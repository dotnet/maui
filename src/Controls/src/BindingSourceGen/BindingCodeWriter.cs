using System.CodeDom.Compiler;
using System.Globalization;
using System.Runtime.InteropServices;

using static Microsoft.Maui.Controls.BindingSourceGen.UnsafeAccessorsMethodName;

namespace Microsoft.Maui.Controls.BindingSourceGen;

public static class BindingCodeWriter
{
	private static readonly string NewLine = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "\r\n" : "\n";

	public static string GeneratedCodeAttribute => $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{typeof(BindingCodeWriter).Assembly.FullName}\", \"{typeof(BindingCodeWriter).Assembly.GetName().Version}\")]";

	public static string GenerateCommonCode() => $$"""
		//------------------------------------------------------------------------------
		// <auto-generated>
		//     This code was generated by a .NET MAUI source generator.
		//
		//     Changes to this file may cause incorrect behavior and will be lost if
		//     the code is regenerated.
		// </auto-generated>
		//------------------------------------------------------------------------------
		#nullable enable

		namespace Microsoft.Maui.Controls.Generated
		{
			{{GeneratedCodeAttribute}}
			internal static partial class GeneratedBindingInterceptors
			{
				private static bool ShouldUseSetter(BindingMode mode, BindableProperty bindableProperty)
					=> mode == BindingMode.OneWayToSource
						|| mode == BindingMode.TwoWay
						|| (mode == BindingMode.Default
							&& (bindableProperty.DefaultBindingMode == BindingMode.OneWayToSource
								|| bindableProperty.DefaultBindingMode == BindingMode.TwoWay));

				private static bool ShouldUseSetter(BindingMode mode)
					=> mode == BindingMode.OneWayToSource
						|| mode == BindingMode.TwoWay
						|| mode == BindingMode.Default;
			}
		}
		""";

	public static string GenerateBinding(BindingInvocationDescription binding, string methodName) => $$"""
		//------------------------------------------------------------------------------
		// <auto-generated>
		//     This code was generated by a .NET MAUI source generator.
		//
		//     Changes to this file may cause incorrect behavior and will be lost if
		//     the code is regenerated.
		// </auto-generated>
		//------------------------------------------------------------------------------
		#nullable enable

		namespace System.Runtime.CompilerServices
		{
			using System;
			using System.Diagnostics;
		
			{{GeneratedCodeAttribute}}
			[Conditional("DEBUG")]
			[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
			file sealed class InterceptsLocationAttribute : Attribute
			{
				public InterceptsLocationAttribute(int version, string data)
				{
					_ = version;
					_ = data;
				}
			}
		}

		namespace Microsoft.Maui.Controls.Generated
		{
			internal static partial class GeneratedBindingInterceptors
			{
				{{GenerateBindingMethod(binding, methodName)}}
			}
		}
		""";

	public static string GenerateBindingMethod(BindingInvocationDescription binding, string methodName, int indent = 2, BindingPropertyFlags propertyFlags = BindingPropertyFlags.All)
	{
		if (!binding.NullableContextEnabled)
		{
			var referenceTypesConditionalAccessTransformer = new ReferenceTypesConditionalAccessTransformer();
			binding = referenceTypesConditionalAccessTransformer.Transform(binding);
		}

		using var builder = new BindingInterceptorCodeBuilder(indent);
		builder.AppendBindingFactoryMethod(binding, methodName, propertyFlags);
		return builder.ToString();
	}

	public sealed class BindingInterceptorCodeBuilder : IDisposable
	{
		private StringWriter _stringWriter;
		private IndentedTextWriter _indentedTextWriter;

		public override string ToString()
		{
			_indentedTextWriter.Flush();
			return _stringWriter.ToString();
		}

		public BindingInterceptorCodeBuilder(int indent = 0)
		{
			_stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			_indentedTextWriter = new IndentedTextWriter(_stringWriter, "\t") { Indent = indent };
		}

		public void AppendBindingFactoryMethod(BindingInvocationDescription binding, string methodName, BindingPropertyFlags propertyFlags = BindingPropertyFlags.All)
		{
			AppendLine(GeneratedCodeAttribute);
			if (binding.InterceptableLocation is not null)
			{
				AppendInterceptorAttribute(binding.InterceptableLocation);
			}
			AppendMethodName(binding, methodName);
			if (binding.SourceType.IsGenericParameter && binding.PropertyType.IsGenericParameter)
			{
				Append($"<{binding.SourceType}, {binding.PropertyType}>");
			}
			else if (binding.SourceType.IsGenericParameter)
			{
				Append($"<{binding.SourceType}>");
			}
			else if (binding.PropertyType.IsGenericParameter)
			{
				Append($"<{binding.PropertyType}>");
			}
			AppendFunctionArguments(binding);

			AppendLine('{');
			Indent();

			// Initialize setter
			AppendLines($$"""
				global::System.Action<{{binding.SourceType}}, {{binding.PropertyType}}>? setter = null;
				if ({{GetShouldUseSetterCall(binding.MethodType)}})
				{
				""");

			Indent();
			Indent();

			Append("setter = ");
			if (binding.SetterOptions.IsWritable)
			{
				AppendSetterLambda(binding);
			}
			else
			{
				AppendLine("static (source, value) =>");
				AppendLine('{');
				Indent();
				AppendLine("throw new global::System.InvalidOperationException(\"Cannot set value on the source object.\");");
				Unindent();
				AppendLine("};");
			}

			Unindent();
			Unindent();

			AppendLine('}');
			AppendBlankLine();

			// Generate the GetHandlers local function first (returns handlersCount)
			var handlersCount = AppendHandlersLocalFunction(binding);

			// Create instance of TypedBinding
			AppendLines($$"""
				var binding = new global::Microsoft.Maui.Controls.Internals.TypedBinding<{{binding.SourceType}}, {{binding.PropertyType}}>(
					getter: source => (getter(source), true),
					setter,
					handlersCount: {{handlersCount}},
				""");
			Indent();

			Append(handlersCount > 0 ? "GetHandlers" : "handlers: null");
			Append(")");;
			Unindent();
			Unindent();
			
			// Only generate property setters for the properties indicated by the flags
			AppendBindingPropertySetters(propertyFlags);
			AppendLine(";");
			AppendBlankLine();

			// Set binding
			if (binding.MethodType == InterceptedMethodType.SetBinding)
			{
				AppendLine("bindableObject.SetBinding(bindableProperty, binding);");
			}
			else if (binding.MethodType == InterceptedMethodType.Create)
			{
				AppendLine("return binding;");
			}
			else
			{
				throw new ArgumentOutOfRangeException(nameof(binding.MethodType));
			}

			AppendUnsafeAccessors(binding);

			Unindent();
			AppendLine('}');
		}

		private void AppendFunctionArguments(BindingInvocationDescription binding)
		{
			AppendLine('(');
			Indent();

			if (binding.MethodType == InterceptedMethodType.SetBinding)
			{
				AppendLines($$"""
					this global::Microsoft.Maui.Controls.BindableObject bindableObject,
					global::Microsoft.Maui.Controls.BindableProperty bindableProperty,
					""");
			}

			AppendLines($$"""
				global::System.Func<{{binding.SourceType}}, {{binding.PropertyType}}> getter,
				global::Microsoft.Maui.Controls.BindingMode mode = global::Microsoft.Maui.Controls.BindingMode.Default,
				global::Microsoft.Maui.Controls.IValueConverter? converter = null,
				object? converterParameter = null,
				string? stringFormat = null,
				object? source = null,
				object? fallbackValue = null,
				object? targetNullValue = null)
				""");

			Unindent();
		}

		private static string GetShouldUseSetterCall(InterceptedMethodType interceptedMethodType) =>
			interceptedMethodType switch
			{
				InterceptedMethodType.SetBinding => "ShouldUseSetter(mode, bindableProperty)",
				InterceptedMethodType.Create => "ShouldUseSetter(mode)",
				_ => throw new ArgumentOutOfRangeException(nameof(interceptedMethodType))
			};


		private void AppendMethodName(BindingInvocationDescription binding, string methodName)
		{
			var visibility = binding.IsPublic ? "public " : "";
			var returnType = binding.MethodType switch
			{
				InterceptedMethodType.SetBinding => "void",
				InterceptedMethodType.Create => "global::Microsoft.Maui.Controls.BindingBase",
				_ => throw new ArgumentOutOfRangeException(nameof(binding.MethodType))
			};

			Append($"{visibility}static {returnType} {methodName}");
		}

		private void AppendInterceptorAttribute(InterceptableLocationRecord location)
		{
			AppendLine($"[global::System.Runtime.CompilerServices.InterceptsLocationAttribute({location.Version}, @\"{location.Data}\")]");
		}

	private void AppendSetterLambda(BindingInvocationDescription binding, string sourceVariableName = "source", string valueVariableName = "value")
	{
		// The setter lambda is always static because it only accesses its parameters and local functions
		// (unsafe accessors are static extern local functions that can be called from static lambdas)
		AppendLine($"static ({sourceVariableName}, {valueVariableName}) =>");
			AppendLine('{');
			Indent();

			var assignedValueExpression = valueVariableName;

			// early return for nullable values if the setter doesn't accept them
			if (binding.PropertyType.IsNullable && !binding.SetterOptions.AcceptsNullValue)
			{
				if (binding.PropertyType.IsValueType)
				{
					AppendLine($"if (!{valueVariableName}.HasValue)");
					assignedValueExpression = $"{valueVariableName}.Value";
				}
				else
				{
					AppendLine($"if ({valueVariableName} is null)");
				}
				AppendLine('{');
				Indent();
				AppendLine("return;");
				Unindent();
				AppendLine('}');
			}

			var setter = Setter.From(binding.Path, sourceVariableName, assignedValueExpression);
			if (setter.PatternMatchingExpressions.Length > 0)
			{
				Append("if (");

				for (int i = 0; i < setter.PatternMatchingExpressions.Length; i++)
				{
					if (i == 1)
					{
						Indent();
					}

					if (i > 0)
					{
						AppendBlankLine();
						Append("&& ");
					}

					Append(setter.PatternMatchingExpressions[i]);
				}

				AppendLine(')');
				if (setter.PatternMatchingExpressions.Length > 1)
				{
					Unindent();
				}

				AppendLine('{');
				Indent();
			}

			AppendLine(setter.AssignmentStatement);

			if (setter.PatternMatchingExpressions.Length > 0)
			{
				Unindent();
				AppendLine('}');
			}

			Unindent();
			AppendLine("};");
		}

	/// <summary>
	/// Generates the GetHandlers local function.
	/// Returns the handlers count, or 0 if the path is empty.
	/// </summary>
	private int AppendHandlersLocalFunction(BindingInvocationDescription binding)
	{
		if (!binding.Path.Any())
		{
			return 0;
		}

		int handlersCount = 0;
		var statements = new List<string>();

		string currentVar = "source";
		int varIndex = 0;
		// If the source type is nullable, we need to use conditional access from the start
		bool useConditionalAccess = binding.SourceType.IsNullable;
		var pathList = binding.Path.ToList();
		
		// Track whether the previous part was a cast (which means subsequent access needs ?.)
		bool afterCast = false;
		
		// Single pass: interleave yield statements and variable declarations
		// Pattern: for each part, first yield for the current variable, then declare the next variable
		for (int i = 0; i < pathList.Count; i++)
		{
			var part = pathList[i];

			// Handle Cast parts - they generate their own variable statement when followed by ConditionalAccess
			if (part is Cast castPart)
			{
				// If the next part is a ConditionalAccess, generate a separate cast variable
				// Otherwise, the cast is combined with the preceding MemberAccess
				if (i + 1 < pathList.Count && pathList[i + 1] is ConditionalAccess && HasSubsequentHandlerPart(pathList, i + 1))
				{
					var targetType = castPart.TargetType;
					var castExpression = targetType.IsValueType 
						? $"({currentVar} as {targetType.GlobalName}?)"
						: $"({currentVar} as {targetType.GlobalName})";
					var nextVar = $"p{varIndex++}";
					statements.Add($"var {nextVar} = {castExpression};");
					currentVar = nextVar;
					afterCast = true;
				}
				continue;
			}

			// First: emit yield statement for current part using the current variable
			string? propertyName = GetPropertyName(part);
			if (propertyName != null)
			{
			// Yield the handler based on whether the type implements INPC
			if (part is MemberAccess memberAccess)
			{
				if (memberAccess.DefinitelyImplementsINPC)
				{
					// Type definitely implements INPC, no cast needed
					statements.Add($"yield return ({currentVar}, \"{propertyName}\");");
					handlersCount++;
				}
				else if (memberAccess.MaybeImplementsINPC)
				{
					// Type might implement INPC at runtime, use is pattern
					var handlerVar = $"p{varIndex++}";
					statements.Add($"if ({currentVar} is {INPC} {handlerVar}) yield return ({handlerVar}, \"{propertyName}\");");
					handlersCount++;
				}
			}
			else if (part is IndexAccess indexAccess)
			{
				if (indexAccess.DefinitelyImplementsINPC)
				{
					// Type definitely implements INPC, no cast needed
					statements.Add($"yield return ({currentVar}, \"{propertyName}\");");
					handlersCount++;
				}
				else if (indexAccess.MaybeImplementsINPC)
				{
					// Type might implement INPC at runtime, use is pattern
					var handlerVar = $"p{varIndex++}";
					statements.Add($"if ({currentVar} is {INPC} {handlerVar}) yield return ({handlerVar}, \"{propertyName}\");");
					handlersCount++;
				}
			}
			else if (part is ConditionalAccess ca && ca.Part is MemberAccess caMemberAccess)
			{
				if (caMemberAccess.DefinitelyImplementsINPC)
				{
					statements.Add($"yield return ({currentVar}, \"{propertyName}\");");
					handlersCount++;
				}
				else if (caMemberAccess.MaybeImplementsINPC)
				{
					var handlerVar = $"p{varIndex++}";
					statements.Add($"if ({currentVar} is {INPC} {handlerVar}) yield return ({handlerVar}, \"{propertyName}\");");
					handlersCount++;
				}
			}
			else if (part is ConditionalAccess caIdx && caIdx.Part is IndexAccess caIndexAccess)
			{
				if (caIndexAccess.DefinitelyImplementsINPC)
				{
					statements.Add($"yield return ({currentVar}, \"{propertyName}\");");
					handlersCount++;
				}
				else if (caIndexAccess.MaybeImplementsINPC)
				{
					var handlerVar = $"p{varIndex++}";
					statements.Add($"if ({currentVar} is {INPC} {handlerVar}) yield return ({handlerVar}, \"{propertyName}\");");
					handlersCount++;
				}
			}

			// For indexers, also yield a handler for the specific indexed property
			if (part is IndexAccess || (part is ConditionalAccess { Part: IndexAccess }))
			{
				var idx = part is IndexAccess ia ? ia : ((ConditionalAccess)part).Part as IndexAccess;
				if (idx != null)
				{
					if (idx.DefinitelyImplementsINPC)
					{
						statements.Add($"yield return ({currentVar}, \"{idx.PropertyName}\");");
						handlersCount++;
					}
					else if (idx.MaybeImplementsINPC)
					{
						var handlerVar = $"p{varIndex++}";
						statements.Add($"if ({currentVar} is {INPC} {handlerVar}) yield return ({handlerVar}, \"{idx.PropertyName}\");");
						handlersCount++;
					}
				}
			}
		}

		// Check if there's a Cast immediately following this part
		// Combine it with the current MemberAccess variable declaration
		Cast? followingCast = null;
		if (i + 1 < pathList.Count && pathList[i + 1] is Cast cast)
		{
			followingCast = cast;
		}

		// Check if there's a subsequent handler part (skipping over casts)
		bool hasSubsequent = HasSubsequentHandlerPart(pathList, i + 1);

		// Second: declare the next variable (if there's a subsequent part that will use it)
		if (hasSubsequent)
			{
				var memberExpression = BuildNextExpression(currentVar, part, useConditionalAccess || afterCast);
				
				// If there's a following cast to be combined, include it in the variable assignment
				string nextExpression;
				if (followingCast != null)
				{
					var targetType = followingCast.TargetType;
					nextExpression = targetType.IsValueType 
						? $"({memberExpression} as {targetType.GlobalName}?)"
						: $"({memberExpression} as {targetType.GlobalName})";
					afterCast = true;  // Next access needs conditional access
					i++; // Skip the Cast part, it's been combined with this MemberAccess
				}
				else
				{
					nextExpression = memberExpression;
					bool wasConditionalAccess = useConditionalAccess || afterCast;
					afterCast = false;
					
					// Determine if subsequent accesses need conditional access (?.)
					var innerPart = part is ConditionalAccess ca ? ca.Part : part;
					if (innerPart is MemberAccess memberAccess && memberAccess.MemberType?.IsNullable == true)
					{
						useConditionalAccess = true;
					}
					else if (innerPart is IndexAccess)
					{
						useConditionalAccess = true;
					}
					else if (wasConditionalAccess)
					{
						// After conditional access (?.), the result can be null
						// (value types become Nullable<T>, references become nullable)
						// so subsequent accesses also need ?.
						useConditionalAccess = true;
					}
					else
					{
						useConditionalAccess = false;
					}
				}
				
				var nextVar = $"p{varIndex++}";
				statements.Add($"var {nextVar} = {nextExpression};");
				currentVar = nextVar;
			}
		}

		// Check if any part after startIndex will yield a handler (has a property name)
		// Note: We don't filter by INPC because the original code generates handlers for ALL parts
		static bool HasSubsequentHandlerPart(List<IPathPart> pathList, int startIndex)
		{
			for (int j = startIndex; j < pathList.Count; j++)
			{
				var nextPart = pathList[j];
				if (nextPart is Cast)
				{
					continue;
				}
				if (GetPropertyName(nextPart) != null)
				{
					return true;
				}
			}
			return false;
		}

		// If no handlers were generated, don't generate the function
		if (handlersCount == 0)
		{
			return 0;
		}

		// The GetHandlers function is always static because:
		// - Unsafe accessors are static extern local functions that can be called from static methods
		// - The function only accesses its parameter 'source' and other static local functions

		// Generate the local function
		AppendLine($"static {IEnumerableOfINPCTuple} GetHandlers({binding.SourceType} source)");
		AppendLine('{');
		Indent();

		// Output all interleaved statements (yield return followed by var declarations)
		foreach (var statement in statements)
		{
			AppendLine(statement);
		}

		Unindent();
		AppendLine('}');
		AppendBlankLine();

		return handlersCount;

		static string? GetPropertyName(IPathPart part) => part switch
		{
			MemberAccess memberAccess => memberAccess.PropertyName,
			IndexAccess indexAccess => indexAccess.DefaultMemberName,
			ConditionalAccess { Part: MemberAccess innerMember } => innerMember.PropertyName,
			ConditionalAccess { Part: IndexAccess innerIndex } => innerIndex.DefaultMemberName,
			_ => null, // Casts don't have property names
		};

		static string BuildNextExpression(string currentVar, IPathPart part, bool useConditionalAccess)
		{
			// If the part is wrapped in ConditionalAccess, we should use ?.
			// Otherwise, use the passed-in useConditionalAccess flag
			bool shouldUseConditionalAccess = part is ConditionalAccess || useConditionalAccess;
			
			// Unwrap ConditionalAccess to get the actual part
			var innerPart = part is ConditionalAccess ca ? ca.Part : part;
			var conditionalOp = shouldUseConditionalAccess ? "?" : "";

			var baseExpression = innerPart switch
			{
				IndexAccess { Index: int numericIndex } => 
					$"{currentVar}{conditionalOp}[{numericIndex}]",
				IndexAccess { Index: string stringIndex } => 
					$"{currentVar}{conditionalOp}[\"{stringIndex}\"]",
				MemberAccess { Kind: AccessorKind.Field, IsGetterAccessible: false } memberAccess => 
					$"{UnsafeAccessorsMethodName.CreateUnsafeFieldAccessorMethodName(memberAccess.MemberName)}({currentVar})",
				MemberAccess { Kind: AccessorKind.Property, IsGetterAccessible: false } memberAccess => 
					$"{UnsafeAccessorsMethodName.CreateUnsafePropertyAccessorGetMethodName(memberAccess.MemberName)}({currentVar})",
				MemberAccess memberAccess => 
					$"{currentVar}{conditionalOp}.{memberAccess.MemberName}",
				_ => throw new NotSupportedException($"Unsupported path part type: {innerPart.GetType()}"),
			};

			return baseExpression;
		}
	}

		private const string INPC = "global::System.ComponentModel.INotifyPropertyChanged";
		private const string IEnumerableOfINPCTuple = $"global::System.Collections.Generic.IEnumerable<global::System.ValueTuple<{INPC}?, string>>";

		private void AppendBindingPropertySetters(BindingPropertyFlags propertyFlags)
		{
			// Skip initializer block entirely if no properties need to be set
			if (propertyFlags == BindingPropertyFlags.None)
			{
				return;
			}

			// Use object initializer syntax for cleaner, shorter code
			AppendBlankLine();
			AppendLine('{');
			Indent();
			
			if (propertyFlags.HasFlag(BindingPropertyFlags.Mode))
				AppendLine("Mode = mode,");
			if (propertyFlags.HasFlag(BindingPropertyFlags.Converter))
				AppendLine("Converter = converter,");
			if (propertyFlags.HasFlag(BindingPropertyFlags.ConverterParameter))
				AppendLine("ConverterParameter = converterParameter,");
			if (propertyFlags.HasFlag(BindingPropertyFlags.StringFormat))
				AppendLine("StringFormat = stringFormat,");
			if (propertyFlags.HasFlag(BindingPropertyFlags.Source))
				AppendLine("Source = source,");
			if (propertyFlags.HasFlag(BindingPropertyFlags.FallbackValue))
				AppendLine("FallbackValue = fallbackValue,");
			if (propertyFlags.HasFlag(BindingPropertyFlags.TargetNullValue))
				AppendLine("TargetNullValue = targetNullValue,");
			
			Unindent();
			Append('}');
		}

		private void AppendUnsafeAccessors(BindingInvocationDescription binding)
		{
			// Append unsafe accessors as local methods for members with inaccessible accessors
			var membersWithInaccessibleAccessors = binding.Path.OfType<MemberAccess>().Where(m => m.HasInaccessibleAccessor);

			foreach (var member in membersWithInaccessibleAccessors)
			{
				AppendBlankLine();

				// Members with inaccessible accessors must have MemberType and ContainingType populated
				// by PathParser during source analysis
				if (member.MemberType == null || member.ContainingType == null)
				{
					throw new InvalidOperationException($"Member '{member.MemberName}' with inaccessible accessor must have MemberType and ContainingType populated.");
				}

				if (member.Kind == AccessorKind.Field)
				{
					AppendUnsafeFieldAccessor(member.MemberName, member.MemberType.GlobalName, member.ContainingType.GlobalName);
				}
				else if (member.Kind == AccessorKind.Property)
				{
					bool isLastPart = member.Equals(binding.Path.Last());
					bool needsGetterForLastPart = binding.RequiresAllUnsafeGetters;

					if (!member.IsGetterAccessible && (!isLastPart || needsGetterForLastPart))
					{
						// we don't need the unsafe getter if the item is the very last part of the path
						// because we don't need to access its value while constructing the handlers array
						AppendUnsafePropertyGetAccessors(member.MemberName, member.MemberType.GlobalName, member.ContainingType.GlobalName);
					}

					if (!member.IsSetterAccessible && isLastPart && binding.SetterOptions.IsWritable)
					{
						// We only need the unsafe setter if the item is the very last part of the path
						AppendUnsafePropertySetAccessors(member.MemberName, member.MemberType.GlobalName, member.ContainingType.GlobalName);
					}
				}
				else
				{
					throw new ArgumentException(nameof(member.Kind));
				}
			}

		}

		private void AppendUnsafeFieldAccessor(string fieldName, string memberType, string containingType)
			=> AppendLines($$"""
				[global::System.Runtime.CompilerServices.UnsafeAccessor(global::System.Runtime.CompilerServices.UnsafeAccessorKind.Field, Name = "{{fieldName}}")]
				static extern ref {{memberType}} {{CreateUnsafeFieldAccessorMethodName(fieldName)}}({{containingType}} source);
				""");

		private void AppendUnsafePropertyGetAccessors(string propertyName, string memberType, string containingType)
			=> AppendLines($$"""
				[global::System.Runtime.CompilerServices.UnsafeAccessor(global::System.Runtime.CompilerServices.UnsafeAccessorKind.Method, Name = "get_{{propertyName}}")]
				static extern {{memberType}} {{CreateUnsafePropertyAccessorGetMethodName(propertyName)}}({{containingType}} source);
				""");

		private void AppendUnsafePropertySetAccessors(string propertyName, string memberType, string containingType)
			=> AppendLines($$"""
				[global::System.Runtime.CompilerServices.UnsafeAccessor(global::System.Runtime.CompilerServices.UnsafeAccessorKind.Method, Name = "set_{{propertyName}}")]
				static extern void {{CreateUnsafePropertyAccessorSetMethodName(propertyName)}}({{containingType}} source, {{memberType}} value);
				""");

		public void Dispose()
		{
			_indentedTextWriter.Dispose();
			_stringWriter.Dispose();
		}

		private void AppendBlankLine() => _indentedTextWriter.WriteLine();
		private void AppendLine(string line) => _indentedTextWriter.WriteLine(line);
		private void AppendLine(char character) => _indentedTextWriter.WriteLine(character);
		private void Append(string str) => _indentedTextWriter.Write(str);
		private void Append(char character) => _indentedTextWriter.Write(character);

		private readonly char[] LineSeparators = ['\n', '\r'];
		private void AppendLines(string lines)
		{
			foreach (var line in lines.Split(LineSeparators, StringSplitOptions.RemoveEmptyEntries))
			{
				AppendLine(line);
			}
		}

		private void Indent() => _indentedTextWriter.Indent++;
		private void Unindent() => _indentedTextWriter.Indent--;
	}
}
