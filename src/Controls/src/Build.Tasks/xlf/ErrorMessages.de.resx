<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AdderMissing" xml:space="preserve">
    <value>Für "{0}{1}" wurde keine Add()-Methode definiert.</value>
    <comment>0 is type name, 1 is property name</comment>
  </data>
  <data name="BindingIndexerEmpty" xml:space="preserve">
    <value>Bindung: Der Indexer enthielt keine Argumente.</value>
  </data>
  <data name="BindingIndexerNotClosed" xml:space="preserve">
    <value>Bindung: Der Indexer enthielt keine schließende Klammer.</value>
  </data>
  <data name="BindingIndexerParse" xml:space="preserve">
    <value>Bindung: "{0}" kann nicht als Index für "{1}" analysiert werden.</value>
    <comment>0 is indexer value, 1 is property name</comment>
  </data>
  <data name="BindingIndexerTypeUnsupported" xml:space="preserve">
    <value>Binding: nicht unterstützter Indexer-Indextyp: "{0}".</value>
    <comment>0 is indexer type name</comment>
  </data>
  <data name="BindingPropertyNotFound" xml:space="preserve">
    <value>Bindung: Die Eigenschaft "{0}" wurde in "{1}" nicht gefunden.</value>
    <comment>0 is property name, 1 is type name</comment>
  </data>
  <data name="BPMissingGetter" xml:space="preserve">
    <value>Es fehlt eine Methode "public static Get{0}" oder ein Eigenschaftengetter der öffentlichen Instanz für die angefügte Eigenschaft "{1}.{0}Property".</value>
    <comment>0 is BindableProperty name, 1 is the declaring type</comment>
  </data>
  <data name="BPName" xml:space="preserve">
    <value>Der Name der BindableProperty "{0}" endet nicht mit "Property".</value>
    <comment>0 is BindableProperty name</comment>
  </data>
  <data name="ConstructorDefaultMissing" xml:space="preserve">
    <value>Fehlender Standardkonstruktor für "{0}".</value>
    <comment>0 is type name</comment>
  </data>
  <data name="ConstructorXArgsMissing" xml:space="preserve">
    <value>Fehlender Konstruktor für "{0}" mit übereinstimmendem Attribut "x:Arguments".</value>
    <comment>0 is type name</comment>
  </data>
  <data name="ContentPropertyAttributeMissing" xml:space="preserve">
    <value>Der Inhalt von "{0}" kann nicht festgelegt werden, weil kein [ContentProperty]-Attribut vorhanden ist.</value>
    <comment>0 is type name</comment>
  </data>
  <data name="Conversion" xml:space="preserve">
    <value>Der Wert "{0}" kann nicht in "{1}" konvertiert werden.</value>
    <comment>0 is a value, 1 is a type</comment>
  </data>
  <data name="EnumValueMissing" xml:space="preserve">
    <value>Der Enumerationswert für "{0}" wurde nicht gefunden.</value>
    <comment>0 is enum value</comment>
  </data>
  <data name="InvalidXaml" xml:space="preserve">
    <value>Ungültiger XAML-Codeausschnitt "{0}".</value>
    <comment>0 is the invalid xaml snippet</comment>
  </data>
  <data name="MarkupNotClosed" xml:space="preserve">
    <value>Der Markupausdruck wurde nicht geschlossen.</value>
  </data>
  <data name="MarkupParsingFailed" xml:space="preserve">
    <value>Fehler beim Analysieren des Markupausdrucks.</value>
  </data>
  <data name="MemberResolution" xml:space="preserve">
    <value>Für "{0}" wurde keine Eigenschaft, keine BindableProperty oder kein Ereignis gefunden, oder es gibt eine Typdiskrepanz zwischen Wert und Eigenschaft.</value>
    <comment>0 is member name</comment>
  </data>
  <data name="MethodStaticMissing" xml:space="preserve">
    <value>Für "{0}::{1} ({2})" wurde keine statische Methode gefunden.</value>
    <comment>0 is type name, 1 is methodname, 2 is type arg list</comment>
  </data>
  <data name="MissingEventHandler" xml:space="preserve">
    <value>Der EventHandler "{0}" mit der richtigen Signatur wurde im Typ "{1}" nicht gefunden.</value>
    <comment>0 is the handler name, 1 is the declaring type</comment>
  </data>
  <data name="NamescopeDuplicate" xml:space="preserve">
    <value>Ein Element mit dem Namen "{0}" ist in diesem NameScope bereits vorhanden.</value>
    <comment>0 is the duplicated key</comment>
  </data>
  <data name="PropertyMissing" xml:space="preserve">
    <value>Die erforderliche Eigenschaft "{0}" für "{1}" fehlt.</value>
    <comment>0 is a property name, 1 is a type</comment>
  </data>
  <data name="PropertyResolution" xml:space="preserve">
    <value>Die Eigenschaft "{0}" für den Typ "{1} (Eigenschaft fehlt oder fehlende Accessoren)" kann nicht aufgelöst werden.</value>
    <comment>0 is a property name, 1 is a type name</comment>
  </data>
  <data name="ResourceDictDuplicateKey" xml:space="preserve">
    <value>"Eine Ressource mit dem Schlüssel "{0}" ist im ResourceDictionary bereits vorhanden.</value>
    <comment>0 is key name</comment>
  </data>
  <data name="ResourceDictMissingKey" xml:space="preserve">
    <value>Die Ressourcen im ResourceDictionary erfordern ein x:Key-Attribut.</value>
  </data>
  <data name="ResourceMissing" xml:space="preserve">
    <value>Die Ressource "{0}" wurde nicht gefunden.</value>
    <comment>0 is a resourceId</comment>
  </data>
  <data name="SByteEnums" xml:space="preserve">
    <value>Mehrwertige Enumerationen sind für sbyte-Enumerationstypen ungültig.</value>
  </data>
  <data name="StyleSheetNoSourceOrContent" xml:space="preserve">
    <value>Das StyleSheet erfordert entweder eine Source-Eigenschaft oder einen Inhalt.</value>
  </data>
  <data name="StyleSheetSourceNotALiteral" xml:space="preserve">
    <value>Die Source-Eigenschaft ist kein Zeichenfolgenliteral.</value>
  </data>
  <data name="StyleSheetSourceOrContent" xml:space="preserve">
    <value>Das StyleSheet kann nicht gleichzeitig eine Source-Eigenschaft und einen Inhalt aufweisen.</value>
  </data>
  <data name="StyleSheetStyleNotALiteral" xml:space="preserve">
    <value>Die Style-Eigenschaft oder der Inhalt ist kein Zeichenfolgenliteral.</value>
  </data>
  <data name="TypeResolution" xml:space="preserve">
    <value>Der Typ "{0}" kann nicht aufgelöst werden.</value>
    <comment>0 is a type name</comment>
  </data>
  <data name="XDataTypeSyntax" xml:space="preserve">
    <value>x:DataType erwartet ein Zeichenfolgenliteral, ein {{x:Type}}-Markup oder {{x:Nul}l}.</value>
  </data>
  <data name="XmlnsUndeclared" xml:space="preserve">
    <value>Nicht deklariertes xmlns-Präfix "{0}".</value>
    <comment>0 is the xmlns prefix</comment>
  </data>
  <data name="XStaticResolution" xml:space="preserve">
    <value>x:Static: Ein öffentliches – oder zugängliches internes – statisches Feld, eine statische Eigenschaft oder ein const- oder enum-Wert mit dem Namen "{0}" wurde in "{1}" nicht gefunden.</value>
    <comment>0 is membername, 1 is type name</comment>
  </data>
  <data name="XStaticSyntax" xml:space="preserve">
    <value>Die Syntax für "x:Static" lautet "[Member=][prefix:]typeName.staticMemberName".</value>
  </data>
  <data name="XKeyNotLiteral" xml:space="preserve">
    <value>Für "x:Key" wird ein Zeichenfolgenliteral erwartet.</value>
  </data>
</root>