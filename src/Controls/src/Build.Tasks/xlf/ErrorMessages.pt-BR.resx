<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AdderMissing" xml:space="preserve">
    <value>Não foi definido nenhum método Add() em "{0}{1}".</value>
    <comment>0 is type name, 1 is property name</comment>
  </data>
  <data name="BindingIndexerEmpty" xml:space="preserve">
    <value>Associação: o indexador não continha nenhum argumento.</value>
  </data>
  <data name="BindingIndexerNotClosed" xml:space="preserve">
    <value>Associação: o indexador não continha nenhum colchete de fechamento.</value>
  </data>
  <data name="BindingIndexerParse" xml:space="preserve">
    <value>Associação: não é possível analisar "{0}" como um índice de uma "{1}".</value>
    <comment>0 is indexer value, 1 is property name</comment>
  </data>
  <data name="BindingIndexerTypeUnsupported" xml:space="preserve">
    <value>Associação: tipo de índice do indexador sem suporte: "{0}".</value>
    <comment>0 is indexer type name</comment>
  </data>
  <data name="BindingWithoutDataType" xml:space="preserve">
    <value>A associação poderá ser compilada para melhorar o desempenho do runtime se x:DataType for especificado. Confira https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings para obter mais informações.</value>
  </data>
  <data name="BindingWithNullDataType" xml:space="preserve">
    <value>A associação poderá ser compilada para melhorar o desempenho do runtime se x:DataType não for explicitamente nulo. Confira https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings para obter mais informações.</value>
  </data>
  <data name="BindingWithXDataTypeFromOuterScope" xml:space="preserve">
    <value>A associação pode ser compilada incorretamente, pois a anotação x:DataType vem de um escopo externo. Certifique-se de anotar todos os elementos XAML do DataTemplate com o x:DataType correto. Confira https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings para obter mais informações.</value>
  </data>
  <data name="BindingWithSourceCompilationSkipped" xml:space="preserve">
    <value>A associação não foi compilada porque tem uma propriedade Source explicitamente definida e a compilação de associações com Source não está habilitada. Considere habilitar esta otimização definindo &lt;MauiEnableXamlCBindingWithSourceCompilation&gt;true&lt;/MauiEnableXamlCBindingWithSourceCompilation&gt; no arquivo de projeto e certifique-se de que o x:DataType correto esteja especificado para esta associação. Confira https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings para obter mais informações.</value>
  </data>
  <data name="BindingPropertyNotFound" xml:space="preserve">
    <value>Associação: a propriedade "{0}" não foi encontrada em "{1}".</value>
    <comment>0 is property name, 1 is type name</comment>
  </data>
  <data name="BPMissingGetter" xml:space="preserve">
    <value>Um método "public static Get{0}" ou um getter de propriedade de instância pública está ausente da propriedade anexada "{1}.{0}Property".</value>
    <comment>0 is BindableProperty name, 1 is the declaring type</comment>
  </data>
  <data name="BPName" xml:space="preserve">
    <value>O nome da BindableProperty {0} não termina com "Property".</value>
    <comment>0 is BindableProperty name</comment>
  </data>
  <data name="ConstructorDefaultMissing" xml:space="preserve">
    <value>Construtor padrão ausente de "{0}".</value>
    <comment>0 is type name</comment>
  </data>
  <data name="ConstructorXArgsMissing" xml:space="preserve">
    <value>Construtor ausente de "{0}" com x:Arguments correspondentes.</value>
    <comment>0 is type name</comment>
  </data>
  <data name="ContentPropertyAttributeMissing" xml:space="preserve">
    <value>Não é possível definir o conteúdo de "{0}" porque ele não tem um atributo [ContentProperty].</value>
    <comment>0 is type name</comment>
  </data>
  <data name="Conversion" xml:space="preserve">
    <value>Não é possível converter o valor "{0}" em "{1}".</value>
    <comment>0 is a value, 1 is a type</comment>
  </data>
  <data name="EnumValueMissing" xml:space="preserve">
    <value>Valor de enumeração não encontrado para "{0}".</value>
    <comment>0 is enum value</comment>
  </data>
  <data name="InvalidXaml" xml:space="preserve">
    <value>XAML inválido "{0}".</value>
    <comment>0 is the invalid xaml snippet</comment>
  </data>
  <data name="MarkupNotClosed" xml:space="preserve">
    <value>Expressão de marcação não fechada.</value>
  </data>
  <data name="MarkupParsingFailed" xml:space="preserve">
    <value>Erro ao analisar a expressão de marcação.</value>
  </data>
  <data name="MemberResolution" xml:space="preserve">
    <value>Não foi encontrada nenhuma propriedade, nenhuma BindableProperty nem nenhum evento para "{0}". Ou o valor e a propriedade apresentam tipos incompatíveis.</value>
    <comment>0 is member name</comment>
  </data>
  <data name="MethodStaticMissing" xml:space="preserve">
    <value>Não foi encontrado nenhum método estático para "{0}::{1} ({2})".</value>
    <comment>0 is type name, 1 is methodname, 2 is type arg list</comment>
  </data>
  <data name="MissingEventHandler" xml:space="preserve">
    <value>O EventHandler "{0}" com a assinatura correta não foi encontrado no tipo "{1}".</value>
    <comment>0 is the handler name, 1 is the declaring type</comment>
  </data>
  <data name="NamescopeDuplicate" xml:space="preserve">
    <value>Já existe um elemento com o nome "{0}" neste NameScope.</value>
    <comment>0 is the duplicated key</comment>
  </data>
  <data name="ObsoleteProperty" xml:space="preserve">
    <value>Property, Property setter ou BindableProperty "{0}" foram preteridos.</value>
  </data>
  <data name="PropertyMissing" xml:space="preserve">
    <value>Propriedade obrigatória "{0}" ausente de "{1}".</value>
    <comment>0 is a property name, 1 is a type</comment>
  </data>
  <data name="PropertyResolution" xml:space="preserve">
    <value>Não é possível resolver a propriedade "{0}" no tipo "{1} (propriedade ou acessadores ausentes)".</value>
    <comment>0 is a property name, 1 is a type name</comment>
  </data>
  <data name="ResourceDictDuplicateKey" xml:space="preserve">
    <value>"Um recurso com a chave "{0}" já está presente no ResourceDictionary.</value>
    <comment>0 is key name</comment>
  </data>
  <data name="ResourceDictMissingKey" xml:space="preserve">
    <value>Os recursos no ResourceDictionary exigem um atributo x:Key.</value>
  </data>
  <data name="ResourceMissing" xml:space="preserve">
    <value>O recurso "{0}" não foi encontrado.</value>
    <comment>0 is a resourceId</comment>
  </data>
  <data name="SByteEnums" xml:space="preserve">
    <value>Enumerações com valores múltiplos não são válidas em tipos enumerados sbyte.</value>
  </data>
  <data name="StyleSheetNoSourceOrContent" xml:space="preserve">
    <value>A StyleSheet exige uma Origem ou um conteúdo.</value>
  </data>
  <data name="StyleSheetSourceNotALiteral" xml:space="preserve">
    <value>A propriedade de origem não é um literal de cadeia de caracteres.</value>
  </data>
  <data name="StyleSheetSourceOrContent" xml:space="preserve">
    <value>StyleSheet não pode ter uma Fonte e um conteúdo.</value>
  </data>
  <data name="StyleSheetStyleNotALiteral" xml:space="preserve">
    <value>A propriedade ou o Conteúdo de Estilo não é um literal de cadeia de caracteres.</value>
  </data>
  <data name="TypeResolution" xml:space="preserve">
    <value>Não é possível resolver o tipo "{0}".</value>
    <comment>0 is a type name</comment>
  </data>
  <data name="XDataTypeSyntax" xml:space="preserve">
    <value>x:DataType espera um literal de cadeia de caracteres, uma marcação {{x:Type}} ou {{x:Null}}.</value>
  </data>
  <data name="UnattributedMarkupType" xml:space="preserve">
    <value>Considere atribuir a extensão de marcação "{0}" com [RequireService] ou [AcceptEmptyServiceProvider] se nenhuma for exigida.</value>
    <comment>0 is type name</comment>
  </data>
  <data name="XmlnsUndeclared" xml:space="preserve">
    <value>Prefixo xmlns não declarado "{0}".</value>
    <comment>0 is the xmlns prefix</comment>
  </data>
  <data name="XStaticResolution" xml:space="preserve">
    <value>O x:Static: não pôde encontrar um campo estático, uma propriedade estática, um valor const ou enumerado público (ou interno acessível) denominado "{0}" em "{1}".</value>
    <comment>0 is membername, 1 is type name</comment>
  </data>
  <data name="XStaticSyntax" xml:space="preserve">
    <value>A sintaxe de x:Static é "[Member=][prefix:]typeName.staticMemberName".</value>
  </data>
  <data name="XKeyNotLiteral" xml:space="preserve">
    <value>x:Key espera uma cadeia de caracteres literal.</value>
  </data>
  <data name="StaticResourceSyntax" xml:space="preserve">
    <value>Uma chave é necessária em {StaticResource}.</value>
  </data>
</root>