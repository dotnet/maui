<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AdderMissing" xml:space="preserve">
    <value>Nie zdefiniowano metody Add() dla elementu „{0}{1}”.</value>
    <comment>0 is type name, 1 is property name</comment>
  </data>
  <data name="BindingIndexerEmpty" xml:space="preserve">
    <value>Powiązanie: indeksator nie zawierał argumentów.</value>
  </data>
  <data name="BindingIndexerNotClosed" xml:space="preserve">
    <value>Powiązanie: indeksator nie zawierał nawiasu zamykającego.</value>
  </data>
  <data name="BindingIndexerParse" xml:space="preserve">
    <value>Powiązanie: nie można przeanalizować wartości „{0}” jako indeksu dla właściwości „{1}”.</value>
    <comment>0 is indexer value, 1 is property name</comment>
  </data>
  <data name="BindingIndexerTypeUnsupported" xml:space="preserve">
    <value>Powiązanie: nieobsługiwany typ indeksu indeksatora: „{0}”.</value>
    <comment>0 is indexer type name</comment>
  </data>
  <data name="BindingWithoutDataType" xml:space="preserve">
    <value>Powiązanie można skompilować w celu zwiększenia wydajności środowiska uruchomieniowego, jeśli adnotacja x:DataType jest określona. Aby uzyskać więcej informacji, zobacz https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings.</value>
  </data>
  <data name="BindingWithNullDataType" xml:space="preserve">
    <value>Powiązanie można skompilować w celu zwiększenia wydajności środowiska uruchomieniowego, jeśli adnotacja x:DataType nie ma wyraźnie wartości null. Aby uzyskać więcej informacji, zobacz https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings.</value>
  </data>
  <data name="BindingWithXDataTypeFromOuterScope" xml:space="preserve">
    <value>Powiązanie może być niepoprawnie skompilowane, ponieważ adnotacja x:DataType pochodzi z zakresu zewnętrznego. Upewnij się, że adnotujesz wszystkie elementy XAML DataTemplate z poprawną adnotacją x:DataType. Aby uzyskać więcej informacji, zobacz https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings.</value>
  </data>
  <data name="BindingWithSourceCompilationSkipped" xml:space="preserve">
    <value>Powiązanie nie zostało skompilowane, ponieważ ma wyraźnie ustawioną właściwość na wartość Source, a kompilacja powiązania z elementem Source nie jest włączona. Rozważ włączenie tej optymalizacji przez ustawienie na wartość &lt;MauiEnableXamlCBindingWithSourceCompilation&gt;true&lt;/MauiEnableXamlCBindingWithSourceCompilation&gt; w pliku projektu i upewnij się, że dla tego powiązania określono poprawną adnotację x:DataType. Aby uzyskać więcej informacji, zobacz https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/compiled-bindings.</value>
  </data>
  <data name="BindingPropertyNotFound" xml:space="preserve">
    <value>Powiązanie: nie znaleziono właściwości „{0}” w typie „{1}”.</value>
    <comment>0 is property name, 1 is type name</comment>
  </data>
  <data name="BPMissingGetter" xml:space="preserve">
    <value>Brak metody „public static get{0}” lub metody pobierającej właściwość wystąpienia publicznego dla dołączonej właściwości „{1}.{0}Property”.</value>
    <comment>0 is BindableProperty name, 1 is the declaring type</comment>
  </data>
  <data name="BPName" xml:space="preserve">
    <value>Nazwa właściwości BindableProperty {0} nie kończy się ciągiem „Property”.</value>
    <comment>0 is BindableProperty name</comment>
  </data>
  <data name="ConstructorDefaultMissing" xml:space="preserve">
    <value>Brak domyślnego konstruktora dla typu „{0}”.</value>
    <comment>0 is type name</comment>
  </data>
  <data name="ConstructorXArgsMissing" xml:space="preserve">
    <value>Brak konstruktora dla typu „{0}” z pasującym atrybutem x:Arguments.</value>
    <comment>0 is type name</comment>
  </data>
  <data name="ContentPropertyAttributeMissing" xml:space="preserve">
    <value>Nie można ustawić zawartości typu „{0}”, ponieważ nie ma on atrybutu [ContentProperty].</value>
    <comment>0 is type name</comment>
  </data>
  <data name="Conversion" xml:space="preserve">
    <value>Nie można przekonwertować wartości „{0}” na typ „{1}”.</value>
    <comment>0 is a value, 1 is a type</comment>
  </data>
  <data name="EnumValueMissing" xml:space="preserve">
    <value>Nie znaleziono wartości wyliczenia dla wartości „{0}”.</value>
    <comment>0 is enum value</comment>
  </data>
  <data name="InvalidXaml" xml:space="preserve">
    <value>Nieprawidłowy kod XAML „{0}”</value>
    <comment>0 is the invalid xaml snippet</comment>
  </data>
  <data name="MarkupNotClosed" xml:space="preserve">
    <value>Wyrażenie znaczników nie zostało zamknięte.</value>
  </data>
  <data name="MarkupParsingFailed" xml:space="preserve">
    <value>Błąd podczas analizowania wyrażenia znaczników.</value>
  </data>
  <data name="MemberResolution" xml:space="preserve">
    <value>Nie znaleziono właściwości BindableProperty lub zdarzenia dla elementu członkowskiego „{0}” lub wartość i właściwość nie są zgodne.</value>
    <comment>0 is member name</comment>
  </data>
  <data name="MethodStaticMissing" xml:space="preserve">
    <value>Nie znaleziono żadnej metody statycznej dla elementu „{0}::{1} ({2})”.</value>
    <comment>0 is type name, 1 is methodname, 2 is type arg list</comment>
  </data>
  <data name="MissingEventHandler" xml:space="preserve">
    <value>W typie „{1}” nie znaleziono programu obsługi zdarzeń „{0}” z poprawnym podpisem.</value>
    <comment>0 is the handler name, 1 is the declaring type</comment>
  </data>
  <data name="NamescopeDuplicate" xml:space="preserve">
    <value>Element o nazwie „{0}” już istnieje w tym zakresie NameScope.</value>
    <comment>0 is the duplicated key</comment>
  </data>
  <data name="ObsoleteProperty" xml:space="preserve">
    <value>Właściwość, metoda ustawiająca właściwości lub element BindableProperty „{0}” są przestarzałe.</value>
  </data>
  <data name="PropertyMissing" xml:space="preserve">
    <value>Brak obowiązkowej właściwości „{0}” w typie „{1}”.</value>
    <comment>0 is a property name, 1 is a type</comment>
  </data>
  <data name="PropertyResolution" xml:space="preserve">
    <value>Nie można rozpoznać właściwości „{0}” w typie „{1} (brak właściwości lub brak metod dostępu)”.</value>
    <comment>0 is a property name, 1 is a type name</comment>
  </data>
  <data name="ResourceDictDuplicateKey" xml:space="preserve">
    <value>„Zasób z kluczem „{0}” już znajduje się w elemencie ResourceDictionary.</value>
    <comment>0 is key name</comment>
  </data>
  <data name="ResourceDictMissingKey" xml:space="preserve">
    <value>Zasoby w elemencie ResourceDictionary wymagają atrybutu x:Key.</value>
  </data>
  <data name="ResourceMissing" xml:space="preserve">
    <value>Nie znaleziono zasobu „{0}”.</value>
    <comment>0 is a resourceId</comment>
  </data>
  <data name="SByteEnums" xml:space="preserve">
    <value>Wyliczenia z wieloma wartościami nie są prawidłowe dla typów wyliczeń sbyte.</value>
  </data>
  <data name="StyleSheetNoSourceOrContent" xml:space="preserve">
    <value>Arkusz stylów wymaga źródła albo zawartości.</value>
  </data>
  <data name="StyleSheetSourceNotALiteral" xml:space="preserve">
    <value>Właściwość źródłowa nie jest literałem ciągu.</value>
  </data>
  <data name="StyleSheetSourceOrContent" xml:space="preserve">
    <value>Arkusz stylów nie może mieć zarówno elementu Source, jak i zawartości.</value>
  </data>
  <data name="StyleSheetStyleNotALiteral" xml:space="preserve">
    <value>Zawartość lub właściwość stylu nie jest literałem ciągu.</value>
  </data>
  <data name="TypeResolution" xml:space="preserve">
    <value>Nie można rozpoznać typu „{0}”.</value>
    <comment>0 is a type name</comment>
  </data>
  <data name="XDataTypeSyntax" xml:space="preserve">
    <value>Adnotacja x:DataType oczekuje literału ciągu, znacznika {{x:Type}} lub {{x:Null}}.</value>
  </data>
  <data name="UnattributedMarkupType" xml:space="preserve">
    <value>Rozważ przypisanie rozszerzenia znaczników „{0}” z [RequireService] lub [AcceptEmptyServiceProvider], jeśli nie wymaga żadnego rozszerzenia.</value>
    <comment>0 is type name</comment>
  </data>
  <data name="XmlnsUndeclared" xml:space="preserve">
    <value>Niezadeklarowany prefiks xmlns „{0}”.</value>
    <comment>0 is the xmlns prefix</comment>
  </data>
  <data name="XStaticResolution" xml:space="preserve">
    <value>x:Static: nie można odnaleźć publicznego — lub dostępnego wewnętrznie — pola statycznego, właściwości statycznej, stałej lub wartości wyliczenia o nazwie „{0}” w typie „{1}”.</value>
    <comment>0 is membername, 1 is type name</comment>
  </data>
  <data name="XStaticSyntax" xml:space="preserve">
    <value>Składnia elementu x:Static to „[elementCzłonkowski=][prefiks:]nazwaTypu.nazwaStatycznegoElementuCzłonkowskiego”.</value>
  </data>
  <data name="XKeyNotLiteral" xml:space="preserve">
    <value>x: Klawisz oczekuje dosłownego ciągu.</value>
  </data>
  <data name="StaticResourceSyntax" xml:space="preserve">
    <value>Klucz jest wymagany w {StaticResource}.</value>
  </data>
</root>