using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Xml;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

using Microsoft.Maui.Controls.Xaml;

namespace Microsoft.Maui.Controls.SourceGen;

using static GeneratorHelpers;
static class CodeBehindCodeWriter
{

	internal static readonly string[] accessModifiers = ["private", "public", "internal", "protected"];

	public static string GenerateXamlCodeBehind(XamlProjectItemForCB? xamlItem, Compilation compilation, Action<Diagnostic>? reportDiagnostic, CancellationToken ct, AssemblyAttributes xmlnsCache, IDictionary<XmlType, INamedTypeSymbol> typeCache)
	{
		var projItem = xamlItem?.ProjectItem;

		// Get a unique string for this xaml project item
		var itemName = projItem?.ManifestResourceName ?? projItem?.RelativePath;
		if (itemName == null)
			return "";

		if (xamlItem!.Root == null)
		{
			if (xamlItem.Exception != null)
			{
				var location = projItem!.RelativePath is not null ? Location.Create(projItem.RelativePath, new TextSpan(), new LinePositionSpan()) : null;
				reportDiagnostic?.Invoke(Diagnostic.Create(Descriptors.XamlParserError, location, xamlItem.Exception.Message));
			}
			return "";
		}

		var uid = Crc64.ComputeHashString($"{compilation.AssemblyName}.{itemName}");
		if (!TryParseXaml(xamlItem, uid, compilation, xmlnsCache, typeCache, ct, reportDiagnostic, out var accessModifier, out var rootType, out var rootClrNamespace, out var generateDefaultCtor, out var addXamlCompilationAttribute, out var hideFromIntellisense, out var XamlResourceIdOnly, out var baseType, out var namedFields))
		{
			return "";
		}

		var sb = new StringBuilder();
		sb.AppendLine(AutoGeneratedHeaderText);
		var warningDisable = GetWarningDisable(xamlItem.Root.OwnerDocument);
		if (warningDisable != "")
			sb.AppendLine($"#pragma warning disable {warningDisable}");

		var hintName = $"{(string.IsNullOrEmpty(Path.GetDirectoryName(projItem!.TargetPath)) ? "" : Path.GetDirectoryName(projItem.TargetPath) + Path.DirectorySeparatorChar)}{Path.GetFileNameWithoutExtension(projItem.TargetPath)}.{projItem.Kind.ToLowerInvariant()}.sg.cs".Replace(Path.DirectorySeparatorChar, '_');

		if (projItem.ManifestResourceName != null && projItem.RelativePath != null)
		{
			sb.AppendLine($"[assembly: global::Microsoft.Maui.Controls.Xaml.XamlResourceId(\"{projItem.ManifestResourceName}\", \"{projItem.RelativePath.Replace('\\', '/')}\", {(rootType == null ? "null" : "typeof(global::" + rootClrNamespace + "." + rootType + ")")})]");
		}

		if (XamlResourceIdOnly)
		{
			return sb.ToString();
		}

		if (rootType == null)
		{
			throw new Exception("Something went wrong");
		}

		var rootSymbol = compilation.GetTypeByMetadataName($"{rootClrNamespace}.{rootType}");
		bool alreadyHasXamlCompilationAttribute = rootSymbol?.GetAttributes().Any(a => a.AttributeClass != null && a.AttributeClass.Equals(compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.Xaml.XamlCompilationAttribute")!, SymbolEqualityComparer.Default)) ?? false;

		var generateInflatorSwitch = compilation.AssemblyName == "Microsoft.Maui.Controls.Xaml.UnitTests" && !generateDefaultCtor;
		var xamlInflators = projItem.Inflator;
		
		//if there's only the XamlC inflator, prevent non-assigned errors
		if (xamlInflators == XamlInflator.XamlC)
			sb.AppendLine("#pragma warning disable CS0649");

		sb.AppendLine($"namespace {rootClrNamespace}");
		sb.AppendLine("{");
		sb.AppendLine($"\t[global::Microsoft.Maui.Controls.Xaml.XamlFilePath(\"{projItem.RelativePath?.Replace("\\", "\\\\")}\")]");

#if !_MAUIXAML_SOURCEGEN_BACKCOMPAT
		if (addXamlCompilationAttribute && !alreadyHasXamlCompilationAttribute)
			sb.AppendLine($"\t[global::Microsoft.Maui.Controls.Xaml.XamlCompilation(global::Microsoft.Maui.Controls.Xaml.XamlCompilationOptions.Compile)]");
#endif
		if (!addXamlCompilationAttribute && (xamlInflators & XamlInflator.XamlC) == 0 && !alreadyHasXamlCompilationAttribute)
			sb.AppendLine($"\t[global::Microsoft.Maui.Controls.Xaml.XamlCompilation(global::Microsoft.Maui.Controls.Xaml.XamlCompilationOptions.Skip)]");

		if (hideFromIntellisense)
		{
			sb.AppendLine($"\t[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
		}

		if (generateDefaultCtor)
			sb.AppendLine($"\t[global::System.CodeDom.Compiler.GeneratedCode(\"Microsoft.Maui.Controls.SourceGen\", \"1.0.0.0\")]");

		sb.AppendLine($"\t{accessModifier} partial class {rootType} : {baseType!.ToFQDisplayString()}");
		sb.AppendLine("\t{");

		//optional default ctor
		if (generateDefaultCtor)
		{
			sb.AppendLine($"\t\t[global::System.CodeDom.Compiler.GeneratedCode(\"Microsoft.Maui.Controls.SourceGen\", \"1.0.0.0\")]");
			sb.AppendLine($"\t\tpublic {rootType}() => InitializeComponent();");
			sb.AppendLine();
		}

		//create fields
		if (namedFields != null)
		{
			//with XamlC, the body of the ctor is empty when the compiler is done, raising warnings. disable those
			if (!generateInflatorSwitch
				&& ((xamlInflators & XamlInflator.XamlC) == XamlInflator.XamlC
					|| (projItem.Configuration != null && projItem.Configuration.Equals("Release", StringComparison.OrdinalIgnoreCase))))
				sb.AppendLine("#pragma warning disable CS0169, CS0649");

			foreach ((var fname, var ftype, var faccess) in namedFields)
			{
				sb.AppendLine($"\t\t[global::System.CodeDom.Compiler.GeneratedCode(\"Microsoft.Maui.Controls.SourceGen\", \"1.0.0.0\")]");

				sb.AppendLine($"\t\t{faccess} {ftype} {EscapeIdentifier(fname)};");
				sb.AppendLine();
			}
			if (!generateInflatorSwitch
				&& ((xamlInflators & XamlInflator.XamlC) == XamlInflator.XamlC
					|| (projItem.Configuration != null && projItem.Configuration.Equals("Release", StringComparison.OrdinalIgnoreCase))))
				sb.AppendLine("#pragma warning restore CS0169, CS0649");
		}

		// if the generateInflatorSwitch is false, we will, depending on the value of inflators
		// - treat XamlInflator.Default as XamlInflator.Runtime for Debug, and XamlC for Release
		// - generate InitializeComponent() with the LoadFromXaml call for XamlInflator.Runtime
		// - generate an empty InitializeComponent for XamlInflator.XamlC (XamlC will replace the methodbody later)
		// - generate the partial signature for InitializeComponent for XamlInflator.SourceGen

		// if the generateInflatorSwitch is true, we will generate a switch statement in the constructor
		// that will call the correct InitializeComponent method depending on the inflator passed in
		// XamlInflatorDefault means all
		// - InitializeCompnentRuntime will be used for Runtime
		// - InitializeComponentXamlC will be used for XamlC
		// - InitializeComponentSourceGen will be used for SourceGen
		// - no parameterless InitializeComponent will be generated
		if (!generateInflatorSwitch)
		{
			if ((xamlInflators & XamlInflator.Runtime) == XamlInflator.Runtime)
				InitComp("InitializeComponent");
			else if ((xamlInflators & XamlInflator.XamlC) == XamlInflator.XamlC)
				InitComp("InitializeComponent");
			else if ((xamlInflators & XamlInflator.SourceGen) == XamlInflator.SourceGen) {
				InitComp("InitializeComponent", partialsignature: true);
				//generate InitCompRuntime for HotReload fallback
				if (projItem.EnableDiagnostics)
					InitComp("InitializeComponentRuntime");
			}
		}
		else
		{
			if ((xamlInflators & XamlInflator.Runtime) == XamlInflator.Runtime || projItem.EnableDiagnostics)
				InitComp("InitializeComponentRuntime");
			if ((xamlInflators & XamlInflator.XamlC) == XamlInflator.XamlC)
				InitComp("InitializeComponentXamlC", empty: true);
			if ((xamlInflators & XamlInflator.SourceGen) == XamlInflator.SourceGen)
				InitComp("InitializeComponentSourceGen", partialsignature: true);
		}

		//initializeComponent
		void InitComp(string methodName, bool empty = false, bool partialsignature = false)
		{
			sb.AppendLine($"\t\t[global::System.CodeDom.Compiler.GeneratedCode(\"Microsoft.Maui.Controls.SourceGen\", \"1.0.0.0\")]");
			// add MemberNotNull attributes
			if (namedFields != null && namedFields.Any())
			{
				sb.AppendLine($"#if NET5_0_OR_GREATER");
				foreach ((var fname, _, _) in namedFields)				
					sb.AppendLine($"\t\t[global::System.Diagnostics.CodeAnalysis.MemberNotNullAttribute(nameof({EscapeIdentifier(fname)}))]");

				sb.AppendLine($"#endif");
			}

			if (empty)
				sb.AppendLine("#nullable disable");

			var modifier = partialsignature ? "partial " : "";
			var semicolon = partialsignature ? ";" : "";
			sb.AppendLine($"\t\tprivate {modifier}void {methodName}(){semicolon}");
			if (partialsignature)
			{
				sb.AppendLine();
				return;
			}

			sb.AppendLine("\t\t{");
			if (!empty)
			{
				sb.AppendLine("#pragma warning disable IL2026, IL3050 // The body of InitializeComponent will be replaced by XamlC so LoadFromXaml will never be called in production builds");
				sb.AppendLine($"\t\t\tglobal::Microsoft.Maui.Controls.Xaml.Extensions.LoadFromXaml(this, typeof({rootType}));");

				if (namedFields != null)
				{
					foreach ((var fname, var ftype, var faccess) in namedFields)
					{
						sb.AppendLine($"\t\t\t{EscapeIdentifier(fname)} = global::Microsoft.Maui.Controls.NameScopeExtensions.FindByName<{ftype}>(this, \"{fname}\");");
					}
				}
				sb.AppendLine("#pragma warning restore IL2026, IL3050");
			}
			sb.AppendLine("\t\t}");

			if (empty)
			{
				sb.AppendLine("#nullable enable");
			}

			sb.AppendLine();
		}

		if (generateInflatorSwitch)
		{
			sb.AppendLine();

			// add MemberNotNull attributes
			if (namedFields != null && namedFields.Any())
			{
				sb.AppendLine($"#if NET5_0_OR_GREATER");
				foreach ((var fname, _, _) in namedFields)
				{
					sb.AppendLine($"\t\t[global::System.Diagnostics.CodeAnalysis.MemberNotNullAttribute(nameof({EscapeIdentifier(fname)}))]");
				}

				sb.AppendLine($"#endif");
			}

			//this isn't supposed to be used, so the default to the first available inflator
			if ((xamlInflators & XamlInflator.Runtime) == XamlInflator.Runtime)
				sb.AppendLine($"\t\tprivate void InitializeComponent() => InitializeComponentRuntime();");
			else if ((xamlInflators & XamlInflator.SourceGen) == XamlInflator.SourceGen)
				sb.AppendLine($"\t\tprivate void InitializeComponent() => InitializeComponentSourceGen();");
			else if ((xamlInflators & XamlInflator.XamlC) == XamlInflator.XamlC)
				sb.AppendLine($"\t\tprivate void InitializeComponent() => InitializeComponentXamlC();");


			sb.AppendLine($"\t\t[global::System.CodeDom.Compiler.GeneratedCode(\"Microsoft.Maui.Controls.SourceGen\", \"1.0.0.0\")]");

			sb.AppendLine($"\t\tinternal {rootType}(global::Microsoft.Maui.Controls.Xaml.XamlInflator inflator)");
			sb.AppendLine("\t\t{");
			sb.AppendLine("\t\t\tswitch (inflator)");
			sb.AppendLine("\t\t\t{");
			if ((xamlInflators & XamlInflator.Runtime) == XamlInflator.Runtime)
			{
				sb.AppendLine("\t\t\t\tcase global::Microsoft.Maui.Controls.Xaml.XamlInflator.Runtime:");
				sb.AppendLine("\t\t\t\t\tInitializeComponentRuntime();");
				sb.AppendLine("\t\t\t\t\tbreak;");
			}
			if ((xamlInflators & XamlInflator.XamlC) == XamlInflator.XamlC)
			{
				sb.AppendLine("\t\t\t\tcase global::Microsoft.Maui.Controls.Xaml.XamlInflator.XamlC:");
				sb.AppendLine("\t\t\t\t\tInitializeComponentXamlC();");
				sb.AppendLine("\t\t\t\t\tbreak;");
			}
			if ((xamlInflators & XamlInflator.SourceGen) == XamlInflator.SourceGen)
			{
				sb.AppendLine("\t\t\t\tcase global::Microsoft.Maui.Controls.Xaml.XamlInflator.SourceGen:");
				sb.AppendLine("\t\t\t\t\tInitializeComponentSourceGen();");
				sb.AppendLine("\t\t\t\t\tbreak;");
			}
			sb.AppendLine("\t\t\t\tdefault:");
			sb.AppendLine("\t\t\t\t\tthrow new global::System.NotSupportedException($\"no code for {inflator} generated. check the [XamlProcessing] attribute.\");");
			sb.AppendLine("\t\t\t}");
			sb.AppendLine("\t\t}");
		}
		sb.AppendLine("\t}");
		sb.AppendLine("}");

		return sb.ToString();
	}

	public static bool TryParseXaml(XamlProjectItemForCB parseResult, string uid, Compilation compilation, AssemblyAttributes xmlnsCache, IDictionary<XmlType, INamedTypeSymbol> typeCache, CancellationToken cancellationToken, Action<Diagnostic>? reportDiagnostic, out string? accessModifier, out string? rootType, out string? rootClrNamespace, out bool generateDefaultCtor, out bool addXamlCompilationAttribute, out bool hideFromIntellisense, out bool xamlResourceIdOnly, out INamedTypeSymbol? baseType, out IEnumerable<(string, string, string)>? namedFields)
	{
		accessModifier = null;
		rootType = null;
		rootClrNamespace = null;
		generateDefaultCtor = false;
		addXamlCompilationAttribute = false;
		hideFromIntellisense = false;
		xamlResourceIdOnly = false;
		namedFields = null;
		baseType = null;

		cancellationToken.ThrowIfCancellationRequested();

		var root = parseResult.Root;
		var nsmgr = parseResult.Nsmgr;

		if (root == null || nsmgr == null)
		{
			return false;
		}

#if _MAUIXAML_SOURCEGEN_BACKCOMPAT
		// if the following xml processing instruction is present
		//
		// <?xaml-comp compile="true" ?>
		//
		// we will generate a xaml.g.cs file with the default ctor calling InitializeComponent, and a XamlCompilation attribute
		var hasXamlCompilationProcessingInstruction = GetXamlCompilationProcessingInstruction(root.OwnerDocument);
#endif

		var rootClass = root.Attributes["Class", XamlParser.X2006Uri]
					 ?? root.Attributes["Class", XamlParser.X2009Uri];

		if (rootClass != null)
		{
			XmlnsHelper.ParseXmlns(rootClass.Value, out rootType, out rootClrNamespace, out _, out _);
		}
#if _MAUIXAML_SOURCEGEN_BACKCOMPAT
		else if (hasXamlCompilationProcessingInstruction
				&& (root.NamespaceURI == XamlParser.MauiUri || root.NamespaceURI == XamlParser.MauiGlobalUri))
#else
		else if (root.NamespaceURI == XamlParser.MauiUri || root.NamespaceURI == XamlParser.MauiGlobalUri)
#endif
		{
			//make sure the base type can be resolved. if not, don't consider this as xaml, and move away
			var typeArgs = GetAttributeValue(root, "TypeArguments", XamlParser.X2006Uri, XamlParser.X2009Uri);
			try
			{
				var basetype = new XmlType(root.NamespaceURI, root.LocalName, typeArgs != null ? TypeArgumentsParser.ParseExpression(typeArgs, nsmgr, null) : null).GetTypeSymbol(null, compilation, xmlnsCache, typeCache);
			}
			catch
			{
				return false;
			}

			rootClrNamespace = "__XamlGeneratedCode__";
			rootType = $"__Type{uid}";
			generateDefaultCtor = true;
			addXamlCompilationAttribute = true;
			hideFromIntellisense = true;
		}
		else if (parseResult?.ProjectItem?.ManifestResourceName != null && parseResult.ProjectItem.TargetPath != null)
		{ // rootClass == null && !hasXamlCompilationProcessingInstruction) {
			xamlResourceIdOnly = true; //only generate the XamlResourceId assembly attribute
			return true;
		}
		else
		{
			reportDiagnostic?.Invoke(Diagnostic.Create(Descriptors.XamlParserError, Location.None, $"Xaml file {parseResult?.ProjectItem?.RelativePath} does not have a Class attribute"));
			return false;
		}

		namedFields = GetNamedFields(root, nsmgr, compilation, xmlnsCache, typeCache, cancellationToken, reportDiagnostic);
		var typeArguments = GetAttributeValue(root, "TypeArguments", XamlParser.X2006Uri, XamlParser.X2009Uri);
		baseType = new XmlType(root.NamespaceURI, root.LocalName, typeArguments != null ? TypeArgumentsParser.ParseExpression(typeArguments, nsmgr, null) : null).GetTypeSymbol(reportDiagnostic, compilation, xmlnsCache, typeCache);

		// x:ClassModifier attribute
		var classModifier = GetAttributeValue(root, "ClassModifier", XamlParser.X2006Uri, XamlParser.X2009Uri);
		accessModifier = classModifier?.ToLowerInvariant().Replace("notpublic", "internal") ?? "public"; // notpublic is WPF for internal

		return true;
	}

#if _MAUIXAML_SOURCEGEN_BACKCOMPAT
	//true, unless explicitely false
	static bool GetXamlCompilationProcessingInstruction(XmlDocument xmlDoc)
	{
		if (xmlDoc.SelectSingleNode("processing-instruction('xaml-comp')") is not XmlProcessingInstruction instruction)
			return true;

		var parts = instruction.Data.Split(' ', '=');
		var indexOfCompile = Array.IndexOf(parts, "compile");
		if (indexOfCompile != -1)
			return !parts[indexOfCompile + 1].Trim('"', '\'').Equals("false", StringComparison.OrdinalIgnoreCase);

		return true;
	}
#endif

	internal static string GetWarningDisable(XmlDocument xmlDoc)
	{
		var warnings = new List<string>();
		var xamlCompNodes = xmlDoc.SelectNodes("processing-instruction('xaml-comp')");
		foreach (var xamlCompNode in xamlCompNodes)
		{
			if (xamlCompNode is not XmlProcessingInstruction xpi)
				continue;
			var parts = xpi.Data.Split(' ', '=');
			var indexOfWarningDisable = Array.IndexOf(parts, "warning-disable");
			if (indexOfWarningDisable != -1)
				warnings.Add(parts[indexOfWarningDisable + 1].Trim('"', '\''));
		}
		return string.Join(", ", warnings);
	}

	static IEnumerable<(string name, string type, string accessModifier)> GetNamedFields(XmlNode root, XmlNamespaceManager nsmgr, Compilation compilation, AssemblyAttributes xmlnsCache, IDictionary<XmlType, INamedTypeSymbol> typeCache, CancellationToken cancellationToken, Action<Diagnostic>? reportDiagnostic)
	{
		var xPrefix = nsmgr.LookupPrefix(XamlParser.X2006Uri) ?? nsmgr.LookupPrefix(XamlParser.X2009Uri);
		if (xPrefix == null)
		{
			yield break;
		}

		XmlNodeList names =
			root.SelectNodes(
				"//*[@" + xPrefix + ":Name" +
				"][not(ancestor:: __f__:DataTemplate) and not(ancestor:: __f__:ControlTemplate) and not(ancestor:: __f__:Style) and not(ancestor:: __f__:VisualStateManager.VisualStateGroups)" +
				"and not(ancestor:: __g__:DataTemplate) and not(ancestor:: __g__:ControlTemplate) and not(ancestor:: __g__:Style) and not(ancestor:: __g__:VisualStateManager.VisualStateGroups)]", nsmgr);
		foreach (XmlNode node in names)
		{
			cancellationToken.ThrowIfCancellationRequested();

			var name = GetAttributeValue(node, "Name", XamlParser.X2006Uri, XamlParser.X2009Uri) ?? throw new Exception();
			var typeArguments = GetAttributeValue(node, "TypeArguments", XamlParser.X2006Uri, XamlParser.X2009Uri);
			var fieldModifier = GetAttributeValue(node, "FieldModifier", XamlParser.X2006Uri, XamlParser.X2009Uri);

			var xmlType = new XmlType(node.NamespaceURI, node.LocalName,
									  typeArguments != null
									  ? TypeArgumentsParser.ParseExpression(typeArguments, nsmgr, null)
									  : null);

			var accessModifier = fieldModifier?.ToLowerInvariant().Replace("notpublic", "internal") ?? "private"; //notpublic is WPF for internal
			if (!accessModifiers.Contains(accessModifier)) //quick validation
				accessModifier = "private";

			yield return (name ?? "", xmlType.GetTypeSymbol(reportDiagnostic, compilation, xmlnsCache, typeCache)?.ToFQDisplayString() ?? "", accessModifier);
		}
	}

	static string? GetAttributeValue(XmlNode node, string localName, params string[] namespaceURIs)
	{
		if (node == null)
			throw new ArgumentNullException(nameof(node));

		if (localName == null)
			throw new ArgumentNullException(nameof(localName));

		if (namespaceURIs == null)
			throw new ArgumentNullException(nameof(namespaceURIs));

		foreach (var namespaceURI in namespaceURIs)
		{
			var attr = node.Attributes[localName, namespaceURI];
			if (attr == null)
			{
				continue;
			}

			return attr.Value;
		}
		return null;
	}
}
