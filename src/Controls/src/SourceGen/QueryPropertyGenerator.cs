using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Microsoft.Maui.Controls.SourceGen;

using static GeneratorHelpers;

[Generator(LanguageNames.CSharp)]
public class QueryPropertyGenerator : IIncrementalGenerator
{
	const string QueryPropertyAttributeFullName = "Microsoft.Maui.Controls.QueryPropertyAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Use ForAttributeWithMetadataName for better performance when filtering by attribute
		var classesWithQueryProperty = context.SyntaxProvider
			.ForAttributeWithMetadataName(
				QueryPropertyAttributeFullName,
				predicate: static (node, _) => node is ClassDeclarationSyntax,
				transform: static (ctx, ct) => GetClassInfo(ctx, ct))
			.Where(static m => m.HasValue);

		// Generate source for each class
		context.RegisterSourceOutput(classesWithQueryProperty, static (spc, classInfoNullable) =>
		{
			if (!classInfoNullable.HasValue)
				return;

			var classInfo = classInfoNullable.Value;

			// Report diagnostics
			foreach (var diagnostic in classInfo.Diagnostics)
			{
				spc.ReportDiagnostic(diagnostic);
			}

			// Only generate if there are valid properties
			if (classInfo.PropertyMappings.Length > 0)
			{
				var source = GenerateSource(classInfo);
				spc.AddSource($"{classInfo.ClassName}_QueryProperty.g.cs", source);
			}
		});
	}

	private static ClassInfo? GetClassInfo(GeneratorAttributeSyntaxContext context, System.Threading.CancellationToken cancellationToken)
	{
		var classDecl = (ClassDeclarationSyntax)context.TargetNode;
		var classSymbol = context.TargetSymbol as INamedTypeSymbol;

		if (classSymbol is null)
			return null;

		var diagnostics = ImmutableArray.CreateBuilder<Diagnostic>();

		// Check if the class is partial
		var isPartial = classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
		if (!isPartial)
		{
			var diagnostic = Diagnostic.Create(
				Descriptors.QueryPropertyClassMustBePartial,
				classDecl.Identifier.GetLocation(),
				classSymbol.Name);
			diagnostics.Add(diagnostic);
			return new ClassInfo(classSymbol.Name, null, ImmutableArray<PropertyMapping>.Empty, diagnostics.ToImmutable());
		}

		// Get all QueryPropertyAttribute instances on this class
		var queryPropertyAttributes = context.Attributes;

		// Extract property mappings
		var propertyMappings = ImmutableArray.CreateBuilder<PropertyMapping>();

		foreach (var attr in queryPropertyAttributes)
		{
			cancellationToken.ThrowIfCancellationRequested();

			if (attr.ConstructorArguments.Length != 2)
				continue;

			var propertyName = attr.ConstructorArguments[0].Value as string;
			var queryId = attr.ConstructorArguments[1].Value as string;

			if (string.IsNullOrEmpty(propertyName) || string.IsNullOrEmpty(queryId))
				continue;

			// Find the property to get its type
			var property = classSymbol.GetMembers(propertyName!)
				.OfType<IPropertySymbol>()
				.FirstOrDefault();

			if (property is null)
			{
				var diagnostic = Diagnostic.Create(
					Descriptors.QueryPropertyNotFound,
					classDecl.Identifier.GetLocation(),
					propertyName,
					classSymbol.Name);
				diagnostics.Add(diagnostic);
				continue;
			}

			if (property.SetMethod is null || property.SetMethod.DeclaredAccessibility != Accessibility.Public)
			{
				var diagnostic = Diagnostic.Create(
					Descriptors.QueryPropertySetterNotPublic,
					classDecl.Identifier.GetLocation(),
					propertyName);
				diagnostics.Add(diagnostic);
				continue;
			}

			propertyMappings.Add(new PropertyMapping(propertyName!, queryId!, property.Type.ToFQDisplayString()));
		}

		var propertyMappingsArray = propertyMappings.ToImmutable();

		// Get namespace
		var namespaceName = classSymbol.ContainingNamespace?.ToString();
		if (string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>")
			namespaceName = null;

		return new ClassInfo(
			classSymbol.Name,
			namespaceName,
			propertyMappingsArray,
			diagnostics.ToImmutable());
	}

	private static string GenerateSource(ClassInfo classInfo)
	{
		var sb = new StringBuilder();

		sb.AppendLine(AutoGeneratedHeaderText);
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System;");
		sb.AppendLine("using System.Collections.Generic;");
		sb.AppendLine();

		if (classInfo.Namespace is not null)
		{
			sb.AppendLine($"namespace {classInfo.Namespace}");
			sb.AppendLine("{");
		}

		// Generate partial class
		var indent = classInfo.Namespace is not null ? "\t" : "";
		sb.AppendLine($"{indent}partial class {classInfo.ClassName} : global::Microsoft.Maui.Controls.IQueryAttributable");
		sb.AppendLine($"{indent}{{");

		// Generate ApplyQueryAttributes method
		sb.AppendLine($"{indent}\t/// <summary>");
		sb.AppendLine($"{indent}\t/// Applies query attributes from navigation parameters.");
		sb.AppendLine($"{indent}\t/// This method is generated by the QueryPropertyGenerator.");
		sb.AppendLine($"{indent}\t/// </summary>");
		sb.AppendLine($"{indent}\tvoid global::Microsoft.Maui.Controls.IQueryAttributable.ApplyQueryAttributes(global::System.Collections.Generic.IDictionary<string, object> query)");
		sb.AppendLine($"{indent}\t{{");
		sb.AppendLine($"{indent}\t\tif (query == null)");
		sb.AppendLine($"{indent}\t\t\treturn;");
		sb.AppendLine();

		// Store old query keys for clearing
		sb.AppendLine($"{indent}\t\t// Track which properties were set in previous navigation");
		sb.AppendLine($"{indent}\t\tvar previousKeys = _queryPropertyKeys ?? new global::System.Collections.Generic.HashSet<string>();");
		sb.AppendLine($"{indent}\t\t_queryPropertyKeys = new global::System.Collections.Generic.HashSet<string>();");
		sb.AppendLine();

		// Generate property setting code for each mapping
		foreach (var mapping in classInfo.PropertyMappings)
		{
			var escapedQueryId = EscapeIdentifier(mapping.QueryId);
			sb.AppendLine($"{indent}\t\tif (query.TryGetValue(\"{mapping.QueryId}\", out var {escapedQueryId}Value))");
			sb.AppendLine($"{indent}\t\t{{");
			sb.AppendLine($"{indent}\t\t\t_queryPropertyKeys.Add(\"{mapping.QueryId}\");");

			if (mapping.PropertyType == "string")
			{
				// For string properties, apply URL decoding
				sb.AppendLine($"{indent}\t\t\tif ({escapedQueryId}Value != null)");
				sb.AppendLine($"{indent}\t\t\t\t{mapping.PropertyName} = global::System.Net.WebUtility.UrlDecode({escapedQueryId}Value.ToString());");
				sb.AppendLine($"{indent}\t\t\telse");
				sb.AppendLine($"{indent}\t\t\t\t{mapping.PropertyName} = null;");
			}
			else
			{
				// For non-string properties, use Convert.ChangeType
				sb.AppendLine($"{indent}\t\t\ttry");
				sb.AppendLine($"{indent}\t\t\t{{");
				sb.AppendLine($"{indent}\t\t\t\tif ({escapedQueryId}Value != null)");
				sb.AppendLine($"{indent}\t\t\t\t{{");
				sb.AppendLine($"{indent}\t\t\t\t\tvar convertedValue = global::System.Convert.ChangeType({escapedQueryId}Value, typeof({mapping.PropertyType}));");
				sb.AppendLine($"{indent}\t\t\t\t\t{mapping.PropertyName} = ({mapping.PropertyType})convertedValue;");
				sb.AppendLine($"{indent}\t\t\t\t}}");
				sb.AppendLine($"{indent}\t\t\t}}");
				sb.AppendLine($"{indent}\t\t\tcatch");
				sb.AppendLine($"{indent}\t\t\t{{");
				sb.AppendLine($"{indent}\t\t\t\t// Ignore conversion errors");
				sb.AppendLine($"{indent}\t\t\t}}");
			}

			sb.AppendLine($"{indent}\t\t}}");
			sb.AppendLine($"{indent}\t\telse if (previousKeys.Contains(\"{mapping.QueryId}\"))");
			sb.AppendLine($"{indent}\t\t{{");
			sb.AppendLine($"{indent}\t\t\t// Clear property if it was set before but not in current query");

			if (IsNullableType(mapping.PropertyType))
			{
				sb.AppendLine($"{indent}\t\t\t{mapping.PropertyName} = default;");
			}
			else
			{
				sb.AppendLine($"{indent}\t\t\t// Property is not nullable, skipping clear");
			}

			sb.AppendLine($"{indent}\t\t}}");
			sb.AppendLine();
		}

		sb.AppendLine($"{indent}\t}}");
		sb.AppendLine();

		// Add field to track query keys
		sb.AppendLine($"{indent}\tprivate global::System.Collections.Generic.HashSet<string>? _queryPropertyKeys;");

		sb.AppendLine($"{indent}}}");

		if (classInfo.Namespace is not null)
		{
			sb.AppendLine("}");
		}

		return sb.ToString();
	}

	private static bool IsNullableType(string typeName)
	{
		return typeName == "string" ||
			   typeName.EndsWith("?") ||
			   typeName.Contains("System.Nullable<");
	}

	private record struct PropertyMapping(string PropertyName, string QueryId, string PropertyType);

	private record struct ClassInfo(
		string ClassName,
		string? Namespace,
		ImmutableArray<PropertyMapping> PropertyMappings,
		ImmutableArray<Diagnostic> Diagnostics);
}
