using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Microsoft.Maui.Controls.SourceGen;

using static GeneratorHelpers;

[Generator(LanguageNames.CSharp)]
public class QueryPropertyGenerator : IIncrementalGenerator
{
	const string QueryPropertyAttributeFullName = "Microsoft.Maui.Controls.QueryPropertyAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Use ForAttributeWithMetadataName for better performance when filtering by attribute
		var classesWithQueryProperty = context.SyntaxProvider
			.ForAttributeWithMetadataName(
				QueryPropertyAttributeFullName,
				predicate: static (node, _) => node is ClassDeclarationSyntax,
				transform: static (ctx, ct) => GetClassInfo(ctx, ct));

		// Generate source for each class
		context.RegisterSourceOutput(classesWithQueryProperty, static (spc, classInfo) =>
		{
			// Report diagnostics
			foreach (var diagnostic in classInfo.Diagnostics)
			{
				spc.ReportDiagnostic(diagnostic);
			}

			// Only generate if there are valid properties
			if (classInfo.PropertyMappings.Length > 0)
			{
				var source = GenerateSource(classInfo);
				spc.AddSource($"{classInfo.ClassName}_QueryProperty.g.cs", source);
			}
		});
	}

	private static ClassInfo GetClassInfo(GeneratorAttributeSyntaxContext context, System.Threading.CancellationToken cancellationToken)
	{
		var classDecl = (ClassDeclarationSyntax)context.TargetNode;
		var classSymbol = (INamedTypeSymbol)context.TargetSymbol;

		var diagnostics = ImmutableArray.CreateBuilder<Diagnostic>();

		// Check if the class is partial
		var isPartial = classDecl.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
		if (!isPartial)
		{
			var diagnostic = Diagnostic.Create(
				Descriptors.QueryPropertyClassMustBePartial,
				classDecl.Identifier.GetLocation(),
				classSymbol.Name);
			diagnostics.Add(diagnostic);
			return new ClassInfo(classSymbol.Name, null, ImmutableArray<PropertyMapping>.Empty, diagnostics.ToImmutable());
		}

		// Get all QueryPropertyAttribute instances on this class
		var queryPropertyAttributes = context.Attributes;

		// Extract property mappings
		var propertyMappings = ImmutableArray.CreateBuilder<PropertyMapping>();

		foreach (var attr in queryPropertyAttributes)
		{
			cancellationToken.ThrowIfCancellationRequested();

			if (attr.ConstructorArguments.Length != 2)
				continue;

			var propertyName = attr.ConstructorArguments[0].Value as string;
			var queryId = attr.ConstructorArguments[1].Value as string;

			if (string.IsNullOrEmpty(propertyName) || string.IsNullOrEmpty(queryId))
			{
				var diagnostic = Diagnostic.Create(
					Descriptors.QueryPropertyAttributeInvalidArguments,
					classDecl.Identifier.GetLocation(),
					classSymbol.Name);
				diagnostics.Add(diagnostic);
				continue;
			}

			// Find the property to get its type
			var property = classSymbol.GetMembers(propertyName!)
				.OfType<IPropertySymbol>()
				.FirstOrDefault();

			if (property is null)
			{
				var diagnostic = Diagnostic.Create(
					Descriptors.QueryPropertyNotFound,
					classDecl.Identifier.GetLocation(),
					propertyName,
					classSymbol.Name);
				diagnostics.Add(diagnostic);
				continue;
			}

			if (property.SetMethod is null || property.SetMethod.DeclaredAccessibility != Accessibility.Public)
			{
				var diagnostic = Diagnostic.Create(
					Descriptors.QueryPropertySetterNotPublic,
					classDecl.Identifier.GetLocation(),
					propertyName);
				diagnostics.Add(diagnostic);
				continue;
			}

			propertyMappings.Add(new PropertyMapping(propertyName!, queryId!, property.Type.ToFQDisplayString()));
		}

		var propertyMappingsArray = propertyMappings.ToImmutable();

		// Get namespace
		var namespaceName = classSymbol.ContainingNamespace?.ToString();
		if (string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>")
			namespaceName = null;

		return new ClassInfo(
			classSymbol.Name,
			namespaceName,
			propertyMappingsArray,
			diagnostics.ToImmutable());
	}

	private static string GenerateSource(ClassInfo classInfo)
	{
		var compilationUnit = BuildCompilationUnit(classInfo);
		var normalizedCode = compilationUnit.NormalizeWhitespace().ToFullString();
		
		// Prepend the auto-generated header comment
		return AutoGeneratedHeaderText + "\r\n" + normalizedCode;
	}

	private static CompilationUnitSyntax BuildCompilationUnit(ClassInfo classInfo)
	{
		// Create using directives
		var usingDirectives = new[]
		{
			SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")),
			SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Collections.Generic"))
		};

		// Build class members
		var classMembers = new List<MemberDeclarationSyntax>();

		// Add ApplyQueryAttributes method
		classMembers.Add(BuildApplyQueryAttributesMethod(classInfo));

		// Add field to track query keys
		classMembers.Add(BuildQueryPropertyKeysField());

		// Build class declaration
		var classDeclaration = SyntaxFactory.ClassDeclaration(classInfo.ClassName)
			.WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PartialKeyword)))
			.WithBaseList(SyntaxFactory.BaseList(SyntaxFactory.SingletonSeparatedList<BaseTypeSyntax>(
				SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName("global::Microsoft.Maui.Controls.IQueryAttributable")))))
			.WithMembers(SyntaxFactory.List(classMembers));

		// Create compilation unit with nullable enable directive
		var compilationUnit = SyntaxFactory.CompilationUnit()
			.AddUsings(usingDirectives);

		// Add nullable directive
		var nullableDirective = SyntaxFactory.Trivia(
			SyntaxFactory.NullableDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.EnableKeyword), true));
		
		// Get the first using directive and add the nullable directive before it
		var firstUsing = compilationUnit.Usings[0];
		var updatedFirstUsing = firstUsing.WithLeadingTrivia(nullableDirective, SyntaxFactory.CarriageReturnLineFeed);
		compilationUnit = compilationUnit.WithUsings(
			compilationUnit.Usings.Replace(firstUsing, updatedFirstUsing));

		if (classInfo.Namespace is not null)
		{
			var namespaceDeclaration = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(classInfo.Namespace))
				.AddMembers(classDeclaration);
			compilationUnit = compilationUnit.AddMembers(namespaceDeclaration);
		}
		else
		{
			compilationUnit = compilationUnit.AddMembers(classDeclaration);
		}

		return compilationUnit;
	}

	private static MethodDeclarationSyntax BuildApplyQueryAttributesMethod(ClassInfo classInfo)
	{
		var statements = new List<StatementSyntax>();

		// if (query == null) return;
		statements.Add(SyntaxFactory.IfStatement(
			SyntaxFactory.BinaryExpression(
				SyntaxKind.EqualsExpression,
				SyntaxFactory.IdentifierName("query"),
				SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)),
			SyntaxFactory.ReturnStatement()));

		// var previousKeys = _queryPropertyKeys ?? new HashSet<string>();
		statements.Add(SyntaxFactory.LocalDeclarationStatement(
			SyntaxFactory.VariableDeclaration(
				SyntaxFactory.IdentifierName("var"))
			.AddVariables(
				SyntaxFactory.VariableDeclarator("previousKeys")
					.WithInitializer(SyntaxFactory.EqualsValueClause(
						SyntaxFactory.BinaryExpression(
							SyntaxKind.CoalesceExpression,
							SyntaxFactory.IdentifierName("_queryPropertyKeys"),
							SyntaxFactory.ObjectCreationExpression(
								SyntaxFactory.ParseTypeName("global::System.Collections.Generic.HashSet<string>"))
								.WithArgumentList(SyntaxFactory.ArgumentList())))))));

		// _queryPropertyKeys = new HashSet<string>();
		statements.Add(SyntaxFactory.ExpressionStatement(
			SyntaxFactory.AssignmentExpression(
				SyntaxKind.SimpleAssignmentExpression,
				SyntaxFactory.IdentifierName("_queryPropertyKeys"),
				SyntaxFactory.ObjectCreationExpression(
					SyntaxFactory.ParseTypeName("global::System.Collections.Generic.HashSet<string>"))
					.WithArgumentList(SyntaxFactory.ArgumentList()))));

		// Generate property setting code for each mapping
		foreach (var mapping in classInfo.PropertyMappings)
		{
			statements.AddRange(BuildPropertyMappingStatements(mapping));
		}

		var method = SyntaxFactory.MethodDeclaration(
				SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)),
				SyntaxFactory.Identifier("ApplyQueryAttributes"))
			.WithExplicitInterfaceSpecifier(
				SyntaxFactory.ExplicitInterfaceSpecifier(
					SyntaxFactory.ParseName("global::Microsoft.Maui.Controls.IQueryAttributable")))
			.AddParameterListParameters(
				SyntaxFactory.Parameter(SyntaxFactory.Identifier("query"))
					.WithType(SyntaxFactory.ParseTypeName("global::System.Collections.Generic.IDictionary<string, object>")))
			.WithBody(SyntaxFactory.Block(statements));

		return method;
	}

	private static IEnumerable<StatementSyntax> BuildPropertyMappingStatements(PropertyMapping mapping)
	{
		var statements = new List<StatementSyntax>();
		var escapedQueryId = EscapeIdentifier(mapping.QueryId);
		var valueVarName = $"{escapedQueryId}Value";

		// if (query.TryGetValue("queryId", out var queryIdValue))
		var tryGetValueCondition = SyntaxFactory.InvocationExpression(
			SyntaxFactory.MemberAccessExpression(
				SyntaxKind.SimpleMemberAccessExpression,
				SyntaxFactory.IdentifierName("query"),
				SyntaxFactory.IdentifierName("TryGetValue")))
			.AddArgumentListArguments(
				SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(
					SyntaxKind.StringLiteralExpression,
					SyntaxFactory.Literal(mapping.QueryId))),
				SyntaxFactory.Argument(
					SyntaxFactory.DeclarationExpression(
						SyntaxFactory.IdentifierName("var"),
						SyntaxFactory.SingleVariableDesignation(SyntaxFactory.Identifier(valueVarName))))
					.WithRefOrOutKeyword(SyntaxFactory.Token(SyntaxKind.OutKeyword)));

		var ifTrueStatements = new List<StatementSyntax>();

		// _queryPropertyKeys.Add("queryId");
		ifTrueStatements.Add(SyntaxFactory.ExpressionStatement(
			SyntaxFactory.InvocationExpression(
				SyntaxFactory.MemberAccessExpression(
					SyntaxKind.SimpleMemberAccessExpression,
					SyntaxFactory.IdentifierName("_queryPropertyKeys"),
					SyntaxFactory.IdentifierName("Add")))
				.AddArgumentListArguments(
					SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(
						SyntaxKind.StringLiteralExpression,
						SyntaxFactory.Literal(mapping.QueryId))))));

		if (mapping.PropertyType == "string")
		{
			// For string properties: if (value != null) Property = UrlDecode(value); else Property = null;
			ifTrueStatements.Add(BuildStringPropertyAssignment(mapping, valueVarName));
		}
		else
		{
			// For non-string properties: if (value != null) { var converted = Convert.ChangeType(...); Property = (Type)converted; }
			ifTrueStatements.Add(BuildNonStringPropertyAssignment(mapping, valueVarName));
		}

		statements.Add(SyntaxFactory.IfStatement(
			tryGetValueCondition,
			SyntaxFactory.Block(ifTrueStatements))
			.WithElse(BuildPropertyClearElseClause(mapping)));

		return statements;
	}

	private static StatementSyntax BuildStringPropertyAssignment(PropertyMapping mapping, string valueVarName)
	{
		// if (valueVarName != null) Property = WebUtility.UrlDecode(valueVarName.ToString()); else Property = null;
		return SyntaxFactory.IfStatement(
			SyntaxFactory.BinaryExpression(
				SyntaxKind.NotEqualsExpression,
				SyntaxFactory.IdentifierName(valueVarName),
				SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)),
			SyntaxFactory.ExpressionStatement(
				SyntaxFactory.AssignmentExpression(
					SyntaxKind.SimpleAssignmentExpression,
					SyntaxFactory.IdentifierName(mapping.PropertyName),
					SyntaxFactory.InvocationExpression(
						SyntaxFactory.MemberAccessExpression(
							SyntaxKind.SimpleMemberAccessExpression,
							SyntaxFactory.ParseName("global::System.Net.WebUtility"),
							SyntaxFactory.IdentifierName("UrlDecode")))
						.AddArgumentListArguments(
							SyntaxFactory.Argument(
								SyntaxFactory.InvocationExpression(
									SyntaxFactory.MemberAccessExpression(
										SyntaxKind.SimpleMemberAccessExpression,
										SyntaxFactory.IdentifierName(valueVarName),
										SyntaxFactory.IdentifierName("ToString"))))))),
			SyntaxFactory.ElseClause(
				SyntaxFactory.ExpressionStatement(
					SyntaxFactory.AssignmentExpression(
						SyntaxKind.SimpleAssignmentExpression,
						SyntaxFactory.IdentifierName(mapping.PropertyName),
						SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)))));
	}

	private static StatementSyntax BuildNonStringPropertyAssignment(PropertyMapping mapping, string valueVarName)
	{
		// if (valueVarName != null) { var convertedValue = Convert.ChangeType(valueVarName, typeof(Type)); Property = (Type)convertedValue; }
		return SyntaxFactory.IfStatement(
			SyntaxFactory.BinaryExpression(
				SyntaxKind.NotEqualsExpression,
				SyntaxFactory.IdentifierName(valueVarName),
				SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)),
			SyntaxFactory.Block(
				SyntaxFactory.LocalDeclarationStatement(
					SyntaxFactory.VariableDeclaration(
						SyntaxFactory.IdentifierName("var"))
					.AddVariables(
						SyntaxFactory.VariableDeclarator("convertedValue")
							.WithInitializer(SyntaxFactory.EqualsValueClause(
								SyntaxFactory.InvocationExpression(
									SyntaxFactory.MemberAccessExpression(
										SyntaxKind.SimpleMemberAccessExpression,
										SyntaxFactory.ParseName("global::System.Convert"),
										SyntaxFactory.IdentifierName("ChangeType")))
									.AddArgumentListArguments(
										SyntaxFactory.Argument(SyntaxFactory.IdentifierName(valueVarName)),
										SyntaxFactory.Argument(
											SyntaxFactory.TypeOfExpression(
												SyntaxFactory.ParseTypeName(mapping.PropertyType)))))))),
				SyntaxFactory.ExpressionStatement(
					SyntaxFactory.AssignmentExpression(
						SyntaxKind.SimpleAssignmentExpression,
						SyntaxFactory.IdentifierName(mapping.PropertyName),
						SyntaxFactory.CastExpression(
							SyntaxFactory.ParseTypeName(mapping.PropertyType),
							SyntaxFactory.IdentifierName("convertedValue"))))));
	}

	private static ElseClauseSyntax BuildPropertyClearElseClause(PropertyMapping mapping)
	{
		// else if (previousKeys.Contains("queryId")) { if (nullable) Property = default; }
		var containsCondition = SyntaxFactory.InvocationExpression(
			SyntaxFactory.MemberAccessExpression(
				SyntaxKind.SimpleMemberAccessExpression,
				SyntaxFactory.IdentifierName("previousKeys"),
				SyntaxFactory.IdentifierName("Contains")))
			.AddArgumentListArguments(
				SyntaxFactory.Argument(SyntaxFactory.LiteralExpression(
					SyntaxKind.StringLiteralExpression,
					SyntaxFactory.Literal(mapping.QueryId))));

		StatementSyntax clearStatement;
		if (IsNullableType(mapping.PropertyType))
		{
			clearStatement = SyntaxFactory.ExpressionStatement(
				SyntaxFactory.AssignmentExpression(
					SyntaxKind.SimpleAssignmentExpression,
					SyntaxFactory.IdentifierName(mapping.PropertyName),
					SyntaxFactory.LiteralExpression(SyntaxKind.DefaultLiteralExpression)));
		}
		else
		{
			// Empty statement for non-nullable types
			clearStatement = SyntaxFactory.EmptyStatement();
		}

		return SyntaxFactory.ElseClause(
			SyntaxFactory.IfStatement(
				containsCondition,
				SyntaxFactory.Block(clearStatement)));
	}

	private static FieldDeclarationSyntax BuildQueryPropertyKeysField()
	{
		return SyntaxFactory.FieldDeclaration(
			SyntaxFactory.VariableDeclaration(
				SyntaxFactory.NullableType(
					SyntaxFactory.ParseTypeName("global::System.Collections.Generic.HashSet<string>")))
			.AddVariables(
				SyntaxFactory.VariableDeclarator("_queryPropertyKeys")))
			.WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PrivateKeyword)));
	}

	private static bool IsNullableType(string typeName)
	{
		return typeName == "string" ||
			   typeName.EndsWith("?") ||
			   typeName.Contains("System.Nullable<");
	}

	private record struct PropertyMapping(string PropertyName, string QueryId, string PropertyType);

	private record struct ClassInfo(
		string ClassName,
		string? Namespace,
		ImmutableArray<PropertyMapping> PropertyMappings,
		ImmutableArray<Diagnostic> Diagnostics);
}
