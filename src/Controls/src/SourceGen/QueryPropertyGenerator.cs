using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Microsoft.Maui.Controls.SourceGen;

[Generator(LanguageNames.CSharp)]
public class QueryPropertyGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Filter classes with QueryPropertyAttribute
		var classesWithQueryProperty = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => IsClassWithAttribute(node),
				transform: static (ctx, _) => GetClassInfo(ctx))
			.Where(static m => m is not null);

		// Generate source for each class
		context.RegisterSourceOutput(classesWithQueryProperty, static (spc, classInfo) =>
		{
			if (classInfo is null)
				return;

			var source = GenerateSource(classInfo.Value);
			spc.AddSource($"{classInfo.Value.ClassName}_QueryProperty.g.cs", source);
		});
	}

	private static bool IsClassWithAttribute(SyntaxNode node)
	{
		return node is ClassDeclarationSyntax classDecl && classDecl.AttributeLists.Count > 0;
	}

	private static ClassInfo? GetClassInfo(GeneratorSyntaxContext context)
	{
		var classDecl = (ClassDeclarationSyntax)context.Node;
		var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDecl);
		
		if (classSymbol is null)
			return null;

		// Get all QueryPropertyAttribute instances
		var queryPropertyAttributes = classSymbol.GetAttributes()
			.Where(attr => attr.AttributeClass?.Name == "QueryPropertyAttribute" &&
			               attr.AttributeClass?.ContainingNamespace?.ToString() == "Microsoft.Maui.Controls")
			.ToImmutableArray();

		if (queryPropertyAttributes.IsEmpty)
			return null;

		// Extract property mappings
		var propertyMappings = ImmutableArray.CreateBuilder<PropertyMapping>();
		
		foreach (var attr in queryPropertyAttributes)
		{
			if (attr.ConstructorArguments.Length != 2)
				continue;

			var propertyName = attr.ConstructorArguments[0].Value as string;
			var queryId = attr.ConstructorArguments[1].Value as string;

			if (string.IsNullOrEmpty(propertyName) || string.IsNullOrEmpty(queryId))
				continue;

			// Find the property to get its type
			var property = classSymbol.GetMembers(propertyName!)
				.OfType<IPropertySymbol>()
				.FirstOrDefault();

			if (property is null)
				continue;

			propertyMappings.Add(new PropertyMapping(propertyName!, queryId!, property.Type.ToFQDisplayString()));
		}

		var propertyMappingsArray = propertyMappings.ToImmutable();
		
		if (propertyMappingsArray.IsEmpty)
			return null;

		// Check if class already implements IQueryAttributable
		var implementsIQueryAttributable = classSymbol.AllInterfaces
			.Any(i => i.Name == "IQueryAttributable" &&
			          i.ContainingNamespace?.ToString() == "Microsoft.Maui.Controls");

		// Get namespace
		var namespaceName = classSymbol.ContainingNamespace?.ToString();
		if (string.IsNullOrEmpty(namespaceName) || namespaceName == "<global namespace>")
			namespaceName = null;

		return new ClassInfo(
			classSymbol.Name,
			namespaceName,
			propertyMappingsArray,
			implementsIQueryAttributable);
	}

	private static string GenerateSource(ClassInfo classInfo)
	{
		var sb = new StringBuilder();

		sb.AppendLine("// <auto-generated />");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System;");
		sb.AppendLine("using System.Collections.Generic;");
		sb.AppendLine("using System.Linq;");
		sb.AppendLine();

		if (classInfo.Namespace is not null)
		{
			sb.AppendLine($"namespace {classInfo.Namespace}");
			sb.AppendLine("{");
		}

		// Generate partial class
		var indent = classInfo.Namespace is not null ? "\t" : "";
		sb.AppendLine($"{indent}partial class {classInfo.ClassName} : Microsoft.Maui.Controls.IQueryAttributable");
		sb.AppendLine($"{indent}{{");

		// Generate ApplyQueryAttributes method
		sb.AppendLine($"{indent}\t/// <summary>");
		sb.AppendLine($"{indent}\t/// Applies query attributes from navigation parameters.");
		sb.AppendLine($"{indent}\t/// This method is generated by the QueryPropertyGenerator.");
		sb.AppendLine($"{indent}\t/// </summary>");
		sb.AppendLine($"{indent}\tvoid Microsoft.Maui.Controls.IQueryAttributable.ApplyQueryAttributes(IDictionary<string, object> query)");
		sb.AppendLine($"{indent}\t{{");
		sb.AppendLine($"{indent}\t\tif (query == null)");
		sb.AppendLine($"{indent}\t\t\treturn;");
		sb.AppendLine();

		// Store old query keys for clearing
		sb.AppendLine($"{indent}\t\t// Track which properties were set in previous navigation");
		sb.AppendLine($"{indent}\t\tvar previousKeys = _queryPropertyKeys ?? new HashSet<string>();");
		sb.AppendLine($"{indent}\t\t_queryPropertyKeys = new HashSet<string>();");
		sb.AppendLine();

		// Generate property setting code for each mapping
		foreach (var mapping in classInfo.PropertyMappings)
		{
			sb.AppendLine($"{indent}\t\tif (query.TryGetValue(\"{mapping.QueryId}\", out var {mapping.QueryId}Value))");
			sb.AppendLine($"{indent}\t\t{{");
			sb.AppendLine($"{indent}\t\t\t_queryPropertyKeys.Add(\"{mapping.QueryId}\");");
			
			if (mapping.PropertyType == "string")
			{
				// For string properties, apply URL decoding
				sb.AppendLine($"{indent}\t\t\tif ({mapping.QueryId}Value != null)");
				sb.AppendLine($"{indent}\t\t\t\t{mapping.PropertyName} = global::System.Net.WebUtility.UrlDecode({mapping.QueryId}Value.ToString());");
				sb.AppendLine($"{indent}\t\t\telse");
				sb.AppendLine($"{indent}\t\t\t\t{mapping.PropertyName} = null;");
			}
			else
			{
				// For non-string properties, use Convert.ChangeType
				sb.AppendLine($"{indent}\t\t\ttry");
				sb.AppendLine($"{indent}\t\t\t{{");
				sb.AppendLine($"{indent}\t\t\t\tif ({mapping.QueryId}Value != null)");
				sb.AppendLine($"{indent}\t\t\t\t{{");
				sb.AppendLine($"{indent}\t\t\t\t\tvar convertedValue = Convert.ChangeType({mapping.QueryId}Value, typeof({mapping.PropertyType}));");
				sb.AppendLine($"{indent}\t\t\t\t\t{mapping.PropertyName} = ({mapping.PropertyType})convertedValue;");
				sb.AppendLine($"{indent}\t\t\t\t}}");
				sb.AppendLine($"{indent}\t\t\t}}");
				sb.AppendLine($"{indent}\t\t\tcatch");
				sb.AppendLine($"{indent}\t\t\t{{");
				sb.AppendLine($"{indent}\t\t\t\t// Ignore conversion errors");
				sb.AppendLine($"{indent}\t\t\t}}");
			}
			
			sb.AppendLine($"{indent}\t\t}}");
			sb.AppendLine($"{indent}\t\telse if (previousKeys.Contains(\"{mapping.QueryId}\"))");
			sb.AppendLine($"{indent}\t\t{{");
			sb.AppendLine($"{indent}\t\t\t// Clear property if it was set before but not in current query");
			
			if (IsNullableType(mapping.PropertyType))
			{
				sb.AppendLine($"{indent}\t\t\t{mapping.PropertyName} = default;");
			}
			else
			{
				sb.AppendLine($"{indent}\t\t\t// Property is not nullable, skipping clear");
			}
			
			sb.AppendLine($"{indent}\t\t}}");
			sb.AppendLine();
		}

		sb.AppendLine($"{indent}\t}}");
		sb.AppendLine();
		
		// Add field to track query keys
		sb.AppendLine($"{indent}\tprivate HashSet<string>? _queryPropertyKeys;");

		sb.AppendLine($"{indent}}}");

		if (classInfo.Namespace is not null)
		{
			sb.AppendLine("}");
		}

		return sb.ToString();
	}

	private static bool IsNullableType(string typeName)
	{
		return typeName == "string" || 
		       typeName.EndsWith("?") ||
		       typeName.Contains("System.Nullable<");
	}

	private record struct PropertyMapping(string PropertyName, string QueryId, string PropertyType);

	private record struct ClassInfo(
		string ClassName,
		string? Namespace,
		ImmutableArray<PropertyMapping> PropertyMappings,
		bool AlreadyImplementsIQueryAttributable);
}
