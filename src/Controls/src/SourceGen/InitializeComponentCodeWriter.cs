using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Xml;
using Microsoft.CodeAnalysis;
using System.Linq; 
using Microsoft.Maui.Controls.Xaml;

namespace Microsoft.Maui.Controls.SourceGen;

static class InitializeComponentCodeWriter
{
	static readonly string NewLine = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "\r\n" : "\n";

	public static string GeneratedCodeAttribute => $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{typeof(InitializeComponentCodeWriter).Assembly.FullName}\", \"{typeof(InitializeComponentCodeWriter).Assembly.GetName().Version}\")]";
	const string AutoGeneratedHeaderText = @"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a .NET MAUI source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#if _MAUIXAML_SG_NULLABLE_ENABLE
#nullable enable
#endif
";

	public static string GenerateInitializeComponent(XamlProjectItemForIC xamlItem, Compilation compilation, SourceProductionContext sourceProductionContext, AssemblyCaches xmlnsCache, IDictionary<XmlType, ITypeSymbol> typeCache)
	{
		using (var codeWriter = new IndentedTextWriter(new StringWriter(CultureInfo.InvariantCulture), "\t") { NewLine = NewLine })
		{
			PrePost newblock() =>
				PrePost.NewBlock(codeWriter);

			codeWriter.WriteLine(AutoGeneratedHeaderText);
			var warningDisable = xamlItem.Root!.DisableWarnings != null ? string.Join(", ", xamlItem.Root!.DisableWarnings) : null;
			if (warningDisable != null && warningDisable.Length > 0)
			{
				codeWriter.WriteLine($"#pragma warning disable {warningDisable}");
				codeWriter.WriteLine();
			}
			var root = xamlItem.Root!;

			string accessModifier = "public";
			INamedTypeSymbol? rootType = null;

			if (root.Properties.TryGetValue(XmlName.xClass, out var classNode))
			{
				if ((classNode as ValueNode)?.Value is not string rootClass)
					goto exit;

				if (root.Properties.TryGetValue(XmlName.xClassModifier, out var classModifierNode))
				{
					var classModifier = (classModifierNode as ValueNode)?.Value as string;
					accessModifier = classModifier?.ToLowerInvariant().Replace("notpublic", "internal") ?? "public"; // notpublic is WPF for internal
				}
				//TODO support x:TypeArguments

				XmlnsHelper.ParseXmlns(rootClass, out var rootTypeName, out var rootClrNamespace, out _, out _);
				rootType = compilation.GetTypeByMetadataName($"{rootClrNamespace}.{rootTypeName}");
			}
			else
			{ //no x:Class, but it can be an autogenerated type (starting with __Type, and with a XamlResourceId attribute)
				ITypeSymbol xamlResIdAttr = compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.Xaml.XamlResourceIdAttribute")!;
				INamedTypeSymbol? GetTypeForResourcePath(string resourcePath, IAssemblySymbol assembly)
				{
					var attr = assembly.GetAttributes(xamlResIdAttr).FirstOrDefault(attr => (string)attr.ConstructorArguments[1].Value! == resourcePath);
					return attr?.ConstructorArguments[2].Value as INamedTypeSymbol;
				}

				rootType = GetTypeForResourcePath(xamlItem.ProjectItem.RelativePath!, compilation.Assembly);
			}

			if (rootType == null)
				goto exit;

			var genSwitch = compilation.AssemblyName == "Microsoft.Maui.Controls.Xaml.UnitTests";
			var xamlInflators = xamlItem.ProjectItem.Inflator;

			var generate = (xamlInflators & XamlInflator.SourceGen) == XamlInflator.SourceGen;

			if (!generate)
				goto exit;

			codeWriter.WriteLine($"namespace {rootType.ContainingNamespace};");
			codeWriter.WriteLine();
			if (!rootType.Name.StartsWith("__Type"))
				codeWriter.WriteLine(GeneratedCodeAttribute);
			codeWriter.WriteLine($"{accessModifier} partial class {rootType.Name}");
			using (newblock())
			{
				var methodName = genSwitch ? "InitializeComponentSourceGen" : "InitializeComponent";
				codeWriter.WriteLine($"private partial void {methodName}()");
				xamlItem.Root!.XmlType.TryResolveTypeSymbol(null, compilation, xmlnsCache, out var baseType);
				var sgcontext = new SourceGenContext(codeWriter, compilation, sourceProductionContext, xmlnsCache, typeCache, rootType!, baseType) { FilePath = xamlItem.ProjectItem.RelativePath };
				using (newblock())
				{
					Visit(root, sgcontext);

					foreach (var localMethod in sgcontext.LocalMethods)
					{
						codeWriter.WriteLine(localMethod);
						codeWriter.WriteLine();
					}
				}

				foreach (var writer in sgcontext.AddtitionalWriters)
				{
					codeWriter.Write(writer.ToString());
					codeWriter.WriteLine();
				}
			}
		exit:
			codeWriter.Flush();
			return codeWriter.InnerWriter.ToString();
		}
	}

	static void Visit(RootNode rootnode, SourceGenContext visitorContext, bool useDesignProperties = false)
	{
		rootnode.Accept(new XamlNodeVisitor((node, parent) => node.Parent = parent), null); //set parents for {StaticResource}
		rootnode.Accept(new ExpandMarkupsVisitor(visitorContext), null);
		rootnode.Accept(new PruneIgnoredNodesVisitor(useDesignProperties), null);
		if (useDesignProperties)
			rootnode.Accept(new RemoveDuplicateDesignNodes(), null);
		rootnode.Accept(new SimplifyTypeExtensionVisitor(), null);
		rootnode.Accept(new CreateValuesVisitor(visitorContext), null);
		rootnode.Accept(new SetNamescopesAndRegisterNamesVisitor(visitorContext), null); //set namescopes for {x:Reference} and FindByName
		rootnode.Accept(new SetFieldsForXNamesVisitor(visitorContext), null);
		// rootnode.Accept(new FillResourceDictionariesVisitor(visitorContext), null);
		rootnode.Accept(new SetResourcesVisitor(visitorContext), null);
		rootnode.Accept(new SetPropertiesVisitor(visitorContext, true), null);
	}
}
