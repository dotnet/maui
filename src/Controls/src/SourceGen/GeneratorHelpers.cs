using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Xml;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;
using Microsoft.Maui.Controls.Xaml;

namespace Microsoft.Maui.Controls.SourceGen;

static class GeneratorHelpers
{
	public const string AutoGeneratedHeaderText = @"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a .NET MAUI source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#if _MAUIXAML_SG_NULLABLE_ENABLE
#nullable enable
#endif
";

	public static string EscapeIdentifier(string identifier)
	{
		var kind = SyntaxFacts.GetKeywordKind(identifier);
		return kind == SyntaxKind.None
			? identifier
			: $"@{identifier}";
	}

	public static ProjectItem? ComputeProjectItem((AdditionalText, AnalyzerConfigOptionsProvider) tuple, CancellationToken cancellationToken)
	{
		var (additionalText, optionsProvider) = tuple;
		var fileOptions = optionsProvider.GetOptions(additionalText);
		if (!fileOptions.TryGetValue("build_metadata.additionalfiles.GenKind", out string? kind) || kind is null)
		{
			return null;
		}

		fileOptions.TryGetValue("build_metadata.additionalfiles.TargetPath", out var targetPath);
		fileOptions.TryGetValue("build_metadata.additionalfiles.ManifestResourceName", out var manifestResourceName);
		fileOptions.TryGetValue("build_metadata.additionalfiles.RelativePath", out var relativePath);
		fileOptions.TryGetValue("build_property.targetframework", out var targetFramework);
		fileOptions.TryGetValue("build_property.Configuration", out var configuration);

		fileOptions.TryGetValue("build_metadata.additionalfiles.Inflator", out var inflator);


		var xamlinflator = 0;
		if (!string.IsNullOrEmpty(inflator))
		{
			var parts = inflator!.Split(',');
			for (int i = 0; i < parts.Length; i++)
			{
				var trimmed = parts[i].Trim();
				if (!Enum.TryParse<XamlInflator>(trimmed, true, out var xinfl))
					throw new InvalidOperationException($"Invalid inflator '{trimmed}' for {additionalText.Path}.");
				xamlinflator |= (int)xinfl;
			}
		}

		return new ProjectItem
		{
			AdditionalText = additionalText,
			TargetPath = targetPath,
			RelativePath = relativePath,
			ManifestResourceName = manifestResourceName,
			Kind = kind,
			Inflator = (XamlInflator)xamlinflator,
			TargetFramework = targetFramework,
			Configuration = configuration!,
		};
	}

	public static XamlProjectItemForIC? ComputeXamlProjectItemForIC((ProjectItem?, AssemblyCaches) itemAdnCaches, CancellationToken cancellationToken)
	{
		var (projectItem, assemblyCaches) = itemAdnCaches;
		var text = projectItem?.AdditionalText.GetText(cancellationToken);
		if (text == null)
		{
			return null;
		}
		try
		{
			return new XamlProjectItemForIC(projectItem!, ParseXaml(text.ToString(), assemblyCaches));
		}
		catch (Exception e)
		{
			return new XamlProjectItemForIC(projectItem!, e);
		}
	}

	static SGRootNode? ParseXaml(string xaml, AssemblyCaches assemblyCaches)
	{
		List<string> warningDisableList = [];
		var nsmgr = new XmlNamespaceManager(new NameTable());
		nsmgr.AddNamespace("__f__", XamlParser.MauiUri);
		nsmgr.AddNamespace("__g__", XamlParser.MauiGlobalUri);
		if (assemblyCaches.AllowImplicitXmlns)
		{
			nsmgr.AddNamespace("", XamlParser.DefaultImplicitUri);
			foreach (var xmlnsPrefix in assemblyCaches.XmlnsPrefixes)
				nsmgr.AddNamespace(xmlnsPrefix.Prefix, xmlnsPrefix.XmlNamespace);
		}
		using var reader = XmlReader.Create(new StringReader(xaml),
											new XmlReaderSettings { ConformanceLevel = assemblyCaches.AllowImplicitXmlns ? ConformanceLevel.Fragment : ConformanceLevel.Document },
											new XmlParserContext(nsmgr.NameTable, nsmgr, null, XmlSpace.None));
		{
			while (reader.Read())
			{
				//Skip until element
				if (reader.NodeType == XmlNodeType.Whitespace)
					continue;
				if (reader.NodeType == XmlNodeType.ProcessingInstruction)
				{
					if (reader.Name != "xaml-comp")
						continue;
					if (reader.Value.Contains("warning-disable"))
					{
						//FIXME: this need proper parsing
						reader.Value.Split(' ').Select(v => v.Trim()).Where(w => w.StartsWith("warning-disable")).ToList().ForEach(s =>
							warningDisableList.AddRange(s.Split('=').Last().Trim('"').Split(',').Select(s => s.Trim())));
					}
					continue;
				}

				if (reader.NodeType != XmlNodeType.Element)
				{
					Debug.WriteLine("Unhandled node {0} {1} {2}", reader.NodeType, reader.Name, reader.Value);
					continue;
				}

				var rootnode = new SGRootNode(new XmlType(reader.NamespaceURI, reader.Name, XamlParser.GetTypeArguments(reader)), /*typeReference, */(IXmlNamespaceResolver)reader, ((IXmlLineInfo)reader).LineNumber, ((IXmlLineInfo)reader).LinePosition)
				{
					DisableWarnings = warningDisableList,
				};
				XamlParser.ParseXaml(rootnode, reader);

				return rootnode;
			}
		}
		return null;
	}

	public static XamlProjectItemForCB? ComputeXamlProjectItemForCB((ProjectItem?, AssemblyCaches) itemAndCaches, CancellationToken cancellationToken)
	{
		(ProjectItem? projectItem, AssemblyCaches xmlnsCache) = itemAndCaches;

		if (projectItem == null)
			return null;

		var text = projectItem.AdditionalText.GetText(cancellationToken);
		if (text == null)
			return null;


		XmlNode? root;
		XmlNamespaceManager nsmgr;
		try
		{
			(root, nsmgr) = LoadXmlDocument(text, xmlnsCache, cancellationToken);
		}
		catch (Exception xe)
		{
			return new XamlProjectItemForCB(projectItem!, xe);
		}

		if (root == null)
			return null;

		ApplyTransforms(root, projectItem!.TargetFramework, nsmgr);

		foreach (XmlAttribute attr in root.Attributes)
		{
			cancellationToken.ThrowIfCancellationRequested();

			if (attr.Name == "xmlns")
				nsmgr.AddNamespace("", attr.Value); //Add default xmlns

			if (attr.Prefix != "xmlns")
				continue;

			nsmgr.AddNamespace(attr.LocalName, attr.Value);
		}

		return new XamlProjectItemForCB(projectItem, root, nsmgr);
	}

	public static (XmlNode?, XmlNamespaceManager) LoadXmlDocument(SourceText text, AssemblyCaches assemblyCaches, CancellationToken cancellationToken)
	{
		var nsmgr = new XmlNamespaceManager(new NameTable());
		nsmgr.AddNamespace("__f__", XamlParser.MauiUri);
		nsmgr.AddNamespace("__g__", XamlParser.MauiGlobalUri);
		if (assemblyCaches.AllowImplicitXmlns)
		{
			nsmgr.AddNamespace("", XamlParser.DefaultImplicitUri);
			foreach (var xmlnsPrefix in assemblyCaches.XmlnsPrefixes)
				nsmgr.AddNamespace(xmlnsPrefix.Prefix, xmlnsPrefix.XmlNamespace);
		}
		using var reader = XmlReader.Create(new StringReader(text.ToString()),
											new XmlReaderSettings { ConformanceLevel = assemblyCaches.AllowImplicitXmlns ? ConformanceLevel.Fragment : ConformanceLevel.Document },
											new XmlParserContext(nsmgr.NameTable, nsmgr, null, XmlSpace.None));


		var xmlDoc = new XmlDocument();
		xmlDoc.Load(reader);


#pragma warning disable CS0618 // Type or member is obsolete
		if (xmlDoc.DocumentElement.NamespaceURI == XamlParser.FormsUri)
			throw new Exception($"{XamlParser.FormsUri} is not a valid namespace. Use {XamlParser.MauiUri} instead");
#pragma warning restore CS0618 // Type or member is obsolete

		cancellationToken.ThrowIfCancellationRequested();

		var root = xmlDoc.SelectSingleNode("/*", nsmgr);
		return (root, nsmgr);
	}

	public static AssemblyCaches GetAssemblyAttributes(Compilation compilation, CancellationToken cancellationToken)
	{
		// [assembly: XmlnsDefinition]
		INamedTypeSymbol? xmlnsDefinitonAttribute = compilation.GetTypesByMetadataName(typeof(XmlnsDefinitionAttribute).FullName)
			.SingleOrDefault(t => t.ContainingAssembly.Identity.Name == "Microsoft.Maui.Controls");

		// [assembly: InternalsVisibleTo]
		INamedTypeSymbol? internalsVisibleToAttribute = compilation.GetTypeByMetadataName(typeof(InternalsVisibleToAttribute).FullName);

		// [assembly: XmlnsPrefix]
		INamedTypeSymbol? xmlnsPrefixAttribute = compilation.GetTypesByMetadataName(typeof(XmlnsPrefixAttribute).FullName)
			.SingleOrDefault(t => t.ContainingAssembly.Identity.Name == "Microsoft.Maui.Controls");

		// [assembly: AllowImplicitXmlnsDeclaration]
		INamedTypeSymbol? allowImplicitXmlnsAttribute = compilation.GetTypesByMetadataName(typeof(Xaml.Internals.AllowImplicitXmlnsDeclarationAttribute).FullName)
			.SingleOrDefault(t => t.ContainingAssembly.Identity.Name == "Microsoft.Maui.Controls");

		if (xmlnsDefinitonAttribute is null || internalsVisibleToAttribute is null)
		{
			return AssemblyCaches.Empty;
		}

		var xmlnsDefinitions = new List<XmlnsDefinitionAttribute>();
		var internalsVisible = new List<IAssemblySymbol>();
		var xmlnsPrefixes = new List<XmlnsPrefixAttribute>();
		var allowImplicitXmlns = compilation.Assembly.GetAttributes()
			.Any(a =>
				   SymbolEqualityComparer.Default.Equals(a.AttributeClass, allowImplicitXmlnsAttribute)
				&& (a.ConstructorArguments.Length == 0 || a.ConstructorArguments[0].Value is bool b && b));
		internalsVisible.Add(compilation.Assembly);

		IList<IAssemblySymbol> assemblies = [compilation.Assembly];
		foreach (var reference in compilation.References)
		{
			cancellationToken.ThrowIfCancellationRequested();

			var assembly = compilation.GetAssemblyOrModuleSymbol(reference);
			if (assembly is IAssemblySymbol assemblySymbol)
			{
				assemblies.Add(assemblySymbol);
			}
		}

		// load from references
		foreach (var assembly in assemblies)
		{
			cancellationToken.ThrowIfCancellationRequested();

			foreach (var attr in assembly.GetAttributes())
			{
				if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, xmlnsDefinitonAttribute))
				{
					// [assembly: XmlnsDefinition]
					var xmlnsDef = new XmlnsDefinitionAttribute(attr.ConstructorArguments[0].Value as string, attr.ConstructorArguments[1].Value as string);
					if (attr.NamedArguments.Length == 1 && attr.NamedArguments[0].Key == nameof(XmlnsDefinitionAttribute.AssemblyName))
					{
						xmlnsDef.AssemblyName = attr.NamedArguments[0].Value.Value as string;
					}
					else
					{
						xmlnsDef.AssemblyName = assembly.Name;
					}

					//only add globalxmlns definition from the current assembly
					if (xmlnsDef.XmlNamespace == XamlParser.MauiGlobalUri
						&& !SymbolEqualityComparer.Default.Equals(assembly, compilation.Assembly))
					{
						continue;
					}

					xmlnsDefinitions.Add(xmlnsDef);
				}
				else if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, internalsVisibleToAttribute))
				{
					// [assembly: InternalsVisibleTo]
					if (attr.ConstructorArguments[0].Value is string assemblyName && new AssemblyName(assemblyName).Name == compilation.Assembly.Identity.Name)
					{
						internalsVisible.Add(assembly);
					}
				}
				else if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, xmlnsPrefixAttribute))
				{
					// [assembly: XmlnsPrefix]
					var xmlnsPrefix = new XmlnsPrefixAttribute(attr.ConstructorArguments[0].Value as string, attr.ConstructorArguments[1].Value as string);
					xmlnsPrefixes.Add(xmlnsPrefix);
				}
			}
		}

		var globalXmlns = xmlnsDefinitions.Where(x => x.XmlNamespace == XamlParser.MauiGlobalUri).ToList();
		var globalGeneratedXmlnsDefinitions = new List<XmlnsDefinitionAttribute>();
		foreach (var global in globalXmlns)
		{
			var pointedXmlns = xmlnsDefinitions.Where(x => x.XmlNamespace == global.Target).ToList();
			foreach (var pointed in pointedXmlns)
			{
				xmlnsDefinitions.Add(new XmlnsDefinitionAttribute(global.XmlNamespace, pointed.Target) { AssemblyName = pointed.AssemblyName });
				globalGeneratedXmlnsDefinitions.Add(new XmlnsDefinitionAttribute(global.XmlNamespace, pointed.Target) { AssemblyName = pointed.AssemblyName });
			}
		}

		return new AssemblyCaches([.. xmlnsDefinitions.Distinct()], xmlnsPrefixes, [.. globalGeneratedXmlnsDefinitions.Distinct()], internalsVisible, allowImplicitXmlns);
	}

	static void ApplyTransforms(XmlNode node, string? targetFramework, XmlNamespaceManager nsmgr)
	{
		SimplifyOnPlatform(node, targetFramework, nsmgr);
	}

	static void SimplifyOnPlatform(XmlNode node, string? targetFramework, XmlNamespaceManager nsmgr)
	{
		//remove OnPlatform nodes if the platform doesn't match, so we don't generate field for x:Name of elements being removed
		if (targetFramework == null)
		{
			return;
		}

		string? target = null;
		targetFramework = targetFramework.Trim();
		if (targetFramework.IndexOf("-android", StringComparison.OrdinalIgnoreCase) != -1)
		{
			target = "Android";
		}

		if (targetFramework.IndexOf("-ios", StringComparison.OrdinalIgnoreCase) != -1)
		{
			target = "iOS";
		}

		if (targetFramework.IndexOf("-macos", StringComparison.OrdinalIgnoreCase) != -1)
		{
			target = "macOS";
		}

		if (targetFramework.IndexOf("-maccatalyst", StringComparison.OrdinalIgnoreCase) != -1)
		{
			target = "MacCatalyst";
		}

		if (target == null)
		{
			return;
		}

		//no need to handle {OnPlatform} markup extension, as you can't x:Name there
		var onPlatformNodes = node.SelectNodes("//__f__:OnPlatform", nsmgr);
		foreach (XmlNode onPlatformNode in onPlatformNodes)
		{
			var onNodes = onPlatformNode.SelectNodes("__f__:On", nsmgr);
			foreach (XmlNode onNode in onNodes)
			{
				var platforms = onNode.SelectSingleNode("@Platform");
				var plats = platforms.Value.Split(',');
				var match = false;

				foreach (var plat in plats)
				{
					if (string.IsNullOrWhiteSpace(plat))
					{
						continue;
					}

					if (plat.Trim() == target)
					{
						match = true;
						break;
					}
				}
				if (!match)
				{
					onNode.ParentNode.RemoveChild(onNode);
				}
			}
		}
	}

	public static IDictionary<XmlType, ITypeSymbol> GetTypeCache(Compilation compilation, CancellationToken cancellationToken) => new Dictionary<XmlType, ITypeSymbol>();

	public static SyntaxTree? GetSyntaxTree((XamlProjectItemForCB? xamlItem, AssemblyCaches xmlnsCache, IDictionary<XmlType, ITypeSymbol> typeCache, Compilation compilation) tuple, CancellationToken cancellationToken)
	{
		var options = tuple.compilation.SyntaxTrees.FirstOrDefault()?.Options as CSharpParseOptions;
		try
		{
			var code = CodeBehindCodeWriter.GenerateXamlCodeBehind(tuple.xamlItem, tuple.compilation, null, cancellationToken, tuple.xmlnsCache, tuple.typeCache);
			return CSharpSyntaxTree.ParseText(code, options: options, cancellationToken: cancellationToken);
		}
		catch (Exception)
		{
		}
		return null;
	}
}
