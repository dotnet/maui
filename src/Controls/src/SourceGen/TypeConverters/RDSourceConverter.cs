using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.Maui.Controls.Xaml;
using static Microsoft.Maui.Controls.SourceGen.LocationHelpers;

namespace Microsoft.Maui.Controls.SourceGen.TypeConverters;

internal class RDSourceConverter : ISGTypeConverter
{
	public IEnumerable<string> SupportedTypes => new[] { "ResourceDictionary", "Microsoft.Maui.Controls.ResourceDictionary", "System.Uri" };

	public string Convert(string value, BaseNode node, ITypeSymbol toType, SourceGenContext context, LocalVariable? parentVar = null)
	{
		if (parentVar == null) //should never happen
			throw new ArgumentException("parentVar is null");

		const string GetResourcePathUriScheme = "maui://";
		ITypeSymbol xamlResIdAttr = context.Compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.Xaml.XamlResourceIdAttribute")!;

		static string GetResourcePath(string value, string rootTargetPath)
		{
			var uri = new Uri(value, UriKind.RelativeOrAbsolute);
			// GetResourcePathUriScheme is a fake scheme so it's not seen as file:// uri,
			// and the forward slashes are valid on all plats
			var resourceUri = uri.OriginalString.StartsWith("/", StringComparison.Ordinal)
									? new Uri($"{GetResourcePathUriScheme}{uri.OriginalString}", UriKind.Absolute)
									: new Uri($"{GetResourcePathUriScheme}/{rootTargetPath}/../{uri.OriginalString}", UriKind.Absolute);

			//drop the leading '/'
			return resourceUri.AbsolutePath.Substring(1);
		}

		ITypeSymbol? GetTypeForResourcePath(string resourcePath, IAssemblySymbol assembly)
		{
			var attr = assembly.GetAttributes(xamlResIdAttr).FirstOrDefault(attr => (string)attr.ConstructorArguments[1].Value! == resourcePath);
			return attr?.ConstructorArguments[2].Value as ITypeSymbol;
		}

		var uriVar = NamingHelpers.CreateUniqueVariableName(context, context.Compilation.GetTypeByMetadataName("System.Uri")!);
		IAssemblySymbol asm;
		if (value.Contains(";assembly="))
		{
			var parts = value.Split([";assembly="], StringSplitOptions.RemoveEmptyEntries);
			value = parts[0];
			var asmName = parts[1];
			asm = context.Compilation.GetAssembly(asmName)!;

			//FIXME if asm is null, reportDiagnostic
		}
		else
			asm = context.RootType.ContainingAssembly;

		var uriType = context.Compilation.GetTypeByMetadataName("System.Uri")!;
		var uriKindType = context.Compilation.GetTypeByMetadataName("System.UriKind")!;
		context.Writer.WriteLine($"var {uriVar} = new {uriType.ToFQDisplayString()}(\"{value};assembly={asm.Name}\", {uriKindType.ToFQDisplayString()}.RelativeOrAbsolute);");

		var rootTargetPath = context.ProjectItem.RelativePath!.Replace('\\', '/');

		if (asm.GetAttributes(xamlResIdAttr).FirstOrDefault(attr => (string)attr.ConstructorArguments[1].Value! == GetResourcePath(value, rootTargetPath)) is null)
			context.ReportDiagnostic(Diagnostic.Create(Descriptors.XamlParserError, LocationCreate(context.ProjectItem.RelativePath!, (IXmlLineInfo)node, value), $"Resource {value} is not a valid resource path."));

		//is there a type associated with the resource ?
		if (GetTypeForResourcePath(GetResourcePath(value, rootTargetPath), asm) is ITypeSymbol type)
			//FIXME: this doesn't work for resources in current assembly, as the attribute is generated by sourcegen, and not in the compilation
			context.Writer.WriteLine($"{parentVar.Name}.SetAndCreateSource<{type.ToFQDisplayString()}>({uriVar});");
		//well, if not, we can still load it
		else
		{
			var resourceDictionaryHelpersType = context.Compilation.GetTypeByMetadataName("Microsoft.Maui.Controls.Xaml.ResourceDictionaryHelpers")!;
			context.Writer.WriteLine($"{resourceDictionaryHelpersType.ToFQDisplayString()}.LoadFromSource({parentVar.Name}, {uriVar}, \"{GetResourcePath(value, rootTargetPath)}\", typeof({context.RootType.ToFQDisplayString()}).Assembly, null);");
		}

		return uriVar;
	}
}