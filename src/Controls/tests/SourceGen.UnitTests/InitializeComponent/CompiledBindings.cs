using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Xunit;

namespace Microsoft.Maui.Controls.SourceGen.UnitTests;

public class CompiledBindings : SourceGenXamlInitializeComponentTestBase
{
	[Fact]
	public void CanDetectXDataType()
	{
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage"
	Title="{Binding Foo.Bar.Title, Mode=TwoWay}"/>
""";

		var code =
"""
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Foo Foo { get; set; } = new Foo { Bar = new Bar() };

	public TestPage()
	{
		InitializeComponent();
	}
}

public class Foo
{
	public Bar Bar { get; set; }
}

public struct Bar
{
	public string Title { get; set; } = "Title";
}
""";
		var testXamlFilePath = Path.Combine(Environment.CurrentDirectory, "Test.xaml");
		var expected = $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a .NET MAUI source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used

namespace Test;

[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Maui.Controls.SourceGen, Version=10.0.0.0, Culture=neutral, PublicKeyToken=null", "10.0.0.0")]
public partial class TestPage
{
	private partial void InitializeComponent()
	{
		// Fallback to Runtime inflation if the page was updated by HotReload
		static string? getPathForType(global::System.Type type)
		{
			var assembly = type.Assembly;
			foreach (var xria in global::System.Reflection.CustomAttributeExtensions.GetCustomAttributes<global::Microsoft.Maui.Controls.Xaml.XamlResourceIdAttribute>(assembly))
			{
				if (xria.Type == type)
					return xria.Path;
			}
			return null;
		}

		var rlr = global::Microsoft.Maui.Controls.Internals.ResourceLoader.ResourceProvider2?.Invoke(new global::Microsoft.Maui.Controls.Internals.ResourceLoader.ResourceLoadingQuery
		{
			AssemblyName = typeof(global::Test.TestPage).Assembly.GetName(),
			ResourcePath = getPathForType(typeof(global::Test.TestPage)),
			Instance = this,
		});

		if (rlr?.ResourceContent != null)
		{
			this.InitializeComponentRuntime();
			return;
		}

		var bindingExtension = new global::Microsoft.Maui.Controls.Xaml.BindingExtension();
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(bindingExtension!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 2);
		var __root = this;
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(__root!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 2, 2);
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		global::Microsoft.Maui.Controls.Internals.INameScope iNameScope = global::Microsoft.Maui.Controls.Internals.NameScope.GetNameScope(__root) ?? new global::Microsoft.Maui.Controls.Internals.NameScope();
#endif
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		global::Microsoft.Maui.Controls.Internals.NameScope.SetNameScope(__root, iNameScope);
#endif
#line 8 "{{testXamlFilePath}}"
		bindingExtension.Mode = global::Microsoft.Maui.Controls.BindingMode.TwoWay;
#line default
#line 8 "{{testXamlFilePath}}"
		bindingExtension.Path = "Foo.Bar.Title";
#line default
		var bindingBase = CreateTypedBindingFrom_bindingExtension(bindingExtension);
		if (global::Microsoft.Maui.VisualDiagnostics.GetSourceInfo(bindingBase!) == null)
			global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(bindingBase!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 2);
		__root.SetBinding(global::Microsoft.Maui.Controls.Page.TitleProperty, bindingBase);
		static global::Microsoft.Maui.Controls.BindingBase CreateTypedBindingFrom_bindingExtension(global::Microsoft.Maui.Controls.Xaml.BindingExtension extension)
		{
			global::System.Action<global::Test.TestPage, string>? setter = static (source, value) =>
			{
				if (source.Foo.Bar is {} p0)
				{
					p0.Title = value;
				}
			};

			return new global::Microsoft.Maui.Controls.Internals.TypedBinding<global::Test.TestPage, string>(
				getter: source => (source.Foo.Bar.Title, true),
				setter,
				handlers: new global::System.Tuple<global::System.Func<global::Test.TestPage, object?>, string>[]
				{
					new(static source => source, "Foo"),
					new(static source => source.Foo, "Bar"),
					new(static source => source.Foo.Bar, "Title"),
				})
				{
					Mode = extension.Mode,
				};
		}

		
	}
}

""";

		var (result, generated) = RunGenerator(xaml, code);
		Assert.False(result.Diagnostics.Any());
		CodeIsEqual(expected, generated ?? string.Empty);
	}

	[Fact]
	public void CorrectlyDetectsNullableTypes()
	{
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage"
	Title="{Binding Product.Size}"/>
""";

		var code =
"""
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Product? Product { get; set; } = null;

	public TestPage()
	{
		InitializeComponent();
	}
}

public class Product
{
	public int Size { get; set; }
}
""";
		var testXamlFilePath = Path.Combine(Environment.CurrentDirectory, "Test.xaml");
		var expected = $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a .NET MAUI source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used

namespace Test;

[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Maui.Controls.SourceGen, Version=10.0.0.0, Culture=neutral, PublicKeyToken=null", "10.0.0.0")]
public partial class TestPage
{
	private partial void InitializeComponent()
	{
		// Fallback to Runtime inflation if the page was updated by HotReload
		static string? getPathForType(global::System.Type type)
		{
			var assembly = type.Assembly;
			foreach (var xria in global::System.Reflection.CustomAttributeExtensions.GetCustomAttributes<global::Microsoft.Maui.Controls.Xaml.XamlResourceIdAttribute>(assembly))
			{
				if (xria.Type == type)
					return xria.Path;
			}
			return null;
		}

		var rlr = global::Microsoft.Maui.Controls.Internals.ResourceLoader.ResourceProvider2?.Invoke(new global::Microsoft.Maui.Controls.Internals.ResourceLoader.ResourceLoadingQuery
		{
			AssemblyName = typeof(global::Test.TestPage).Assembly.GetName(),
			ResourcePath = getPathForType(typeof(global::Test.TestPage)),
			Instance = this,
		});

		if (rlr?.ResourceContent != null)
		{
			this.InitializeComponentRuntime();
			return;
		}

		var bindingExtension = new global::Microsoft.Maui.Controls.Xaml.BindingExtension();
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(bindingExtension!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 2);
		var __root = this;
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(__root!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 2, 2);
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		global::Microsoft.Maui.Controls.Internals.INameScope iNameScope = global::Microsoft.Maui.Controls.Internals.NameScope.GetNameScope(__root) ?? new global::Microsoft.Maui.Controls.Internals.NameScope();
#endif
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		global::Microsoft.Maui.Controls.Internals.NameScope.SetNameScope(__root, iNameScope);
#endif
#line 8 "{{testXamlFilePath}}"
		bindingExtension.Path = "Product.Size";
#line default
		var bindingBase = CreateTypedBindingFrom_bindingExtension(bindingExtension);
		if (global::Microsoft.Maui.VisualDiagnostics.GetSourceInfo(bindingBase!) == null)
			global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(bindingBase!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 2);
		__root.SetBinding(global::Microsoft.Maui.Controls.Page.TitleProperty, bindingBase);
		static global::Microsoft.Maui.Controls.BindingBase CreateTypedBindingFrom_bindingExtension(global::Microsoft.Maui.Controls.Xaml.BindingExtension extension)
		{
			global::System.Action<global::Test.TestPage, int>? setter = static (source, value) =>
			{
				if (source.Product is {} p0)
				{
					p0.Size = value;
				}
			};
			
			return new global::Microsoft.Maui.Controls.Internals.TypedBinding<global::Test.TestPage, int>(
				getter: source => (source.Product?.Size ?? default, true),
				setter,
				handlers: new global::System.Tuple<global::System.Func<global::Test.TestPage, object?>, string>[]
				{
					new(static source => source, "Product"),
					new(static source => source.Product, "Size"),
				});
		}
	}
}

""";

		var (result, generated) = RunGenerator(xaml, code);
		Assert.False(result.Diagnostics.Any());
		CodeIsEqual(expected, generated ?? string.Empty);
	}

	internal static void CodeIsEqual(string expectedCode, string actualCode)
	{
		var expectedLines = SplitCode(expectedCode);
		var actualLines = SplitCode(actualCode);

		foreach (var (expectedLine, actualLine) in expectedLines.Zip(actualLines))
		{
			Assert.Equal(expectedLine, actualLine);
		}

		Assert.Equal(expectedLines.Count(), actualLines.Count());

		static IEnumerable<string> SplitCode(string code)
			=> code.Split(Environment.NewLine)
				.Select(static line => line.Trim())
				.Where(static line => !string.IsNullOrWhiteSpace(line))
				.Where(static line => !line.StartsWith("#pragma warning", StringComparison.Ordinal));
	}

	[Fact]
	public void CorrectlyDetectsNullableReferenceTypes()
	{
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage">
	<Entry Text="{Binding Product.Name}"/>
</ContentPage>
""";

		var code =
"""
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Product? Product { get; set; } = null;

	public TestPage()
	{
		InitializeComponent();
	}
}

public class Product
{
	public string Name { get; set; } = "";
}
""";
		var testXamlFilePath = Path.Combine(Environment.CurrentDirectory, "Test.xaml");
		var expected = $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a .NET MAUI source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used

namespace Test;

[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Maui.Controls.SourceGen, Version=10.0.0.0, Culture=neutral, PublicKeyToken=null", "10.0.0.0")]
public partial class TestPage
{
	private partial void InitializeComponent()
	{
		// Fallback to Runtime inflation if the page was updated by HotReload
		static string? getPathForType(global::System.Type type)
		{
			var assembly = type.Assembly;
			foreach (var xria in global::System.Reflection.CustomAttributeExtensions.GetCustomAttributes<global::Microsoft.Maui.Controls.Xaml.XamlResourceIdAttribute>(assembly))
			{
				if (xria.Type == type)
					return xria.Path;
			}
			return null;
		}

		var rlr = global::Microsoft.Maui.Controls.Internals.ResourceLoader.ResourceProvider2?.Invoke(new global::Microsoft.Maui.Controls.Internals.ResourceLoader.ResourceLoadingQuery
		{
			AssemblyName = typeof(global::Test.TestPage).Assembly.GetName(),
			ResourcePath = getPathForType(typeof(global::Test.TestPage)),
			Instance = this,
		});

		if (rlr?.ResourceContent != null)
		{
			this.InitializeComponentRuntime();
			return;
		}

		var bindingExtension = new global::Microsoft.Maui.Controls.Xaml.BindingExtension();
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(bindingExtension!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 9);
		var entry = new global::Microsoft.Maui.Controls.Entry();
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(entry!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 3);
		var __root = this;
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(__root!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 2, 2);
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		global::Microsoft.Maui.Controls.Internals.INameScope iNameScope = global::Microsoft.Maui.Controls.Internals.NameScope.GetNameScope(__root) ?? new global::Microsoft.Maui.Controls.Internals.NameScope();
#endif
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		global::Microsoft.Maui.Controls.Internals.NameScope.SetNameScope(__root, iNameScope);
#endif
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		entry.transientNamescope = iNameScope;
#endif
#line 8 "{{testXamlFilePath}}"
		bindingExtension.Path = "Product.Name";
#line default
		var bindingBase = CreateTypedBindingFrom_bindingExtension(bindingExtension);
		if (global::Microsoft.Maui.VisualDiagnostics.GetSourceInfo(bindingBase!) == null)
			global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(bindingBase!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 9);
		entry.SetBinding(global::Microsoft.Maui.Controls.Entry.TextProperty, bindingBase);
#line 8 "{{testXamlFilePath}}"
		__root.SetValue(global::Microsoft.Maui.Controls.ContentPage.ContentProperty, entry);
#line default
		static global::Microsoft.Maui.Controls.BindingBase CreateTypedBindingFrom_bindingExtension(global::Microsoft.Maui.Controls.Xaml.BindingExtension extension)
		{
			global::System.Action<global::Test.TestPage, string?>? setter = static (source, value) =>
			{
				if (value is null)
				{
					return;
				}
				if (source.Product is {} p0)
				{
					p0.Name = value;
				}
			};
			
			return new global::Microsoft.Maui.Controls.Internals.TypedBinding<global::Test.TestPage, string?>(
				getter: source => (source.Product?.Name, true),
				setter,
				handlers: new global::System.Tuple<global::System.Func<global::Test.TestPage, object?>, string>[]
				{
					new(static source => source, "Product"),
					new(static source => source.Product, "Name"),
				});
		}
	}
}

""";

		var (result, generated) = RunGenerator(xaml, code);
		Assert.False(result.Diagnostics.Any());
		CodeIsEqual(expected, generated ?? string.Empty);
	}

	[Fact]
	public void CorrectlyDetectsNullableReferenceTypesWithNonNullableTarget()
	{
		// This test reproduces the CS8603 error scenario
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage">
	<Entry Text="{Binding Product.Name}"/>
</ContentPage>
""";

		var code =
"""
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Product? Product { get; set; } = null;

	public TestPage()
	{
		InitializeComponent();
	}
}

public class Product
{
	public string Name { get; set; } = "";  // Non-nullable string
}
""";
		var (result, generated) = RunGenerator(xaml, code);
		
		// Check that no CS8603 errors are present - even with non-nullable target property,
		// the generated getter should handle the nullable path correctly
		Assert.False(result.Diagnostics.Any(d => d.Id == "CS8603"));
		Assert.False(result.Diagnostics.Any(d => d.Severity == Microsoft.CodeAnalysis.DiagnosticSeverity.Error));
	}

	[Fact]
	public void CorrectlyHandlesNullableValueTypesWithNonNullableTarget()
	{
		// This test covers binding to a non-nullable value type property through a nullable path
		// Note: In XAML SourceGen, value types accessed through nullable paths remain non-nullable
		// (using ?? default fallback in getter) rather than becoming Nullable<T>
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage">
	<Slider Value="{Binding Product.Quantity}"/>
</ContentPage>
""";

		var code =
"""
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Product? Product { get; set; } = null;

	public TestPage()
	{
		InitializeComponent();
	}
}

public class Product
{
	public double Quantity { get; set; } = 0;  // Non-nullable double
}
""";
		var (result, generated) = RunGenerator(xaml, code);
		
		// Verify no errors are present - value types through nullable paths don't need null checks
		// because they use ?? default fallback in the getter and keep the non-nullable type
		Assert.False(result.Diagnostics.Any(d => d.Severity == Microsoft.CodeAnalysis.DiagnosticSeverity.Error));
		Assert.NotNull(generated);
		
		// The setter for value types should NOT have HasValue check because PropertyType stays as double, not double?
		// The conditional access is handled by pattern matching (source.Product is {} p0)
		Assert.Contains("if (source.Product is {} p0)", generated, StringComparison.Ordinal);
	}

	[Fact]
	public void TargetNullValueWithNullablePathGeneratesValidCode()
	{
		// This test reproduces the issue from #32606 where TargetNullValue with nullable path
		// generates invalid code: getter references extension.TargetNullValue but cannot be static
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage">
	<Label Text="{Binding CurrentPerson.Id, TargetNullValue=0}"/>
</ContentPage>
""";

		var code =
"""
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Person? CurrentPerson { get; set; } = null;

	public TestPage()
	{
		InitializeComponent();
	}
}

public class Person
{
	public int Id { get; set; }
}
""";
		var testXamlFilePath = Path.Combine(Environment.CurrentDirectory, "Test.xaml");
		var expected = $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a .NET MAUI source generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used

namespace Test;

[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Maui.Controls.SourceGen, Version=10.0.0.0, Culture=neutral, PublicKeyToken=null", "10.0.0.0")]
public partial class TestPage
{
	private partial void InitializeComponent()
	{
		// Fallback to Runtime inflation if the page was updated by HotReload
		static string? getPathForType(global::System.Type type)
		{
			var assembly = type.Assembly;
			foreach (var xria in global::System.Reflection.CustomAttributeExtensions.GetCustomAttributes<global::Microsoft.Maui.Controls.Xaml.XamlResourceIdAttribute>(assembly))
			{
				if (xria.Type == type)
					return xria.Path;
			}
			return null;
		}

		var rlr = global::Microsoft.Maui.Controls.Internals.ResourceLoader.ResourceProvider2?.Invoke(new global::Microsoft.Maui.Controls.Internals.ResourceLoader.ResourceLoadingQuery
		{
			AssemblyName = typeof(global::Test.TestPage).Assembly.GetName(),
			ResourcePath = getPathForType(typeof(global::Test.TestPage)),
			Instance = this,
		});

		if (rlr?.ResourceContent != null)
		{
			this.InitializeComponentRuntime();
			return;
		}

		var bindingExtension = new global::Microsoft.Maui.Controls.Xaml.BindingExtension();
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(bindingExtension!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 9);
		var label = new global::Microsoft.Maui.Controls.Label();
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(label!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 3);
		var __root = this;
		global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(__root!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 2, 2);
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		global::Microsoft.Maui.Controls.Internals.INameScope iNameScope = global::Microsoft.Maui.Controls.Internals.NameScope.GetNameScope(__root) ?? new global::Microsoft.Maui.Controls.Internals.NameScope();
#endif
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		global::Microsoft.Maui.Controls.Internals.NameScope.SetNameScope(__root, iNameScope);
#endif
#if !_MAUIXAML_SG_NAMESCOPE_DISABLE
		label.transientNamescope = iNameScope;
#endif
#line 8 "{{testXamlFilePath}}"
		bindingExtension.TargetNullValue = "0";
#line default
#line 8 "{{testXamlFilePath}}"
		bindingExtension.Path = "CurrentPerson.Id";
#line default
		var bindingBase = CreateTypedBindingFrom_bindingExtension(bindingExtension);
		if (global::Microsoft.Maui.VisualDiagnostics.GetSourceInfo(bindingBase!) == null)
			global::Microsoft.Maui.VisualDiagnostics.RegisterSourceInfo(bindingBase!, new global::System.Uri(@"Test.xaml;assembly=SourceGeneratorDriver.Generated", global::System.UriKind.Relative), 8, 9);
		label.SetBinding(global::Microsoft.Maui.Controls.Label.TextProperty, bindingBase);
#line 8 "{{testXamlFilePath}}"
		__root.SetValue(global::Microsoft.Maui.Controls.ContentPage.ContentProperty, label);
#line default
		static global::Microsoft.Maui.Controls.BindingBase CreateTypedBindingFrom_bindingExtension(global::Microsoft.Maui.Controls.Xaml.BindingExtension extension)
		{
			global::System.Action<global::Test.TestPage, int>? setter = static (source, value) =>
			{
				if (source.CurrentPerson is {} p0)
				{
					p0.Id = value;
				}
			};

			return new global::Microsoft.Maui.Controls.Internals.TypedBinding<global::Test.TestPage, int>(
				getter: source => (source.CurrentPerson?.Id ?? extension.TargetNullValue as int? ?? default, true),
				setter,
				handlers: new global::System.Tuple<global::System.Func<global::Test.TestPage, object?>, string>[]
				{
					new(static source => source, "CurrentPerson"),
					new(static source => source.CurrentPerson, "Id"),
				})
			{
				TargetNullValue = extension.TargetNullValue,
			};
		}

		
	}
}

""";

		var (result, generated) = RunGenerator(xaml, code);

		// Verify the generated code matches expected structure
		CodeIsEqual(expected, generated ?? string.Empty);
	}

	[Theory]
	[InlineData("{Binding .}")]
	[InlineData("{Binding}")]
	[InlineData("{Binding Path=.}")]
	public void CanCompileSelfBinding(string bindingExpression)
	{
		var xaml =
$$"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestViewModel">
	<Label Text="{{bindingExpression}}"/>
</ContentPage>
""";

		var code =
"""
#nullable enable
#pragma warning disable CS0219 // Variable is assigned but its value is never used
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public TestPage()
	{
		InitializeComponent();
	}
}

public class TestViewModel
{Expand commentComment on line R323ResolvedCode has comments. Press enter to view.
	public override string ToString() => "ViewModel Value";
}
""";

		var (result, generated) = RunGenerator(xaml, code);

		// Verify it compiles without errors
		Assert.Empty(result.Diagnostics);

		// Verify generated code exists
		Assert.NotNull(generated);

		// Verify the generated code contains a TypedBinding for self-binding
		Assert.Contains("TypedBinding<global::Test.TestViewModel, global::Test.TestViewModel>", generated, StringComparison.Ordinal);

		// Verify the getter is the identity function for self-binding
		Assert.Contains("getter: source => (source, true)", generated, StringComparison.Ordinal);

		// Verify setter is null for self-bindings (not writable)
		Assert.Contains("global::System.Action<global::Test.TestViewModel, global::Test.TestViewModel>? setter = null;", generated, StringComparison.Ordinal);

		// Verify handlers array is empty for self-bindings (no items in the array)
		// Use regex to match the empty array pattern without relying on exact whitespace
		var emptyHandlersPattern = @"handlers:\s*new\s+global::System\.Tuple<global::System\.Func<global::Test\.TestViewModel,\s*object\?>,\s*string>\[\]\s*\{\s*\}";
		Assert.Matches(emptyHandlersPattern, generated);
	}

	[Fact]
	public void ValueTypeAtEndOfConditionalAccessPath()
	{
		// Test value type property at the end of a binding path with conditional access in the middle
		// The setter should use pattern matching and NOT have HasValue check since PropertyType is non-nullable
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage">
	<Label Text="{Binding Container.Count}"/>
</ContentPage>
""";

		var code =
"""
#nullable enable
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Container? Container { get; set; }
}

public class Container
{
	public int Count { get; set; }
}
""";

		var (result, generated) = RunGenerator(xaml, code);
		
		Assert.False(result.Diagnostics.Any(d => d.Severity == Microsoft.CodeAnalysis.DiagnosticSeverity.Error));
		Assert.NotNull(generated);
		
		// Verify setter uses pattern matching for conditional access
		Assert.Contains("if (source.Container is {} p0)", generated, StringComparison.Ordinal);
		
		// Should NOT have HasValue check since Count is int, not int?
		Assert.DoesNotContain("HasValue", generated, StringComparison.Ordinal);
		
		// Getter should have ?? default for value type through nullable path
		Assert.Contains("?? default", generated, StringComparison.Ordinal);
	}

	[Fact]
	public void NonNullableReferenceTypeAtEndOfConditionalAccessPath()
	{
		// Test non-nullable reference type property at the end of a binding path with conditional access
		// The setter should have an early return for null since the target property doesn't accept null
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage">
	<Entry Text="{Binding Container.Label}"/>
</ContentPage>
""";

		var code =
"""
#nullable enable
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Container? Container { get; set; }
}

public class Container
{
	public string Label { get; set; } = "";  // Non-nullable string
}
""";

		var (result, generated) = RunGenerator(xaml, code);
		
		Assert.False(result.Diagnostics.Any(d => d.Severity == Microsoft.CodeAnalysis.DiagnosticSeverity.Error));
		Assert.NotNull(generated);
		
		// Verify setter has early return for null since Label doesn't accept null
		Assert.Contains("if (value is null)", generated, StringComparison.Ordinal);
		Assert.Contains("return;", generated, StringComparison.Ordinal);
		
		// Verify setter uses pattern matching for conditional access
		Assert.Contains("if (source.Container is {} p0)", generated, StringComparison.Ordinal);
	}

	[Fact]
	public void NullableReferenceTypeAtEndOfConditionalAccessPath()
	{
		// Test nullable reference type property at the end of a binding path with conditional access
		// The setter should NOT have an early return since the target property accepts null
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage">
	<Entry Text="{Binding Container.Description}"/>
</ContentPage>
""";

		var code =
"""
#nullable enable
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Container? Container { get; set; }
}

public class Container
{
	public string? Description { get; set; }  // Nullable string
}
""";

		var (result, generated) = RunGenerator(xaml, code);
		
		Assert.False(result.Diagnostics.Any(d => d.Severity == Microsoft.CodeAnalysis.DiagnosticSeverity.Error));
		Assert.NotNull(generated);
		
		// Verify setter does NOT have early return since Description accepts null
		// The setter should just use pattern matching without null check on value
		Assert.Contains("if (source.Container is {} p0)", generated, StringComparison.Ordinal);
		
		// Check the setter signature accepts nullable
		Assert.Contains("global::System.Action<global::Test.TestPage, string?>", generated, StringComparison.Ordinal);
		
		// The pattern "if (value is null)" followed by "return;" should NOT appear together
		// This would indicate an early return that we don't want for nullable target properties
		var lines = generated.Split('\n');
		bool hasEarlyReturn = false;
		for (int i = 0; i < lines.Length - 1; i++)
		{
			if (lines[i].Contains("if (value is null)", StringComparison.Ordinal))
			{
				// Check if the next few lines contain a return statement
				for (int j = i + 1; j < Math.Min(i + 5, lines.Length); j++)
				{
					if (lines[j].Trim() == "return;")
					{
						hasEarlyReturn = true;
						break;
					}
					// If we hit the closing brace or another statement, stop looking
					if (lines[j].Contains("}", StringComparison.Ordinal) || lines[j].Contains("if (", StringComparison.Ordinal))
					{
						break;
					}
				}
			}
		}
		Assert.False(hasEarlyReturn, "Setter should NOT have early return for nullable target property");
	}

	[Fact]
	public void NullableValueTypeAtEndOfConditionalAccessPath()
	{
		// Test nullable value type property (int?) at the end of a binding path with conditional access
		// The setter should NOT have an early return since the target property accepts null
		var xaml =
"""
<?xml version="1.0" encoding="UTF-8"?>
<ContentPage
	xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
	xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
	xmlns:test="clr-namespace:Test"
	x:Class="Test.TestPage"
	x:DataType="test:TestPage">
	<Label Text="{Binding Container.OptionalCount}"/>
</ContentPage>
""";

		var code =
"""
#nullable enable
using System;
using Microsoft.Maui.Controls;
using Microsoft.Maui.Controls.Xaml;

namespace Test;

[XamlProcessing(XamlInflator.SourceGen)]
public partial class TestPage : ContentPage
{
	public Container? Container { get; set; }
}

public class Container
{
	public int? OptionalCount { get; set; }  // Nullable int
}
""";

		var (result, generated) = RunGenerator(xaml, code);
		
		Assert.False(result.Diagnostics.Any(d => d.Severity == Microsoft.CodeAnalysis.DiagnosticSeverity.Error));
		Assert.NotNull(generated);
		
		// Verify setter uses pattern matching for conditional access
		Assert.Contains("if (source.Container is {} p0)", generated, StringComparison.Ordinal);
		
		// Check the setter signature accepts nullable value type
		Assert.Contains("global::System.Action<global::Test.TestPage, int?>", generated, StringComparison.Ordinal);
		
		// Should NOT have early return for null value since OptionalCount accepts null
		var lines = generated.Split('\n');
		bool hasEarlyReturn = false;
		for (int i = 0; i < lines.Length - 1; i++)
		{
			if (lines[i].Contains("if (!value.HasValue)", StringComparison.Ordinal) || lines[i].Contains("if (value is null)", StringComparison.Ordinal))
			{
				// Check if the next few lines contain a return statement
				for (int j = i + 1; j < Math.Min(i + 5, lines.Length); j++)
				{
					if (lines[j].Trim() == "return;")
					{
						hasEarlyReturn = true;
						break;
					}
					if (lines[j].Contains("}", StringComparison.Ordinal) || lines[j].Contains("if (", StringComparison.Ordinal))
					{
						break;
					}
				}
			}
		}
		Assert.False(hasEarlyReturn, "Setter should NOT have early return for nullable value type target property");
	}
}
