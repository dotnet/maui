using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.Maui.Controls.BindingSourceGen;
using Xunit;

namespace BindingSourceGen.UnitTests;

public class ObservablePropertyTests
{
	// Note: Expression-based bindings work with ObservableProperty through type inference in
	// GetLambdaReturnType. The generated interceptor code will be correct. In tests,
	// we'll see compilation errors because the actual generated property doesn't exist
	// (CommunityToolkit.Mvvm's source generator isn't running in the test environment),
	// but the interceptor code itself is generated correctly.

	[Fact]
	public void GenerateBindingToObservablePropertyFromCamelCaseField()
	{
		var source = """
			using Microsoft.Maui.Controls;
			using System.Collections.ObjectModel;

			namespace CommunityToolkit.Mvvm.ComponentModel
			{
				[System.AttributeUsage(System.AttributeTargets.Field)]
				public class ObservablePropertyAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.ComponentModel.ObservableProperty]
					private string? name;
					// Name property will be generated by CommunityToolkit.Mvvm
				}

				public class TestCode
				{
					public void Test()
					{
						var label = new Label();
						label.SetBinding(Label.TextProperty, static (MyViewModel vm) => vm.Name);
					}
				}
			}
			""";

		var result = SourceGenHelpers.Run(source);

		// The binding should be generated successfully with ObservableProperty inference
		Assert.NotNull(result.Binding);

		// Verify the generated interceptor code contains the correct getter and setter references
		var allGeneratedCode = string.Join("\n\n", result.GeneratedFiles.Values);
		// Check that the handler contains the property access
		Assert.Contains("\"Name\"", allGeneratedCode, System.StringComparison.Ordinal);
		// Check that setter assigns to .Name
		Assert.Contains("source.Name = value;", allGeneratedCode, System.StringComparison.Ordinal);

		// Note: There will be compilation errors because Name doesn't actually exist,
		// but the interceptor code itself is generated correctly. In real usage with
		// CommunityToolkit.Mvvm, the property would exist and compile successfully.
	}

	[Fact]
	public void GenerateBindingToObservablePropertyFromUnderscorePrefixedField()
	{
		var source = """
			using Microsoft.Maui.Controls;
			using System.Collections.ObjectModel;

			namespace CommunityToolkit.Mvvm.ComponentModel
			{
				[System.AttributeUsage(System.AttributeTargets.Field)]
				public class ObservablePropertyAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.ComponentModel.ObservableProperty]
					private string? _title;
					// Title property will be generated by CommunityToolkit.Mvvm
				}

				public class TestCode
				{
					public void Test()
					{
						var label = new Label();
						label.SetBinding(Label.TextProperty, static (MyViewModel vm) => vm.Title);
					}
				}
			}
			""";

		var result = SourceGenHelpers.Run(source);

		// The binding should be generated successfully with ObservableProperty inference
		Assert.NotNull(result.Binding);

		// Verify the generated interceptor code contains the correct getter and setter references
		var allGeneratedCode = string.Join("\n\n", result.GeneratedFiles.Values);
		// Check that the handler contains the property access
		Assert.Contains("\"Title\"", allGeneratedCode, System.StringComparison.Ordinal);
		// Check that setter assigns to .Title
		Assert.Contains("source.Title = value;", allGeneratedCode, System.StringComparison.Ordinal);
	}

	[Fact]
	public void GenerateBindingToObservablePropertyCollection()
	{
		var source = """
			using Microsoft.Maui.Controls;
			using System.Collections.ObjectModel;

			namespace CommunityToolkit.Mvvm.ComponentModel
			{
				[System.AttributeUsage(System.AttributeTargets.Field)]
				public class ObservablePropertyAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class Tag { }

				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.ComponentModel.ObservableProperty]
					private ObservableCollection<Tag> _tags = new();
					// Tags property will be generated by CommunityToolkit.Mvvm
				}

				public class TestCode
				{
					public void Test()
					{
						var label = new Label();
						label.SetBinding(Label.BindingContextProperty, static (MyViewModel vm) => vm.Tags);
					}
				}
			}
			""";

		var result = SourceGenHelpers.Run(source);

		// The binding should be generated successfully with ObservableProperty inference
		Assert.NotNull(result.Binding);

		// Verify the generated interceptor code contains the correct getter and setter references
		var allGeneratedCode = string.Join("\n\n", result.GeneratedFiles.Values);
		// Check that the handler contains the property access
		Assert.Contains("\"Tags\"", allGeneratedCode, System.StringComparison.Ordinal);
		// Check that setter assigns to .Tags
		Assert.Contains("source.Tags = value;", allGeneratedCode, System.StringComparison.Ordinal);
	}
}
