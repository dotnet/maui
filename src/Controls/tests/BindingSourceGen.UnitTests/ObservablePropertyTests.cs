using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.Maui.Controls.BindingSourceGen;
using Xunit;

namespace BindingSourceGen.UnitTests;

public class ObservablePropertyTests
{
	// Note: Expression-based bindings work with ObservableProperty through type inference in
	// GetLambdaReturnType. The generated interceptor code will be correct. In tests,
	// we'll see compilation errors because the actual generated property doesn't exist
	// (CommunityToolkit.Mvvm's source generator isn't running in the test environment),
	// but the interceptor code itself is generated correctly.

	[Fact]
	public void GenerateBindingToObservablePropertyFromCamelCaseField()
	{
		var source = """
			using Microsoft.Maui.Controls;
			using System.Collections.ObjectModel;

			namespace CommunityToolkit.Mvvm.ComponentModel
			{
				[System.AttributeUsage(System.AttributeTargets.Field)]
				public class ObservablePropertyAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.ComponentModel.ObservableProperty]
					private string? name;
					// Name property will be generated by CommunityToolkit.Mvvm
				}

				public class TestCode
				{
					public void Test()
					{
						var label = new Label();
						label.SetBinding(Label.TextProperty, static (MyViewModel vm) => vm.Name);
					}
				}
			}
			""";

		var result = SourceGenHelpers.Run(source);

		// The binding should be generated successfully with ObservableProperty inference
		Assert.NotNull(result.Binding);

		// Verify the generated interceptor code contains the Name property access
		var allGeneratedCode = string.Join("\n\n", result.GeneratedFiles.Values);
		Assert.Contains("Name", allGeneratedCode, System.StringComparison.Ordinal);

		// Note: There will be compilation errors because Name doesn't actually exist,
		// but the interceptor code itself is generated correctly. In real usage with
		// CommunityToolkit.Mvvm, the property would exist and compile successfully.
	}

	[Fact]
	public void GenerateBindingToObservablePropertyFromUnderscorePrefixedField()
	{
		var source = """
			using Microsoft.Maui.Controls;
			using System.Collections.ObjectModel;

			namespace CommunityToolkit.Mvvm.ComponentModel
			{
				[System.AttributeUsage(System.AttributeTargets.Field)]
				public class ObservablePropertyAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.ComponentModel.ObservableProperty]
					private string? _title;
					// Title property will be generated by CommunityToolkit.Mvvm
				}

				public class TestCode
				{
					public void Test()
					{
						var label = new Label();
						label.SetBinding(Label.TextProperty, static (MyViewModel vm) => vm.Title);
					}
				}
			}
			""";

		var result = SourceGenHelpers.Run(source);

		// The binding should be generated successfully with ObservableProperty inference
		Assert.NotNull(result.Binding);

		// Verify the generated interceptor code contains the Title property access
		var allGeneratedCode = string.Join("\n\n", result.GeneratedFiles.Values);
		Assert.Contains("Title", allGeneratedCode, System.StringComparison.Ordinal);
	}

	[Fact]
	public void GenerateBindingToObservablePropertyCollection()
	{
		var source = """
			using Microsoft.Maui.Controls;
			using System.Collections.ObjectModel;

			namespace CommunityToolkit.Mvvm.ComponentModel
			{
				[System.AttributeUsage(System.AttributeTargets.Field)]
				public class ObservablePropertyAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class Tag { }

				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.ComponentModel.ObservableProperty]
					private ObservableCollection<Tag> _tags = new();
					// Tags property will be generated by CommunityToolkit.Mvvm
				}

				public class TestCode
				{
					public void Test()
					{
						var label = new Label();
						label.SetBinding(Label.BindingContextProperty, static (MyViewModel vm) => vm.Tags);
					}
				}
			}
			""";

		var result = SourceGenHelpers.Run(source);

		// The binding should be generated successfully with ObservableProperty inference
		Assert.NotNull(result.Binding);

		// Verify the generated interceptor code contains the Tags property access
		var allGeneratedCode = string.Join("\n\n", result.GeneratedFiles.Values);
		Assert.Contains("Tags", allGeneratedCode, System.StringComparison.Ordinal);
	}

	[Fact]
	public void DetectsObservablePropertyFromCamelCaseField()
	{
		// This test verifies that TryGetObservablePropertyType can detect ObservableProperty fields
		var source = """
			using System.Collections.ObjectModel;

			namespace CommunityToolkit.Mvvm.ComponentModel
			{
				[System.AttributeUsage(System.AttributeTargets.Field)]
				public class ObservablePropertyAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.ComponentModel.ObservableProperty]
					private string? name;
				}
			}
			""";

		// Create a compilation to test the extension method directly
		var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("test")
			.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source))
			.AddReferences(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));

		var myViewModelType = compilation.GetTypeByMetadataName("TestApp.MyViewModel");
		Assert.NotNull(myViewModelType);

		// Test that TryGetObservablePropertyType can detect the Name property from name field
		var canInfer = myViewModelType.TryGetObservablePropertyType("Name", compilation, out var propertyType);

		Assert.True(canInfer, "Should be able to infer Name from name field with [ObservableProperty]");
		Assert.NotNull(propertyType);
		Assert.Equal("string?", propertyType!.ToDisplayString());
	}

	[Fact]
	public void DetectsObservablePropertyFromUnderscorePrefixedField()
	{
		var source = """
			using System.Collections.ObjectModel;

			namespace CommunityToolkit.Mvvm.ComponentModel
			{
				[System.AttributeUsage(System.AttributeTargets.Field)]
				public class ObservablePropertyAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.ComponentModel.ObservableProperty]
					private int _count;
				}
			}
			""";

		var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("test")
			.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source))
			.AddReferences(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));

		var myViewModelType = compilation.GetTypeByMetadataName("TestApp.MyViewModel");
		Assert.NotNull(myViewModelType);

		// Test that TryGetObservablePropertyType can detect the Count property from _count field
		var canInfer = myViewModelType.TryGetObservablePropertyType("Count", compilation, out var propertyType);

		Assert.True(canInfer, "Should be able to infer Count from _count field with [ObservableProperty]");
		Assert.NotNull(propertyType);
		Assert.Equal("int", propertyType!.ToDisplayString());
	}

	[Fact]
	public void DoesNotDetectPropertyWithoutAttribute()
	{
		var source = """
			namespace TestApp
			{
				public class MyViewModel
				{
					// No [ObservableProperty] attribute
					private string? name;
				}
			}
			""";

		var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("test")
			.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source))
			.AddReferences(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));

		var myViewModelType = compilation.GetTypeByMetadataName("TestApp.MyViewModel");
		Assert.NotNull(myViewModelType);

		// Should not infer Name without [ObservableProperty] attribute
		var canInfer = myViewModelType.TryGetObservablePropertyType("Name", compilation, out var propertyType);

		Assert.False(canInfer, "Should not infer Name without [ObservableProperty] attribute");
		Assert.Null(propertyType);
	}

	[Fact]
	public void DetectsObservablePropertyWithShortAttributeName()
	{
		// Test that we can detect the attribute even with short name (without "Attribute" suffix)
		var source = """
			using System.Collections.ObjectModel;

			namespace CommunityToolkit.Mvvm.ComponentModel
			{
				[System.AttributeUsage(System.AttributeTargets.Field)]
				public class ObservablePropertyAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.ComponentModel.ObservableProperty]
					private bool _isActive;
				}
			}
			""";

		var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("test")
			.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source))
			.AddReferences(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));

		var myViewModelType = compilation.GetTypeByMetadataName("TestApp.MyViewModel");
		Assert.NotNull(myViewModelType);

		var canInfer = myViewModelType.TryGetObservablePropertyType("IsActive", compilation, out var propertyType);

		Assert.True(canInfer, "Should be able to infer IsActive from _isActive field");
		Assert.NotNull(propertyType);
		Assert.Equal("bool", propertyType!.ToDisplayString());
	}
}
