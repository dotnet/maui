using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.Maui.Controls.BindingSourceGen;
using Xunit;

namespace BindingSourceGen.UnitTests;

public class RelayCommandTests
{
	// Note: C# lambda bindings (SetBinding with static lambda expressions) cannot work with
	// source-generated properties like those from [RelayCommand] because the semantic model
	// needs to resolve the lambda return type before source generators run.
	// 
	// The RelayCommand support is primarily for XAML string-based bindings which use
	// CompiledBindingMarkup.cs and the TryGetProperty extension method.
	//
	// These tests verify the behavior and document the limitation.

	[Fact]
	public void RelayCommandPropertyNotResolvedInLambdaBinding()
	{
		// This test documents that C# lambda bindings don't work with source-generated properties
		var source = """
			using Microsoft.Maui.Controls;
			using System.Threading.Tasks;

			namespace System.Windows.Input
			{
				public interface ICommand
				{
					event System.EventHandler CanExecuteChanged;
					bool CanExecute(object parameter);
					void Execute(object parameter);
				}
			}

			namespace CommunityToolkit.Mvvm.Input
			{
				[System.AttributeUsage(System.AttributeTargets.Method)]
				public class RelayCommandAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.Input.RelayCommand]
					private void Save()
					{
						// SaveCommand property will be generated by CommunityToolkit.Mvvm
					}
				}

				public class TestCode
				{
					public void Test()
					{
						var button = new Button();
						// This won't work because the semantic model can't see SaveCommand
						button.SetBinding(Button.CommandProperty, static (MyViewModel vm) => vm.SaveCommand);
					}
				}
			}
			""";

		var result = SourceGenHelpers.Run(source);
		
		// The binding cannot be generated because the semantic model can't resolve SaveCommand
		// before source generators run
		Assert.Null(result.Binding);
		
		// Should have the "lambda result type cannot be resolved" error
		var hasUnresolvableError = result.SourceGeneratorDiagnostics.Any(d => d.Id == "BSG0006");
		Assert.True(hasUnresolvableError, "Should have BSG0006 error when property is not in semantic model");
	}

	[Fact]
	public void DetectsRelayCommandMethod()
	{
		// This test verifies that TryGetRelayCommandPropertyType can detect RelayCommand methods
		var source = """
			using Microsoft.CodeAnalysis;
			using Microsoft.CodeAnalysis.CSharp;
			using System.Linq;

			namespace System.Windows.Input
			{
				public interface ICommand
				{
					event System.EventHandler CanExecuteChanged;
					bool CanExecute(object parameter);
					void Execute(object parameter);
				}
			}

			namespace CommunityToolkit.Mvvm.Input
			{
				[System.AttributeUsage(System.AttributeTargets.Method)]
				public class RelayCommandAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.Input.RelayCommand]
					private void Save()
					{
					}
				}
			}
			""";

		// Create a compilation to test the extension method directly
		var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("test")
			.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source))
			.AddReferences(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));

		var myViewModelType = compilation.GetTypeByMetadataName("TestApp.MyViewModel");
		Assert.NotNull(myViewModelType);

		// Test that TryGetRelayCommandPropertyType can detect the SaveCommand property
		var canInfer = myViewModelType.TryGetRelayCommandPropertyType("SaveCommand", compilation, out var commandType);
		
		Assert.True(canInfer, "Should be able to infer SaveCommand from Save method with [RelayCommand]");
		Assert.NotNull(commandType);
		Assert.Equal("System.Windows.Input.ICommand", commandType!.ToDisplayString());
	}

	[Fact]
	public void DoesNotDetectCommandPropertyWithoutAttribute()
	{
		var source = """
			using Microsoft.CodeAnalysis;
			using Microsoft.CodeAnalysis.CSharp;
			using System.Linq;

			namespace TestApp
			{
				public class MyViewModel
				{
					// No [RelayCommand] attribute
					private void Save()
					{
					}
				}
			}
			""";

		var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("test")
			.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source))
			.AddReferences(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));

		var myViewModelType = compilation.GetTypeByMetadataName("TestApp.MyViewModel");
		Assert.NotNull(myViewModelType);

		// Should not infer SaveCommand without [RelayCommand] attribute
		var canInfer = myViewModelType.TryGetRelayCommandPropertyType("SaveCommand", compilation, out var commandType);
		
		Assert.False(canInfer, "Should not infer SaveCommand without [RelayCommand] attribute");
		Assert.Null(commandType);
	}
}
