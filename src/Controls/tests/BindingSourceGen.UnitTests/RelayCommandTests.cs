using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.Maui.Controls.BindingSourceGen;
using Xunit;

namespace BindingSourceGen.UnitTests;

public class RelayCommandTests
{
	// Note: Expression-based bindings work with RelayCommand through type inference in
	// GetLambdaReturnType. The generated interceptor code will be correct. In tests,
	// we'll see compilation errors because the actual SaveCommand property doesn't exist
	// (CommunityToolkit.Mvvm's source generator isn't running in the test environment),
	// but the interceptor code itself is generated correctly.

	[Fact]
	public void GenerateBindingToRelayCommandProperty()
	{
		var source = """
			using Microsoft.Maui.Controls;
			using System.Threading.Tasks;

			namespace System.Windows.Input
			{
				public interface ICommand
				{
					event System.EventHandler CanExecuteChanged;
					bool CanExecute(object parameter);
					void Execute(object parameter);
				}
			}

			namespace CommunityToolkit.Mvvm.Input
			{
				[System.AttributeUsage(System.AttributeTargets.Method)]
				public class RelayCommandAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.Input.RelayCommand]
					private void Save()
					{
						// SaveCommand property will be generated by CommunityToolkit.Mvvm
					}
				}

				public class TestCode
				{
					public void Test()
					{
						var button = new Button();
						button.SetBinding(Button.CommandProperty, static (MyViewModel vm) => vm.SaveCommand);
					}
				}
			}
			""";

		var result = SourceGenHelpers.Run(source);
		
		// The binding should be generated successfully with RelayCommand inference
		Assert.NotNull(result.Binding);
		
		// Verify the generated interceptor code contains the SaveCommand property access
		var allGeneratedCode = string.Join("\n\n", result.GeneratedFiles.Values);
		Assert.Contains("SaveCommand", allGeneratedCode, System.StringComparison.Ordinal);
		
		// Note: There will be compilation errors because SaveCommand doesn't actually exist,
		// but the interceptor code itself is generated correctly. In real usage with
		// CommunityToolkit.Mvvm, the property would exist and compile successfully.
	}

	[Fact]
	public void DetectsRelayCommandMethod()
	{
		// This test verifies that TryGetRelayCommandPropertyType can detect RelayCommand methods
		var source = """
			using Microsoft.CodeAnalysis;
			using Microsoft.CodeAnalysis.CSharp;
			using System.Linq;

			namespace System.Windows.Input
			{
				public interface ICommand
				{
					event System.EventHandler CanExecuteChanged;
					bool CanExecute(object parameter);
					void Execute(object parameter);
				}
			}

			namespace CommunityToolkit.Mvvm.Input
			{
				[System.AttributeUsage(System.AttributeTargets.Method)]
				public class RelayCommandAttribute : System.Attribute { }
			}

			namespace TestApp
			{
				public class MyViewModel
				{
					[CommunityToolkit.Mvvm.Input.RelayCommand]
					private void Save()
					{
					}
				}
			}
			""";

		// Create a compilation to test the extension method directly
		var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("test")
			.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source))
			.AddReferences(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));

		var myViewModelType = compilation.GetTypeByMetadataName("TestApp.MyViewModel");
		Assert.NotNull(myViewModelType);

		// Test that TryGetRelayCommandPropertyType can detect the SaveCommand property
		var canInfer = myViewModelType.TryGetRelayCommandPropertyType("SaveCommand", compilation, out var commandType);
		
		Assert.True(canInfer, "Should be able to infer SaveCommand from Save method with [RelayCommand]");
		Assert.NotNull(commandType);
		Assert.Equal("System.Windows.Input.ICommand", commandType!.ToDisplayString());
	}

	[Fact]
	public void DoesNotDetectCommandPropertyWithoutAttribute()
	{
		var source = """
			using Microsoft.CodeAnalysis;
			using Microsoft.CodeAnalysis.CSharp;
			using System.Linq;

			namespace TestApp
			{
				public class MyViewModel
				{
					// No [RelayCommand] attribute
					private void Save()
					{
					}
				}
			}
			""";

		var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("test")
			.AddSyntaxTrees(CSharpSyntaxTree.ParseText(source))
			.AddReferences(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));

		var myViewModelType = compilation.GetTypeByMetadataName("TestApp.MyViewModel");
		Assert.NotNull(myViewModelType);

		// Should not infer SaveCommand without [RelayCommand] attribute
		var canInfer = myViewModelType.TryGetRelayCommandPropertyType("SaveCommand", compilation, out var commandType);
		
		Assert.False(canInfer, "Should not infer SaveCommand without [RelayCommand] attribute");
		Assert.Null(commandType);
	}
}
