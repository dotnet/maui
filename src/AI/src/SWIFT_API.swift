import BackgroundAssets
import CoreGraphics
import Foundation
import Observation

/// A type that can be initialized from generated content.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol ConvertibleFromGeneratedContent : SendableMetatype {

    /// Creates an instance from content generated by a model.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. To manually initialize your type from generated content,
    /// decode the values as shown below:
    ///
    /// ```swift
    /// struct Person: ConvertibleFromGeneratedContent {
    ///     var name: String
    ///     var age: Int
    ///
    ///     init(_ content: GeneratedContent) {
    ///         self.name = try content.value(forProperty: "firstName")
    ///         self.age = try content.value(forProperty: "ageInYears")
    ///     }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleToGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleToGeneratedContent/generatedContent``.
    ///
    /// - SeeAlso: `@Generable` macro ``Generable(description:)``
    init(_ content: GeneratedContent) throws
}

/// A type that can be converted to generated content.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol ConvertibleToGeneratedContent : InstructionsRepresentable, PromptRepresentable {

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension ConvertibleToGeneratedContent {

    /// An instance that represents the instructions.
    public var instructionsRepresentation: Instructions { get }

    /// An instance that represents a prompt.
    public var promptRepresentation: Prompt { get }
}

/// The dynamic counterpart to the generation schema type that you use to construct schemas at runtime.
///
/// An individual schema may reference other schemas by
/// name, and references are resolved when converting a set of
/// dynamic schemas into a ``GenerationSchema``.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct DynamicGenerationSchema : Sendable {

    /// Creates an object schema.
    ///
    /// - Parameters:
    ///   - name: A name this dynamic schema can be referenced by.
    ///   - description: A natural language description of this schema.
    ///   - properties: The properties to associated with this schema.
    public init(name: String, description: String? = nil, properties: [DynamicGenerationSchema.Property])

    /// Creates an any-of schema.
    ///
    /// - Parameters:
    ///   - name: A name this schema can be referenecd by.
    ///   - description: A natural language description of this ``DynamicGenerationSchema``.
    ///   - choices: An array of schemas this one will be a union of.
    public init(name: String, description: String? = nil, anyOf choices: [DynamicGenerationSchema])

    /// Creates an enum schema.
    ///
    /// - Parameters:
    ///   - name: A name this schema can be referenced by.
    ///   - description: A natural language description of this ``DynamicGenerationSchema``.
    ///   - choices: An array of schemas this one will be a union of.
    public init(name: String, description: String? = nil, anyOf choices: [String])

    /// Creates an array schema.
    ///
    /// - Parameters:
    ///   - arrayOf: A schema to use as the elements of the array.
    public init(arrayOf itemSchema: DynamicGenerationSchema, minimumElements: Int? = nil, maximumElements: Int? = nil)

    /// Creates a schema from a generable type and guides.
    ///
    /// - Parameters:
    ///   - type: A `Generable` type
    ///   - guides: Generation guides to apply to this `DynamicGenerationSchema`.
    public init<Value>(type: Value.Type, guides: [GenerationGuide<Value>] = []) where Value : Generable

    /// Creates an refrence schema.
    ///
    /// - Parameters:
    ///   - name: The name of the ``DynamicGenerationSchema`` this is a reference to.
    public init(referenceTo name: String)

    /// A property that belongs to a dynamic generation schema.
    ///
    /// Fields are named members of object types. Fields are strongly
    /// typed and have optional descriptions.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Property {

        /// Creates a property referencing a dynamic schema.
        ///
        /// - Parameters:
        ///   - name: A name for this property.
        ///   - description: An optional natural language description of this
        ///     property's contents.
        ///   - schema: A schema representing the type this property contains.
        ///   - isOptional: Determines if this property is required or not.
        public init(name: String, description: String? = nil, schema: DynamicGenerationSchema, isOptional: Bool = false)
    }
}

/// A type that the model uses when responding to prompts.
///
/// Annotate your Swift structure or enumeration with the `@Generable` macro to allow the model to
/// respond to prompts by generating an instance of your type. Use the `@Guide` macro to provide natural
/// language descriptions of your properties, and programmatically control the values that the model can
/// generate.
///
/// ```swift
/// @Generable
/// struct SearchSuggestions {
///     @Guide(description: "A list of suggested search terms", .count(4))
///     var searchTerms: [SearchTerm]
///
///     @Generable
///     struct SearchTerm {
///         // Use a generation identifier for data structures the framework generates.
///         var id: GenerationID
///
///         @Guide(description: "A 2 or 3 word search term, like 'Beautiful sunsets'")
///         var searchTerm: String
///     }
/// }
/// ```
/// - SeeAlso: `@Generable` macro ``Generable(description:)`` and  `@Guide` macro
/// ``Guide(description:)``.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol Generable : ConvertibleFromGeneratedContent, ConvertibleToGeneratedContent {

    /// A representation of partially generated content
    associatedtype PartiallyGenerated : ConvertibleFromGeneratedContent = Self

    /// An instance of the generation schema.
    static var generationSchema: GenerationSchema { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Generable {

    /// The partially generated type of this struct.
    public func asPartiallyGenerated() -> Self.PartiallyGenerated
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Generable {

    /// A representation of partially generated content
    public typealias PartiallyGenerated = Self
}

/// Conforms a type to ``Generable`` protocol.
///
/// You can apply this macro to structures and enumerations.
///
/// ```swift
/// @Generable
/// struct NovelIdea {
///   @Guide(description: "A short title")
///   let title: String
///
///   @Guide(description: "A short subtitle for the novel")
///   let subtitle: String
///
///   @Guide(description: "The genre of the novel")
///   let genre: Genre
/// }
///
/// @Generable
/// enum Genre {
///   case fiction
///   case nonFiction
/// }
/// ```
/// - SeeAlso: @Guide macro ``Guide(description:)``
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@attached(extension, conformances: Generable, names: named(init(_:)), named(generatedContent)) @attached(member, names: arbitrary) public macro Generable(description: String? = nil) = #externalMacro(module: "FoundationModelsMacros", type: "GenerableMacro")

/// A type that represents structured, generated content.
///
/// Generated content may contain a single value, an array, or key-value pairs with unique keys.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GeneratedContent : Sendable, Equatable, Generable, CustomDebugStringConvertible {

    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema { get }

    /// A unique id that is stable for the duration of a generated response.
    ///
    /// A ``LanguageModelSession`` produces instances of ``GeneratedContent`` that have a
    /// non-nil `id`. When you stream a response, the `id` is the same for all partial generations in the
    /// response stream.
    ///
    /// Instances of ``GeneratedContent`` that you produce manually with initializers have a nil `id`
    /// because the framework didn't create them as part of a generation.
    public var id: GenerationID?

    /// Creates generated content from another value.
    ///
    /// This is used to satisfy `Generable.init(_:)`.
    public init(_ content: GeneratedContent) throws

    /// A representation of this instance.
    public var generatedContent: GeneratedContent { get }

    /// Creates generated content representing a structure with the properties you specify.
    ///
    /// The order of properties is important. For ``Generable`` types, the order
    /// must match the order properties in the types `schema`.
    public init(properties: KeyValuePairs<String, any ConvertibleToGeneratedContent>, id: GenerationID? = nil)

    /// Creates new generated content from the key-value pairs in the given sequence,
    /// using a combining closure to determine the value for any duplicate keys.
    ///
    /// The order of properties is important. For ``Generable`` types, the order
    /// must match the order properties in the types `schema`.
    ///
    /// You use this initializer to create generated content when you have a sequence
    /// of key-value tuples that might have duplicate keys. As the content is
    /// built, the initializer calls the `combine` closure with the current and
    /// new values for any duplicate keys. Pass a closure as `combine` that
    /// returns the value to use in the resulting content: The closure can
    /// choose between the two values, combine them to produce a new value, or
    /// even throw an error.
    ///
    /// The following example shows how to choose the first and last values for
    /// any duplicate keys:
    ///
    /// ```swift
    ///     let content = GeneratedContent(
    ///       properties: [("name", "John"), ("name", "Jane"), ("married", true)],
    ///       uniquingKeysWith: { (first, _) in first }
    ///     )
    ///     // GeneratedContent(["name": "John", "married": true])
    /// ```
    ///
    /// - Parameters:
    ///   - properties: A sequence of key-value pairs to use for the new content.
    ///   - id: A unique id associated with ``GeneratedContent``.
    ///   - combine: A closure that is called with the values to resolve any duplicates
    ///     keys that are encountered. The closure returns the desired value for the final content.
    public init<S>(properties: S, id: GenerationID? = nil, uniquingKeysWith combine: (GeneratedContent, GeneratedContent) throws -> some ConvertibleToGeneratedContent) rethrows where S : Sequence, S.Element == (String, any ConvertibleToGeneratedContent)

    /// Creates content representing an array of elements you specify.
    public init<S>(elements: S, id: GenerationID? = nil) where S : Sequence, S.Element == any ConvertibleToGeneratedContent

    /// Creates content that contains a single value.
    ///
    /// - Parameters:
    ///   - value: The underlying value.
    public init(_ value: some ConvertibleToGeneratedContent)

    /// Creates content that contains a single value with a custom `GenerationID`.
    ///
    /// - Parameters:
    ///   - value: The underlying value.
    ///   - id: The ``GenerationID`` for this content.
    public init(_ value: some ConvertibleToGeneratedContent, id: GenerationID)

    /// Creates equivalent content from a JSON string.
    ///
    /// The JSON string you provide may be incomplete. This is useful for correctly handling partially generated responses.
    ///
    /// ```swift
    /// @Generable struct NovelIdea {
    ///   let title: String
    /// }
    ///
    /// let partial = #"{"title": "A story of"#
    /// let content = try GeneratedContent(json: partial)
    /// let idea = try NovelIdea(content)
    /// print(idea.title) // A story of
    /// ```
    public init(json: String) throws

    /// Returns a JSON string representation of the generated content.
    ///
    /// ## Examples
    ///
    /// ```swift
    /// // Object with properties
    /// let content = GeneratedContent(properties: [
    ///     "name": "Johnny Appleseed",
    ///     "age": 30,
    /// ])
    /// print(content.jsonString)
    /// // Output: {"name": "Johnny Appleseed", "age": 30}
    /// ```
    public var jsonString: String { get }

    /// Reads a top level, concrete partially `Generable` type from a named property.
    public func value<Value>(_ type: Value.Type = Value.self) throws -> Value where Value : ConvertibleFromGeneratedContent

    /// Reads a concrete `Generable` type from named property.
    public func value<Value>(_ type: Value.Type = Value.self, forProperty property: String) throws -> Value where Value : ConvertibleFromGeneratedContent

    /// Reads an optional, concrete generable type from named property.
    public func value<Value>(_ type: Value?.Type = Value?.self, forProperty property: String) throws -> Value? where Value : ConvertibleFromGeneratedContent

    /// A string representation for the debug description.
    public var debugDescription: String { get }

    /// A Boolean that indicates whether the generated content is completed.
    public var isComplete: Bool { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: GeneratedContent, b: GeneratedContent) -> Bool
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GeneratedContent {

    /// A representation of the different types of content that can be stored in `GeneratedContent`.
    ///
    /// `Kind` represents the various types of JSON-compatible data that can be held within 
    /// a ``GeneratedContent`` instance, including primitive types, arrays, and structured objects.
    public enum Kind : Equatable, Sendable {

        /// Represents a null value.
        case null

        /// Represents a boolean value.
        /// - Parameter value: The boolean value.
        case bool(Bool)

        /// Represents a numeric value.
        /// - Parameter value: The numeric value as a Double.
        case number(Double)

        /// Represents a string value.
        /// - Parameter value: The string value.
        case string(String)

        /// Represents an array of `GeneratedContent` elements.
        /// - Parameter elements: An array of ``GeneratedContent`` instances.
        case array([GeneratedContent])

        /// Represents a structured object with key-value pairs.
        /// - Parameters:
        ///   - properties: A dictionary mapping string keys to ``GeneratedContent`` values.
        ///   - orderedKeys: An array of keys that specifies the order of properties.
        case structure(properties: [String : GeneratedContent], orderedKeys: [String])

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: GeneratedContent.Kind, b: GeneratedContent.Kind) -> Bool
    }

    /// Creates a new `GeneratedContent` instance with the specified kind and `GenerationID`.
    ///
    /// This initializer provides a convenient way to create content from its kind representation.
    ///
    /// - Parameters:
    ///   - kind: The kind of content to create.
    ///   - id: An optional ``GenerationID`` to associate with this content.
    public init(kind: GeneratedContent.Kind, id: GenerationID? = nil)

    /// The kind representation of this generated content.
    ///
    /// This property provides access to the content in a strongly-typed enum representation,
    /// preserving the hierarchical structure of the data and the  data's ``GenerationID`` ids.
    public var kind: GeneratedContent.Kind { get }
}

/// Guides that control how values are generated.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GenerationGuide<Value> {
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GenerationGuide where Value == String {

    /// Enforces that the string be precisely the given value.
    public static func constant(_ value: String) -> GenerationGuide<String>

    /// Enforces that the string be one of the provided values.
    public static func anyOf(_ values: [String]) -> GenerationGuide<String>

    /// Enforces that the string follows the pattern.
    public static func pattern<Output>(_ regex: Regex<Output>) -> GenerationGuide<String>
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GenerationGuide where Value == Int {

    /// Enforces a minimum value.
    ///
    /// Use a `minimum` generation guide --- whose bounds are inclusive --- to ensure the model produces
    /// a value greater than or equal to some minimum value. For example, you can specify that all characters
    /// in your game start at level 1:
    ///
    /// ```swift
    /// @Generable
    /// struct struct GameCharacter {
    ///     @Guide(description: "A creative name appropriate for a fantasy RPG character")
    ///     var name: String
    ///
    ///     @Guide(description: "A level for the character", .minimum(1))
    ///     var level: Int
    /// }
    /// ```
    public static func minimum(_ value: Int) -> GenerationGuide<Int>

    /// Enforces a maximum value.
    ///
    /// Use a `maximum` generation guide --- whose bounds are inclusive --- to ensure the model produces
    /// a value less than or equal to some maximum value. For example, you can specify that the highest level
    /// a character in your game can achieve is 100:
    ///
    /// ```swift
    /// @Generable
    /// struct struct GameCharacter {
    ///     @Guide(description: "A creative name appropriate for a fantasy RPG character")
    ///     var name: String
    ///
    ///     @Guide(description: "A level for the character", .maximum(100))
    ///     var level: Int
    /// }
    /// ```
    public static func maximum(_ value: Int) -> GenerationGuide<Int>

    /// Enforces values fall within a range.
    ///
    /// Use a `range` generation guide --- whose bounds are inclusive --- to ensure the model produces a
    /// value that falls within a range. For example, you can specify that the level of characters in your game
    /// are between 1 and 100:
    ///
    /// ```swift
    /// @Generable
    /// struct struct GameCharacter {
    ///     @Guide(description: "A creative name appropriate for a fantasy RPG character")
    ///     var name: String
    ///
    ///     @Guide(description: "A level for the character", .range(1...100))
    ///     var level: Int
    /// }
    /// ```
    public static func range(_ range: ClosedRange<Int>) -> GenerationGuide<Int>
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GenerationGuide where Value == Float {

    /// Enforces a minimum value.
    ///
    /// Use a `minimum` generation guide --- whose bounds are inclusive --- to ensure the model produces
    /// a value greater than or equal to some minimum value. For example, you can specify that all characters
    /// in your game start at level 1.0:
    ///
    /// ```swift
    /// @Generable
    /// struct struct GameCharacter {
    ///     @Guide(description: "A creative name appropriate for a fantasy RPG character")
    ///     var name: String
    ///
    ///     @Guide(description: "A level for the character", .minimum(1.0))
    ///     var level: Float
    /// }
    /// ```
    public static func minimum(_ value: Float) -> GenerationGuide<Float>

    /// Enforces a maximum value.
    ///
    /// Use a `maximum` generation guide --- whose bounds are inclusive --- to ensure the model produces
    /// a value less than or equal to some maximum value. For example, you can specify that the highest level
    /// a character in your game can achieve is 100.0:
    ///
    /// ```swift
    /// @Generable
    /// struct struct GameCharacter {
    ///     @Guide(description: "A creative name appropriate for a fantasy RPG character")
    ///     var name: String
    ///
    ///     @Guide(description: "A level for the character", .maximum(100.0))
    ///     var level: Float
    /// }
    /// ```
    public static func maximum(_ value: Float) -> GenerationGuide<Float>

    /// Enforces values fall within a range.
    ///
    /// Bounds are inclusive.
    ///
    /// A `range` generation guide may be used when you want to ensure the model
    /// produces a value that falls in some range, such as the cost for an item
    /// in a game.
    ///
    /// ```swift
    /// @Generable
    /// struct struct ShopItem {
    ///     @Guide(description: "A creative name for an item sold in a fantasy RPG"
    ///     var name: String
    ///
    ///     @Guide(description: "A cost for the item", .range(1...1000))
    ///     var cost: Float
    /// }
    /// ```
    public static func range(_ range: ClosedRange<Float>) -> GenerationGuide<Float>
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GenerationGuide where Value == Decimal {

    /// Enforces a minimum value.
    ///
    /// Use a `minimum` generation guide --- whose bounds are inclusive --- to ensure the model produces
    /// a value greater than or equal to some minimum value. For example, you can specify that all characters
    /// in your game start at level 0.75:
    ///
    /// ```swift
    /// @Generable
    /// struct struct GameCharacter {
    ///     @Guide(description: "A creative name appropriate for a fantasy RPG character")
    ///     var name: String
    ///
    ///     @Guide(description: "A level for the character", .minimum(0.75))
    ///     var level: Decimal
    /// }
    /// ```
    public static func minimum(_ value: Decimal) -> GenerationGuide<Decimal>

    /// Enforces a maximum value.
    ///
    /// Use a `maximum` generation guide --- whose bounds are inclusive --- to ensure the model produces
    /// a value less than or equal to some maximum value. For example, you can specify that the highest level
    /// a character in your game can achieve is 99.9:
    ///
    /// ```swift
    /// @Generable
    /// struct struct GameCharacter {
    ///     @Guide(description: "A creative name appropriate for a fantasy RPG character")
    ///     var name: String
    ///
    ///     @Guide(description: "A level for the character", .maximum(99.9))
    ///     var level: Decimal
    /// }
    /// ```
    public static func maximum(_ value: Decimal) -> GenerationGuide<Decimal>

    /// Enforces values fall within a range.
    ///
    /// Bounds are inclusive.
    ///
    /// A `range` generation guide may be used when you want to ensure the model
    /// produces a value that falls in some range, such as the cost for an item
    /// in a game.
    ///
    /// ```swift
    /// @Generable
    /// struct struct ShopItem {
    ///     @Guide(description: "A creative name for an item sold in a fantasy RPG"
    ///     var name: String
    ///
    ///     @Guide(description: "A cost for the item", .range(0.25...1000))
    ///     var cost: Decimal
    /// }
    /// ```
    public static func range(_ range: ClosedRange<Decimal>) -> GenerationGuide<Decimal>
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GenerationGuide where Value == Double {

    /// Enforces a minimum value.
    ///
    /// Use a `minimum` generation guide --- whose bounds are inclusive --- to ensure the model produces
    /// a value greater than or equal to some minimum value. For example, you can specify that all characters
    /// in your game start at level 1.0:
    ///
    /// ```swift
    /// @Generable
    /// struct struct GameCharacter {
    ///     @Guide(description: "A creative name appropriate for a fantasy RPG character")
    ///     var name: String
    ///
    ///     @Guide(description: "A level for the character", .minimum(1.0))
    ///     var level: Double
    /// }
    /// ```
    public static func minimum(_ value: Double) -> GenerationGuide<Double>

    /// Enforces a maximum value.
    ///
    /// Use a `maximum` generation guide --- whose bounds are inclusive --- to ensure the model produces
    /// a value less than or equal to some maximum value. For example, you can specify that the highest level
    /// a character in your game can achieve is 5000.0:
    ///
    /// ```swift
    /// @Generable
    /// struct struct GameCharacter {
    ///     @Guide(description: "A creative name appropriate for a fantasy RPG character")
    ///     var name: String
    ///
    ///     @Guide(description: "A level for the character", .maximum(5000.0))
    ///     var level: Double
    /// }
    /// ```
    public static func maximum(_ value: Double) -> GenerationGuide<Double>

    /// Enforces values fall within a range.
    ///
    /// Bounds are inclusive.
    ///
    /// A `range` generation guide may be used when you want to ensure the model
    /// produces a value that falls in some range, such as the cost for an item
    /// in a game.
    ///
    /// ```swift
    /// @Generable
    /// struct struct ShopItem {
    ///     @Guide(description: "A creative name for an item sold in a fantasy RPG"
    ///     var name: String
    ///
    ///     @Guide(description: "A cost for the item", .range(1...1000))
    ///     var cost: Double
    /// }
    /// ```
    public static func range(_ range: ClosedRange<Double>) -> GenerationGuide<Double>
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GenerationGuide {

    /// Enforces a minimum number of elements in the array.
    ///
    /// The bounds are inclusive.
    ///
    /// A `minimumCount` generation guide may be used when you want to ensure the
    /// model produces a number of array elements greater than or equal to to some
    /// minimum value, such as the number of items in a game's shop.
    ///
    /// ```swift
    /// @Generable
    /// struct struct Shop {
    ///     @Guide(description: "A creative name for a shop in a fantasy RPG"
    ///     var name: String
    ///
    ///     @Guide(description: "A list of items for sale", .minimumCount(3))
    ///     var inventory: [ShopItem]
    /// }
    /// ```
    public static func minimumCount<Element>(_ count: Int) -> GenerationGuide<[Element]> where Value == [Element]

    /// Enforces a maximum number of elements in the array.
    ///
    /// The bounds are inclusive.
    ///
    /// A `maximumCount` generation guide may be used when you want to ensure the
    /// model produces a number of array elements less than or equal to to some
    /// maximum value, such as the number of items in a game's shop.
    ///
    /// ```swift
    /// @Generable
    /// struct struct Shop {
    ///     @Guide(description: "A creative name for a shop in a fantasy RPG"
    ///     var name: String
    ///
    ///     @Guide(description: "A list of items for sale", .maximumCount(10))
    ///     var inventory: [ShopItem]
    /// }
    /// ```
    public static func maximumCount<Element>(_ count: Int) -> GenerationGuide<[Element]> where Value == [Element]

    /// Enforces that the number of elements in the array fall within a closed range.
    ///
    /// Bounds are inclusive.
    ///
    /// A `count` generation guide may be used when you want to ensure the
    /// model produces a number of array elements that falls within a given range,
    /// such as the number of items in a game's shop.
    ///
    /// ```swift
    /// @Generable
    /// struct struct Shop {
    ///     @Guide(description: "A creative name for a shop in a fantasy RPG"
    ///     var name: String
    ///
    ///     @Guide(description: "A list of items for sale", .count(2...10))
    ///     var inventory: [ShopItem]
    /// }
    /// ```
    public static func count<Element>(_ range: ClosedRange<Int>) -> GenerationGuide<[Element]> where Value == [Element]

    /// Enforces that the array has exactly a certain number elements.
    ///
    /// A `count` generation guide may be used when you want to ensure the
    /// model produces exactly a certain number array elements, such as the
    /// number of items in a game's shop.
    ///
    /// ```swift
    /// @Generable
    /// struct struct Shop {
    ///     @Guide(description: "A creative name for a shop in a fantasy RPG"
    ///     var name: String
    ///
    ///     @Guide(description: "A list of items for sale", .count(3))
    ///     var inventory: [ShopItem]
    /// }
    /// ```
    public static func count<Element>(_ count: Int) -> GenerationGuide<[Element]> where Value == [Element]

    /// Enforces a guide on the elements within the array.
    ///
    /// An `element` generation guide may be used when you want to apply guides to
    /// the values a model produces within an array. For example, you may want to
    /// generate an array of integers, where all the integers are in the range 0-9.
    ///
    /// ```swift
    /// @Generable
    /// struct struct FortuneCookie {
    ///     @Guide(description: "A fortune from a fortune cookie"
    ///     var name: String
    ///
    ///     @Guide(description: "A list lucky numbers", .element(.range(0...9)), .count(4))
    ///     var luckyNumbers: [Int]
    /// }
    /// ```
    public static func element<Element>(_ guide: GenerationGuide<Element>) -> GenerationGuide<[Element]> where Value == [Element]
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension GenerationGuide where Value == [Never] {

    /// Enforces a minimum number of elements in the array.
    ///
    /// Bounds are inclusive.
    ///
    /// - Warning: This overload is only used for macro expansion. Don't call `GenerationGuide<[Never]>.minimumCount(_:)` on your own.
    public static func minimumCount(_ count: Int) -> GenerationGuide<Value>

    /// Enforces a maximum number of elements in the array.
    ///
    /// Bounds are inclusive.
    ///
    /// - Warning: This overload is only used for macro expansion. Don't call `GenerationGuide<[Never]>.maximumCount(_:)` on your own.
    public static func maximumCount(_ count: Int) -> GenerationGuide<Value>

    /// Enforces that the number of elements in the array fall within a closed range.
    ///
    /// - Warning: This overload is only used for macro expansion. Don't call `GenerationGuide<[Never]>.count(_:)` on your own.
    public static func count(_ range: ClosedRange<Int>) -> GenerationGuide<Value>

    /// Enforces that the array has exactly a certain number elements.
    ///
    /// - Warning: This overload is only used for macro expansion. Don't call `GenerationGuide<[Never]>.count(_:)` on your own.
    public static func count(_ count: Int) -> GenerationGuide<Value>
}

/// A unique identifier that is stable for the duration of a response, but not across responses.
///
/// The framework guarantees a `GenerationID` to be both present and stable when you
/// receive it from a ``LanguageModelSession``. When you create an instance of
/// `GenerationID` there is no guarantee an identifier is present or stable.
///
/// ```swift
/// @Generable struct Person: Equatable {
///     var id: GenerationID
///     var name: String
/// }
///
/// struct PeopleView: View {
///     @State private var session = LanguageModelSession()
///     @State private var people = [Person.PartiallyGenerated]()
///
///     var body: some View {
///         // A person's name changes as the response is generated,
///         // and two people can have the same name, so it is not suitable
///         // for use as an id.
///         //
///         // `GenerationID` receives special treatment and is guaranteed
///         // to be both present and stable.
///         List {
///             ForEach(people) { person in
///                 Text("Name: \(person.name)")
///             }
///         }
///         .task {
///             for try! await people in stream.streamResponse(
///                 to: "Who were the first 3 presidents of the US?",
///                 generating: [Person].self
///             ) {
///                 withAnimation {
///                     self.people = people
///                 }
///             }
///         }
///     }
/// }
/// ```
/// - SeeAlso: `@Generable` macro ``Generable(description:)``
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GenerationID : Sendable, Hashable {

    /// Create a new, unique `GenerationID`.
    public init()

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: GenerationID, b: GenerationID) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Options that control how the model generates its response to a prompt.
///
/// Create a ``GenerationOptions`` structure when you want to adjust
/// the way the model chooses output tokens.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GenerationOptions : Sendable, Equatable {

    /// A type that defines how values are sampled from a probability distribution.
    ///
    /// A model builds its response to a prompt in a loop. At each iteration in the
    /// loop the model produces a probability distribution for all the tokens in its
    /// vocabulary. The sampling mode controls how a token is selected from that
    /// distribution.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct SamplingMode : Sendable, Equatable {

        /// A sampling mode that always chooses the most likely token.
        ///
        /// Using this mode will always result in the same output
        /// for a given input. Responses produced with greedy sampling
        /// are statistically likely, but may lack the human-like quality
        /// and variety of other sampling strategies.
        /// - SeeAlso: Sampling modes ``random(top:seed:)`` and ``random(probabilityThreshold:seed:)``
        public static var greedy: GenerationOptions.SamplingMode { get }

        /// A sampling mode that considers a fixed number of high-probability tokens.
        ///
        /// Also known as top-k.
        ///
        /// During the token-selection process, the vocabulary is sorted by probability a
        /// token is selected from among the top K candidates. Smaller values of K will
        /// ensure only the most probable tokens are candidates for selection, resulting
        /// in more deterministic and confident answers. Larger values of K will allow less
        /// probably tokens to be selected, raising non-determinism and creativity.
        ///
        /// - Note: Setting a random seed is not guaranteed to result in fully deterministic
        ///   output. It is best effort.
        ///
        /// - Parameters:
        ///   - k: The number of tokens to consider.
        ///   - seed: An optional random seed used to make output more deterministic.
        /// - SeeAlso: Sampling modes ``greedy`` and ``random(probabilityThreshold:seed:)``
        public static func random(top k: Int, seed: UInt64? = nil) -> GenerationOptions.SamplingMode

        /// A mode that considers a variable number of high-probability tokens
        /// based on the specified threshold.
        ///
        /// Also known as top-p or nucleus sampling.
        ///
        /// With nucleus sampling, tokens are sorted by probability and added to a
        /// pool of candidates until the cumulative probability of the pool exceeds
        /// the specified threshold, and then a token is sampled from the pool.
        ///
        /// Because the number of tokens isn't predetermined, the selection pool size
        /// will be larger when the distribution is flat and smaller when it is spikey.
        /// This variability can lead to a wider variety of options to choose from, and
        /// potentially more creative responses.
        ///
        /// - Note: Setting a random seed is not guaranteed to result in fully deterministic
        ///   output. It is best effort.
        ///
        /// - Parameters:
        ///     - probabilityThreshold: A number between `0.0` and `1.0` that
        ///       increases sampling pool size.
        ///     - seed: An optional random seed used to make output more deterministic.
        /// - SeeAlso: Sampling modes ``greedy`` and ``random(top:seed:)``
        public static func random(probabilityThreshold: Double, seed: UInt64? = nil) -> GenerationOptions.SamplingMode

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: GenerationOptions.SamplingMode, b: GenerationOptions.SamplingMode) -> Bool
    }

    /// A sampling strategy for how the model picks tokens when generating a
    /// response.
    ///
    /// When you execute a prompt on a model, the model produces a probability
    /// for every token in its vocabulary. The sampling strategy controls how
    /// the model narrows down the list of tokens to consider during that process.
    /// A strategy that picks the single most likely token yields a predictable
    /// response every time, but other strategies offer results that often
    /// sound more natural to a person.
    ///
    /// - Note: Leaving the `sampling` nil lets the system choose a
    ///   a reasonable default on your behalf.
    public var sampling: GenerationOptions.SamplingMode?

    /// Temperature influences the confidence of the models response.
    ///
    /// The value of this property must be a number between `0` and `1` inclusive.
    ///
    /// Temperature is an adjustment applied to the probability distribution
    /// prior to sampling. A value of `1` results in no adjustment. Values less
    /// than `1` will make the probability distribution sharper, with already
    /// likely tokens becoming even more likely.
    ///
    /// The net effect is that low temperatures manifest as more stable and
    /// predictable responses, while high temperatures give the model more
    /// creative license.
    ///
    /// - Note: Leaving `temperature` nil lets the system choose a reasonable
    ///   default on your behalf.
    public var temperature: Double?

    /// The maximum number of tokens the model is allowed to produce in its response.
    ///
    /// If the model produce `maximumResponseTokens` before it naturally completes its response,
    /// the response will be terminated early. No error will be thrown. This property
    /// can be used to protect against unexpectedly verbose responses and runaway generations.
    ///
    /// If no value is specified, then the model is allowed to produce the longest answer
    /// its context size supports. If the response exceeds that limit without terminating,
    /// an error will be thrown.
    public var maximumResponseTokens: Int?

    /// Creates generation options that control token sampling behavior.
    ///
    /// - Parameters:
    ///   - sampling: A strategy to use for sampling from a distribution.
    ///   - temperature: Increasing temperature makes it possible for the model to produce less likely
    ///     responses. Must be between `0` and `1`, inclusive.
    ///   - maximumResponseTokens: The maximum number of tokens the model is allowed
    ///     to produce before being artificially halted. Must be positive.
    public init(sampling: GenerationOptions.SamplingMode? = nil, temperature: Double? = nil, maximumResponseTokens: Int? = nil)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: GenerationOptions, b: GenerationOptions) -> Bool
}

/// A type that describes the properties of an object and any guides
/// on their values.
///
/// Generation  schemas guide the output of a ``SystemLanguageModel`` to deterministically
/// ensure the output is in the desired format.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct GenerationSchema : Sendable, Codable, CustomDebugStringConvertible {

    /// A property that belongs to a generation schema.
    ///
    /// Fields are named members of object types. Fields are strongly
    /// typed and have optional descriptions and guides.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Property : Sendable {

        /// Create a property that contains a generable type.
        ///
        /// - Parameters:
        ///   - name: The property's name.
        ///   - description: A natural language description of what content
        ///     should be generated for this property.
        ///   - type: The type this property represents.
        ///   - guides: A list of guides to apply to this property.
        public init<Value>(name: String, description: String? = nil, type: Value.Type, guides: [GenerationGuide<Value>] = []) where Value : Generable

        /// Create an optional property that contains a generable type.
        ///
        /// - Parameters:
        ///   - name: The property's name.
        ///   - description: A natural language description of what content
        ///     should be generated for this property.
        ///   - type: The type this property represents.
        ///   - guides: A list of guides to apply to this property.
        public init<Value>(name: String, description: String? = nil, type: Value?.Type, guides: [GenerationGuide<Value>] = []) where Value : Generable

        /// Create a property that contains a string type.
        ///
        /// - Parameters:
        ///   - name: The property's name.
        ///   - description: A natural language description of what content
        ///     should be generated for this property.
        ///   - type: The type this property represents.
        ///   - guides: An array of regexes to be applied to this string. If there're multiple regexes in the array, only the last one will be applied.
        public init<RegexOutput>(name: String, description: String? = nil, type: String.Type, guides: [Regex<RegexOutput>] = [])

        /// Create an optional property that contains a generable type.
        ///
        /// - Parameters:
        ///   - name: The property's name.
        ///   - description: A natural language description of what content
        ///     should be generated for this property.
        ///   - type: The type this property represents.
        ///   - guides: An array of regexes to be applied to this string. If there're multiple regexes in the array, only the last one will be applied.
        public init<RegexOutput>(name: String, description: String? = nil, type: String?.Type, guides: [Regex<RegexOutput>] = [])
    }

    /// A string representation of the debug description.
    ///
    /// This string is not localized and is not appropriate for display to end users.
    public var debugDescription: String { get }

    /// Creates a schema by providing an array of properties.
    /// 
    /// - Parameters:
    ///   - type: The type this schema represents.
    ///   - description: A natural language description of this schema.
    ///   - properties: An array of properties.
    public init(type: any Generable.Type, description: String? = nil, properties: [GenerationSchema.Property])

    /// Creates a schema for a string enumeration.
    ///
    /// - Parameters:
    ///   - type: The type this schema represents.
    ///   - description: A natural language description of this schema.
    ///   - anyOf: The allowed choices.
    public init(type: any Generable.Type, description: String? = nil, anyOf choices: [String])

    /// Creates a schema as the union of several other types.
    ///
    /// - Parameters:
    ///   - type: The type this schema represents.
    ///   - description: A natural language description of this schema.
    ///   - anyOf: The types this schema should be a union of.
    public init(type: any Generable.Type, description: String? = nil, anyOf types: [any Generable.Type])

    /// Creates a schema by providing an array of dynamic schemas.
    ///
    /// - Parameters:
    ///   - root: The root schema.
    ///   - dependencies: An array of dynamic schemas.
    /// - Throws: Throws there are schemas with naming conflicts or
    ///   references to undefined types.
    public init(root: DynamicGenerationSchema, dependencies: [DynamicGenerationSchema]) throws

    /// A error that occurs when there is a problem creating a generation schema.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public enum SchemaError : Error, LocalizedError {

        /// The context in which the error occurred.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public struct Context : Sendable {

            /// A string representation of the debug description.
            ///
            /// This string is not localized and is not appropriate for display to end users.
            public let debugDescription: String

            public init(debugDescription: String)
        }

        /// An error that represents an attempt to construct a schema from dynamic schemas,
        /// and two or more of the subschemas have the same type name.
        case duplicateType(schema: String?, type: String, context: GenerationSchema.SchemaError.Context)

        /// An error that represents an attempt to construct a dynamic schema
        /// with properties that have conflicting names.
        case duplicateProperty(schema: String, property: String, context: GenerationSchema.SchemaError.Context)

        /// An error that represents an attempt to construct an anyOf schema with an
        /// empty array of type choices.
        case emptyTypeChoices(schema: String, context: GenerationSchema.SchemaError.Context)

        /// An error that represents an attempt to construct a schema from dynamic schemas,
        /// and one of those schemas references an undefined schema.
        case undefinedReferences(schema: String?, references: [String], context: GenerationSchema.SchemaError.Context)

        /// A string representation of the error description.
        public var errorDescription: String? { get }

        /// A suggestion that indicates how to handle the error.
        public var recoverySuggestion: String? { get }
    }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

/// Allows for influencing the allowed values of properties of a ``Generable`` type.
/// - SeeAlso: `@Generable` macro ``Generable(description:)``
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@attached(peer) public macro Guide<T>(description: String? = nil, _ guides: GenerationGuide<T>...) = #externalMacro(module: "FoundationModelsMacros", type: "GuideMacro") where T : Generable

/// Allows for influencing the allowed values of properties of a ``Generable`` type.
/// - SeeAlso: `@Generable` macro ``Generable(description:)``
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@attached(peer) public macro Guide<RegexOutput>(description: String? = nil, _ guides: Regex<RegexOutput>) = #externalMacro(module: "FoundationModelsMacros", type: "GuideMacro")

/// Allows for influencing the allowed values of properties of a ``Generable`` type.
/// - SeeAlso: `@Generable` macro ``Generable(description:)``
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@attached(peer) public macro Guide(description: String) = #externalMacro(module: "FoundationModelsMacros", type: "GuideMacro")

/// Instructions define the model's intended behavior on prompts.
///
/// Instructions are typically provided by you to define the role and behavior of the model. In the code below,
/// the instructions specify that the model replies with topics rather than, for example, a recipe:
///
/// ```swift
/// let instructions = """
///     Suggest related topics. Keep them concise (three to seven words) and \
///     make sure they build naturally from the person's topic.
///     """
///
/// let session = LanguageModelSession(instructions: instructions)
///
/// let prompt = "Making homemade bread"
/// let response = try await session.respond(to: prompt)
/// ```
///
/// Apple trains the model to obey instructions over any commands it receives in prompts, so don't include
/// untrusted content in instructions. For more on how instructions impact generation quality and safety,
/// see <doc:improving-safety-from-generative-model-output>.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct Instructions : Sendable {

    /// Creates an instance with the content you specify.
    public init(_ content: some InstructionsRepresentable)
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Instructions : InstructionsRepresentable {

    /// An instance that represents the instructions.
    public var instructionsRepresentation: Instructions { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Instructions {

    public init(@InstructionsBuilder _ content: () throws -> Instructions) rethrows
}

/// A type that represents an instructions builder.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@resultBuilder public struct InstructionsBuilder {

    /// Creates a builder with the a block.
    public static func buildBlock<each I>(_ components: repeat each I) -> Instructions where repeat each I : InstructionsRepresentable

    /// Creates a builder with the an array of prompts.
    public static func buildArray(_ instructions: [some InstructionsRepresentable]) -> Instructions

    /// Creates a builder with the first component.
    public static func buildEither(first component: some InstructionsRepresentable) -> Instructions

    /// Creates a builder with the second component.
    public static func buildEither(second component: some InstructionsRepresentable) -> Instructions

    /// Creates a builder with an optional component.
    public static func buildOptional(_ instructions: Instructions?) -> Instructions

    /// Creates a builder with a limited availability prompt.
    public static func buildLimitedAvailability(_ instructions: some InstructionsRepresentable) -> Instructions

    /// Creates a builder with an expression.
    public static func buildExpression<I>(_ expression: I) -> I where I : InstructionsRepresentable

    /// Creates a builder with a prompt expression.
    public static func buildExpression(_ expression: Instructions) -> Instructions
}

/// A type that can be represented as instructions.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol InstructionsRepresentable {

    /// An instance that represents the instructions.
    @InstructionsBuilder var instructionsRepresentation: Instructions { get }
}

/// Feedback appropriate for logging or attaching to Feedback Assistant.
///
/// `LanguageModelFeedback` is a namespace with  structures for describing feedback in a consistent way.
/// ``LanguageModelFeedback/Sentiment`` is used to describe the sentiment of the feedback, while
/// ``LanguageModelFeedback/Issue`` offers a standard template for issues.
///
/// Given a model session, use
/// ``LanguageModelSession/logFeedbackAttachment(sentiment:issues:desiredOutput:)`` to produce
/// structured feedback.
///
/// ```swift
/// let session = LanguageModelSession()
/// let response = try await session.respond(to: "What is the capital of France?")
///
/// // Or create feedback for a problematic response
/// let feedbackData = session.logFeedbackAttachment(
///     sentiment: LanguageModelFeedback.Sentiment.negative,
///     issues: [
///         LanguageModelFeedback.Issue(
///             category: .incorrect,
///             explanation: "The model provided outdated information"
///         )
///     ],
///     desiredOutput: Transcript.Entry.response(...)
/// )
/// ```
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct LanguageModelFeedback {

    /// A sentiment regarding the model's response.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public enum Sentiment : Sendable, CaseIterable {

        /// A positive sentiment
        case positive

        /// A negative sentiment
        case negative

        /// A neutral sentiment
        case neutral

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: LanguageModelFeedback.Sentiment, b: LanguageModelFeedback.Sentiment) -> Bool

        /// A type that can represent a collection of all values of this type.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias AllCases = [LanguageModelFeedback.Sentiment]

        /// A collection of all values of this type.
        nonisolated public static var allCases: [LanguageModelFeedback.Sentiment] { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An issue with the model's response.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Issue : Sendable {

        /// Categories for model response issues.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public enum Category : Sendable, CaseIterable {

            /// The response was not unhelpful.
            ///
            /// An unhelpful issue might be where you asked for a recipe, and the model gave you a list of
            /// ingredients but not amounts.
            case unhelpful

            /// The response was too verbose.
            ///
            /// A verbose issue might be where you asked for a simple recipe, and the model wrote introductory
            /// and conclusion paragraphs.
            case tooVerbose

            /// The model did not follow instructions correctly.
            ///
            /// An instruction issue might be where you asked for a recipe in numbered steps, and the model
            /// provided a recipe but didn't number the steps.
            case didNotFollowInstructions

            /// The model provided an incorrect response.
            ///
            /// An incorrect issue might be where you asked how to make a pizza, and the model suggested using glue.
            case incorrect

            /// The model exhibited bias or perpetuated a stereotype.
            ///
            /// A stereotype or bias issue might be where you ask the model to summarize an article written by
            /// a male, and the model doesn't state the authors sex, but the model uses male pronouns.
            case stereotypeOrBias

            /// The model produces suggestive or sexual material.
            ///
            /// A suggestive or sexual issue might be where you ask the model to draft a script for a school
            /// play, and it includes a sex scene.
            case suggestiveOrSexual

            /// The model produces vulgar or offensive material.
            ///
            /// A vulgar or offensive issue might be where you ask the model to draft a complaint about poor
            /// customer service, and it uses profanity.
            case vulgarOrOffensive

            /// The model throws a guardrail violation when it shouldn't.
            ///
            /// An unexpected guardrail issue might be where you ask for a cake recipe, and the framework
            /// throws a guardrail violation error.
            case triggeredGuardrailUnexpectedly

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: LanguageModelFeedback.Issue.Category, b: LanguageModelFeedback.Issue.Category) -> Bool

            /// A type that can represent a collection of all values of this type.
            @available(iOS 26.0, macOS 26.0, *)
            @available(tvOS, unavailable)
            @available(watchOS, unavailable)
            public typealias AllCases = [LanguageModelFeedback.Issue.Category]

            /// A collection of all values of this type.
            nonisolated public static var allCases: [LanguageModelFeedback.Issue.Category] { get }

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// Creates a new issue
        ///
        /// - Parameters:
        ///   - category: A category for this issue.
        ///   - explanation: An optional explanation of this issue.
        public init(category: LanguageModelFeedback.Issue.Category, explanation: String? = nil)
    }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension LanguageModelFeedback.Sentiment : Equatable {
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension LanguageModelFeedback.Sentiment : Hashable {
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension LanguageModelFeedback.Issue.Category : Equatable {
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension LanguageModelFeedback.Issue.Category : Hashable {
}

/// An object that represents a session that interacts with a language model.
///
/// A session is a single context that you use to generate content with, and maintains state between
/// requests. You can reuse the existing instance or create a new one each time you call the model. When
/// you create a session you can provide instructions that tells the model what its role is and provides
/// guidance on how to respond.
///
/// ```swift
/// let session = LanguageModelSession(instructions: """
///     You are a motivational workout coach that provides quotes to inspire \
///     and motivate athletes.
///     """
/// )
/// let prompt = "Generate a motivational quote for my next workout."
/// let response = try await session.respond(to: prompt)
/// ```
///
/// The framework records each call to the model in a ``Transcript`` that includes all prompts and
/// responses. If your session exceeds the available context size, it throws
/// ``LanguageModelSession/GenerationError/exceededContextWindowSize(_:)``.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
final public class LanguageModelSession {

    /// A full history of interactions, including user inputs and model responses.
    final public var transcript: Transcript { get }

    /// A Boolean value that indicates a response is being generated.
    ///
    /// - Important: You should not call any of the respond methods while
    /// this property is `true`.
    ///
    /// Disable buttons and other interactions to prevent users from submitting
    /// a second prompt while the model is responding to their first prompt.
    ///
    /// ```swift
    /// struct ShopView: View {
    ///     @State var session = LanguageModelSession()
    ///     @State var joke = ""
    ///
    ///     var body: some View {
    ///         Text(joke)
    ///         Button("Generate joke") {
    ///             Task {
    ///                 assert(!session.isResponding, "It should not be possible to tap this button while the model is responding")
    ///                 joke = try await session.respond(to: "Tell me a joke").content
    ///             }
    ///         }
    ///         .disabled(session.isResponding) // Prevent concurrent calls to respond
    ///     }
    /// }
    /// ```
    final public var isResponding: Bool { get }

    /// Start a new session in blank slate state with string-based instructions.
    ///
    /// - Parameters
    ///   - model: The language model to use for this session.
    ///   - tools: Tools to make available to the model for this session.
    ///   - instructions: Instructions that control the model's behavior.
    public convenience init(model: SystemLanguageModel = .default, tools: [any Tool] = [], instructions: String? = nil)

    /// Start a new session in blank slate state with instructions builder.
    ///
    /// - Parameters
    ///   - model: The language model to use for this session.
    ///   - tools: Tools to make available to the model for this session.
    ///   - instructions: Instructions that control the model's behavior.
    public convenience init(model: SystemLanguageModel = .default, tools: [any Tool] = [], @InstructionsBuilder instructions: () throws -> Instructions) rethrows

    /// Start a new session in blank slate state with instructions.
    ///
    /// - Parameters
    ///   - model: The language model to use for this session.
    ///   - tools: Tools to make available to the model for this session.
    ///   - instructions: Instructions that control the model's behavior.
    public convenience init(model: SystemLanguageModel = .default, tools: [any Tool] = [], instructions: Instructions? = nil)

    /// Start a session by rehydrating from a transcript.
    ///
    /// - Parameters
    ///   - model: The language model to use for this session.
    ///   - transcript: A transcript to resume from.
    ///   - tools: Tools to make available to the model for this session.
    public convenience init(model: SystemLanguageModel = .default, tools: [any Tool] = [], transcript: Transcript)

    /// Requests that the system eagerly load the resources required for this session into memory and
    /// optionally caches a prefix of your prompt.
    ///
    /// This method can be useful in cases where you have a strong signal that the user will interact with
    /// session within a few seconds. For example, you might call prewarm when the user begins typing
    /// into a text field.
    ///
    /// If you know a prefix for the future prompt, passing it to prewarm will allow the system to process the
    /// prompt eagerly and reduce latency for the future request.
    ///
    /// - Important: You should only use prewarm when you have a window of at least 1s before the
    /// call to `respond(to:)`.
    ///
    /// - Note: Calling this method does not guarantee that the system loads your assets immediately,
    /// particularly if your app is running in the background or the system is under load.
    final public func prewarm(promptPrefix: Prompt? = nil)

    /// A structure that stores the output of a response call.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Response<Content> where Content : Generable {

        /// The response content.
        public let content: Content

        /// The raw response content.
        ///
        /// When `Content` is `GeneratedContent`, this is the same as `content`.
        public let rawContent: GeneratedContent

        /// The list of transcript entries.
        public let transcriptEntries: ArraySlice<Transcript.Entry>
    }

    /// Produces a response to a prompt.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - options: GenerationOptions that control how tokens are sampled from the distribution the model produces.
    /// - Returns: A string composed of the tokens produced by sampling model output.
    @discardableResult
    nonisolated(nonsending) final public func respond(to prompt: Prompt, options: GenerationOptions = GenerationOptions()) async throws -> LanguageModelSession.Response<String>

    /// Produces a response to a prompt.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - options: GenerationOptions that control how tokens are sampled from the distribution the model produces.
    /// - Returns: A string composed of the tokens produced by sampling model output.
    @discardableResult
    nonisolated(nonsending) final public func respond(to prompt: String, options: GenerationOptions = GenerationOptions()) async throws -> LanguageModelSession.Response<String>

    /// Produces a response to a prompt.
    ///
    /// - Parameters:
    ///   - options: GenerationOptions that control how tokens are sampled from the distribution the model produces.
    ///   - prompt: A prompt for the model to respond to.
    /// - Returns: A string composed of the tokens produced by sampling model output.
    @discardableResult
    nonisolated(nonsending) final public func respond(options: GenerationOptions = GenerationOptions(), @PromptBuilder prompt: () throws -> Prompt) async throws -> LanguageModelSession.Response<String>

    /// Produces a generated content type as a response to a prompt and schema.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - schema: A schema to guide the output with.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: ``GeneratedContent`` containing the fields and values defined in the schema.
    @discardableResult
    nonisolated(nonsending) final public func respond(to prompt: Prompt, schema: GenerationSchema, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions()) async throws -> LanguageModelSession.Response<GeneratedContent>

    /// Produces a generated content type as a response to a prompt and schema.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - schema: A schema to guide the output with.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: ``GeneratedContent`` containing the fields and values defined in the schema.
    @discardableResult
    nonisolated(nonsending) final public func respond(to prompt: String, schema: GenerationSchema, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions()) async throws -> LanguageModelSession.Response<GeneratedContent>

    /// Produces a generated content type as a response to a prompt and schema.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Parameters:
    ///   - schema: A schema to guide the output with.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    ///   - prompt: A prompt for the model to respond to.
    /// - Returns: ``GeneratedContent`` containing the fields and values defined in the schema.
    @discardableResult
    nonisolated(nonsending) final public func respond(schema: GenerationSchema, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions(), @PromptBuilder prompt: () throws -> Prompt) async throws -> LanguageModelSession.Response<GeneratedContent>

    /// Produces a generable object as a response to a prompt.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - type: A type to produce as the response.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: ``GeneratedContent`` containing the fields and values defined in the schema.
    @discardableResult
    nonisolated(nonsending) final public func respond<Content>(to prompt: Prompt, generating type: Content.Type = Content.self, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions()) async throws -> LanguageModelSession.Response<Content> where Content : Generable

    /// Produces a generable object as a response to a prompt.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - type: A type to produce as the response.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: An instance of the `Generable` type.
    /// - Returns: ``GeneratedContent`` containing the fields and values defined in the schema.
    @discardableResult
    nonisolated(nonsending) final public func respond<Content>(to prompt: String, generating type: Content.Type = Content.self, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions()) async throws -> LanguageModelSession.Response<Content> where Content : Generable

    /// Produces a generable object as a response to a prompt.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - type: A type to produce as the response.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: ``GeneratedContent`` containing the fields and values defined in the schema.
    @discardableResult
    nonisolated(nonsending) final public func respond<Content>(generating type: Content.Type = Content.self, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions(), @PromptBuilder prompt: () throws -> Prompt) async throws -> LanguageModelSession.Response<Content> where Content : Generable

    /// Produces a response stream to a prompt and schema.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Important: If running in the background, use the non-streaming
    /// ``LanguageModelSession/respond(to:options:)-(Prompt,_)`` method to
    /// reduce the likelihood of encountering ``LanguageModelSession/GenerationError/rateLimited(_:)`` errors.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - schema: A schema to guide the output with.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: A response stream that produces ``GeneratedContent`` containing the fields and values defined in the schema.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    final public func streamResponse(to prompt: Prompt, schema: GenerationSchema, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions()) -> sending LanguageModelSession.ResponseStream<GeneratedContent>

    @objc deinit
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension LanguageModelSession : @unchecked Sendable {
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension LanguageModelSession : nonisolated Observable {
}

extension LanguageModelSession {

    /// An error that may occur while generating a response.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public enum GenerationError : Error, LocalizedError {

        /// The context in which the error occurred.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public struct Context : Sendable {

            /// A debug description to help developers diagnose issues during development.
            ///
            /// This string is not localized and is not appropriate for display to end users.
            public let debugDescription: String

            /// Creates a context.
            ///
            /// - Parameters:
            ///   - debugDescription: The debug description to help developers diagnose issues during development.
            public init(debugDescription: String)
        }

        /// A refusal produced by a language model.
        ///
        /// Refusal errors indicate that the model chose not to respond to a prompt. To make the model
        /// explain why it refused, catch the refusal error and access one of its explanation properties.
        ///
        /// ```swift
        /// do {
        ///     let session = LanguageModelSession()
        ///     let response = try session.respond(to: "...")
        /// } catch error as LanguageModelSession.GenerationError.refusal(let refusal, _) {
        ///     let message = try await refusal.explanation
        ///     print(message)
        /// } catch {
        ///     print("Something went wrong: \(error)")
        /// }
        /// ```
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public struct Refusal : Sendable {

            public init(transcriptEntries: [Transcript.Entry])

            /// An explanation for why the model refused to respond.
            public var explanation: LanguageModelSession.Response<String> { get async throws }

            /// A stream containing an explanation about why the model refused to respond.
            public var explanationStream: LanguageModelSession.ResponseStream<String> { get }
        }

        /// An error that signals the session reached its context window size limit.
        ///
        /// This error occurs when you use the available tokens for the context window of  4,096 tokens. The
        /// token count includes instructions, prompts, and outputs for a session instance. A single token
        /// corresponds to approximately three to four characters in languages like English, Spanish, or
        /// German, and one token per character in languages like Japanese, Chinese, and Korean.
        ///
        /// Start a new session when you exceed the content window size, and try again using a shorter
        /// prompt or shorter output length.
        case exceededContextWindowSize(LanguageModelSession.GenerationError.Context)

        /// An error that indicates the assets required for the session are unavailable.
        ///
        /// This may happen if you forget to check model availability to begin with,
        /// or if the model assets are deleted. This can happen if the user disables
        /// AppleIntelligence while your app is running.
        ///
        /// You may be able to recover from this error by retrying later after the
        /// device has freed up enough space to redownload model assets.
        case assetsUnavailable(LanguageModelSession.GenerationError.Context)

        /// An error that indicates the system's safety guardrails are triggered by content in a
        /// prompt or the response generated by the model.
        case guardrailViolation(LanguageModelSession.GenerationError.Context)

        /// An error that indicates a generation guide with an unsupported pattern was used.
        case unsupportedGuide(LanguageModelSession.GenerationError.Context)

        /// An error that indicates an error that occurs if the model is prompted to respond in a language
        /// that it does not support.
        case unsupportedLanguageOrLocale(LanguageModelSession.GenerationError.Context)

        /// An error that indicates the session failed to deserialize a valid generable type from model output.
        ///
        /// This can happen if generation was terminated early.
        case decodingFailure(LanguageModelSession.GenerationError.Context)

        /// An error that indicates your session has been rate limited.
        ///
        /// This error will only happen if your app is running in the background
        /// and exceeds the system defined rate limit.
        case rateLimited(LanguageModelSession.GenerationError.Context)

        /// An error that happens if you attempt to make a session respond to a
        /// second prompt while it's still responding to the first one.
        case concurrentRequests(LanguageModelSession.GenerationError.Context)

        /// An error indicating that the model refused to answer.
        ///
        /// This error can happen for prompts that do not violate any guardrail policy, but
        /// the model isn't able to provide the kind of response you requested. You can
        /// choose to handle this error by showing a predetermined message of your choice,
        /// or you can use the `Refusal` to generate an explanation from the model itself.
        case refusal(LanguageModelSession.GenerationError.Refusal, LanguageModelSession.GenerationError.Context)

        /// A string representation of the error description.
        public var errorDescription: String? { get }

        /// A string representation of the recovery suggestion.
        public var recoverySuggestion: String? { get }

        /// A string representation of the failure reason.
        public var failureReason: String? { get }
    }

    /// An error that occurs while a system language model is calling a tool.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct ToolCallError : Error, LocalizedError {

        /// The tool that produced the error.
        public var tool: any Tool

        /// The underlying error that was thrown during a tool call.
        public var underlyingError: any Error

        /// Creates a tool call error
        ///
        /// - Parameters:
        ///   - tool: The tool that produced the error.
        ///    - underlyingError: The underlying error that was thrown during a tool call.
        public init(tool: any Tool, underlyingError: any Error)

        /// A string representation of the error description.
        public var errorDescription: String? { get }
    }
}

extension LanguageModelSession {

    /// An async sequence of snapshots of partially generated content.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct ResponseStream<Content> where Content : Generable {

        /// A snapshot of partially generated content.
        public struct Snapshot {

            /// The content of the response.
            public var content: Content.PartiallyGenerated

            /// The raw content of the response.
            ///
            /// When `Content` is `GeneratedContent`, this is the same as `content`.
            public var rawContent: GeneratedContent
        }
    }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension LanguageModelSession {

    /// Produces a response stream to a prompt and schema.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Important: If running in the background, use the non-streaming
    /// ``LanguageModelSession/respond(to:options:)-(Prompt,_)`` method to
    /// reduce the likelihood of encountering ``LanguageModelSession/GenerationError/rateLimited(_:)`` errors.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - schema: A schema to guide the output with.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: A response stream that produces ``GeneratedContent`` containing the fields and values defined in the schema.
    final public func streamResponse(to prompt: String, schema: GenerationSchema, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions()) -> sending LanguageModelSession.ResponseStream<GeneratedContent>

    /// Produces a response stream to a prompt and schema.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Important: If running in the background, use the non-streaming
    /// ``LanguageModelSession/respond(to:options:)-(Prompt,_)`` method to
    /// reduce the likelihood of encountering ``LanguageModelSession/GenerationError/rateLimited(_:)`` errors.
    ///
    /// - Parameters:
    ///   - schema: A schema to guide the output with.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    ///   - prompt: A prompt for the model to respond to.
    /// - Returns: A response stream that produces ``GeneratedContent`` containing the fields and values defined in the schema.
    final public func streamResponse(schema: GenerationSchema, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions(), @PromptBuilder prompt: () throws -> Prompt) rethrows -> sending LanguageModelSession.ResponseStream<GeneratedContent>

    /// Produces a response stream to a prompt and schema.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Important: If running in the background, use the non-streaming
    /// ``LanguageModelSession/respond(to:options:)-(Prompt,_)`` method to
    /// reduce the likelihood of encountering ``LanguageModelSession/GenerationError/rateLimited(_:)`` errors.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - type: A type to produce as the response.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: A response stream that produces ``GeneratedContent`` containing the fields and values defined in the schema.
    final public func streamResponse<Content>(to prompt: Prompt, generating type: Content.Type = Content.self, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions()) -> sending LanguageModelSession.ResponseStream<Content> where Content : Generable

    /// Produces a response stream to a prompt.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Important: If running in the background, use the non-streaming
    /// ``LanguageModelSession/respond(to:options:)-(Prompt,_)`` method to
    /// reduce the likelihood of encountering ``LanguageModelSession/GenerationError/rateLimited(_:)`` errors.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - type: A type to produce as the response.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: A response stream that produces ``GeneratedContent`` containing the fields and values defined in the schema.
    final public func streamResponse<Content>(to prompt: String, generating type: Content.Type = Content.self, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions()) -> sending LanguageModelSession.ResponseStream<Content> where Content : Generable

    /// Produces a response stream for a type.
    ///
    /// Consider using the default value of `true` for `includeSchemaInPrompt`.
    /// The exception to the rule is when the model has knowledge about the expected response format, either
    /// because it has been trained on it, or because it has seen exhaustive examples during this session.
    ///
    /// - Important: If running in the background, use the non-streaming
    /// ``LanguageModelSession/respond(to:options:)-(Prompt,_)`` method to
    /// reduce the likelihood of encountering ``LanguageModelSession/GenerationError/rateLimited(_:)`` errors.
    ///
    /// - Parameters:
    ///   - prompt: A prompt for the model to respond to.
    ///   - type: A type to produce as the response.
    ///   - includeSchemaInPrompt: Inject the schema into the prompt to bias the model.   
    ///   - options: Options that control how tokens are sampled from the distribution the model produces.
    /// - Returns: A response stream.
    final public func streamResponse<Content>(generating type: Content.Type = Content.self, includeSchemaInPrompt: Bool = true, options: GenerationOptions = GenerationOptions(), @PromptBuilder prompt: () throws -> Prompt) rethrows -> sending LanguageModelSession.ResponseStream<Content> where Content : Generable

    /// Produces a response stream to a prompt.
    ///
    /// - Important: If running in the background, use the non-streaming
    /// ``LanguageModelSession/respond(to:options:)-(Prompt,_)`` method to
    /// reduce the likelihood of encountering ``LanguageModelSession/GenerationError/rateLimited(_:)`` errors.
    ///
    /// - Parameters:
    ///   - prompt: A specific prompt for the model to respond to.
    ///   - options: GenerationOptions that control how tokens are sampled from the distribution the model produces.
    /// - Returns: A response stream that produces aggregated tokens.
    final public func streamResponse(to prompt: Prompt, options: GenerationOptions = GenerationOptions()) -> sending LanguageModelSession.ResponseStream<String>

    /// Produces a response stream to a prompt.
    ///
    /// - Important: If running in the background, use the non-streaming
    /// ``LanguageModelSession/respond(to:options:)-(Prompt,_)`` method to
    /// reduce the likelihood of encountering ``LanguageModelSession/GenerationError/rateLimited(_:)`` errors.
    ///
    /// - Parameters:
    ///   - prompt: A specific prompt for the model to respond to.
    ///   - options: GenerationOptions that control how tokens are sampled from the distribution the model produces.
    /// - Returns: A response stream that produces aggregated tokens.
    final public func streamResponse(to prompt: String, options: GenerationOptions = GenerationOptions()) -> sending LanguageModelSession.ResponseStream<String>

    /// Produces a response stream to a prompt.
    ///
    /// - Important: If running in the background, use the non-streaming
    /// ``LanguageModelSession/respond(to:options:)-(Prompt,_)`` method to
    /// reduce the likelihood of encountering ``LanguageModelSession/GenerationError/rateLimited(_:)`` errors.
    ///
    /// - Parameters:
    ///   - options: GenerationOptions that control how tokens are sampled from the distribution the model produces.
    ///   - prompt: A specific prompt for the model to respond to.
    /// - Returns: A response stream that produces aggregated tokens.
    final public func streamResponse(options: GenerationOptions = GenerationOptions(), @PromptBuilder prompt: () throws -> Prompt) rethrows -> sending LanguageModelSession.ResponseStream<String>
}

extension LanguageModelSession {

    /// Logs and serializes a feedback attachment that can be submitted to Apple.
    ///
    /// This method creates a structured feedback attachment containing the session's transcript
    /// and any provided feedback information. The attachment can be saved to a file and submitted
    /// to Apple using [Feedback Assistant](https://feedbackassistant.apple.com).
    ///
    /// If an error occurred during a previous response, any rejected entries that were rolled
    /// back from the transcript are included in the feedback data.
    ///
    /// - Parameters:
    ///   - sentiment: An optional sentiment rating about the model's output (positive, negative, or neutral).
    ///   - issues: An array of specific issues identified with the model's response. Defaults to an empty array.
    ///   - desiredOutput: An optional transcript entry showing what the desired output should have been.
    /// - Returns: A `Data` object containing the JSON-encoded feedback attachment that can be submitted to Feedback Assistant.
    ///
    /// ## Usage Example
    /// ```swift
    /// let session = LanguageModelSession()
    /// let response = try await session.respond(to: "What is the capital of France?")
    /// 
    /// // Create feedback for a helpful response
    /// let feedbackData = session.logFeedbackAttachment(sentiment: .positive)
    ///
    /// // Or create feedback for a problematic response
    /// let feedbackData = session.logFeedbackAttachment(
    ///     sentiment: .negative,
    ///     issues: [
    ///         LanguageModelFeedback.Issue(
    ///             category: .incorrect,
    ///             explanation: "The model provided outdated information"
    ///         )
    ///     ],
    ///     desiredOutput: Transcript.Entry.response(...)
    /// )
    /// ```
    ///
    /// If your `desiredOutput` is a string, use ``Transcript/Entry/response(_:)`` to turn your desired output into a
    /// ``Transcript`` entry:
    ///
    /// ```swift
    /// let text = Transcript.TextSegment(content: "The capital of France is Paris.")
    /// let segment = Transcript.Segment.text(text)
    /// let response = Transcript.Response(segments: [segment])
    /// let entry = Transcript.Entry.response(response)
    /// ```
    ///
    /// If your `desiredOutput` is a ``Generable`` type, turning that into a ``Transcript`` entry is slightly different:
    ///
    /// ```swift
    /// let foo = Foo(...) // A Generable type
    /// let structure = Transcript.StructuredSegment(source: String(describing: Foo.self), content: foo.generatedContent))
    /// let segment = Transcript.Segment.structure(structure)
    /// let response = Transcript.Response(segments: [segment])
    /// let entry = Transcript.Entry.response(response)
    /// ```
    ///
    /// Finally, if you'd like to submit the feedback to Apple, write your feedback to a `.json` file and include the file as an
    /// attachment to [Feedback Assistant](https://feedbackassistant.apple.com). You can include one or many
    /// feedback attachment in the same file:
    ///
    /// ```swift
    /// let allFeedback = feedbackData + feedbackData2 + feedbackData3
    /// let url = URL(fileURLWithPath: "path/to/save/feedback.json")
    /// try allFeedback.write(to: url)
    /// ```
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @discardableResult
    final public func logFeedbackAttachment(sentiment: LanguageModelFeedback.Sentiment?, issues: [LanguageModelFeedback.Issue] = [], desiredOutput: Transcript.Entry? = nil) -> Data

    @available(iOS 26.0, macOS 26.0, *)
    @backDeployed(before: iOS 26.1, macOS 26.1, visionOS 26.1)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @discardableResult
    final public func logFeedbackAttachment(sentiment: LanguageModelFeedback.Sentiment?, issues: [LanguageModelFeedback.Issue] = [], desiredResponseText: String?) -> Data

    @available(iOS 26.0, macOS 26.0, *)
    @backDeployed(before: iOS 26.1, macOS 26.1, visionOS 26.1)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @discardableResult
    final public func logFeedbackAttachment(sentiment: LanguageModelFeedback.Sentiment?, issues: [LanguageModelFeedback.Issue] = [], desiredResponseContent: (any ConvertibleToGeneratedContent)?) -> Data
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension LanguageModelSession.ResponseStream : AsyncSequence {

    /// The type of element produced by this asynchronous sequence.
    public typealias Element = LanguageModelSession.ResponseStream<Content>.Snapshot

    /// The type of asynchronous iterator that produces elements of this
    /// asynchronous sequence.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct AsyncIterator : AsyncIteratorProtocol {

        /// Asynchronously advances to the next element and returns it, or ends the
        /// sequence if there is no next element.
        ///
        /// - Returns: The next element, if it exists, or `nil` to signal the end of
        ///   the sequence.
        public mutating func next(isolation actor: isolated (any Actor)? = #isolation) async throws -> LanguageModelSession.ResponseStream<Content>.Snapshot?

        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Element = LanguageModelSession.ResponseStream<Content>.Snapshot
    }

    /// Creates the asynchronous iterator that produces elements of this
    /// asynchronous sequence.
    ///
    /// - Returns: An instance of the `AsyncIterator` type used to produce
    /// elements of the asynchronous sequence.
    public func makeAsyncIterator() -> LanguageModelSession.ResponseStream<Content>.AsyncIterator

    /// The result from a streaming response, after it completes.
    ///
    /// If the streaming response was finished successfully before calling
    /// `collect()`, this method `Response` returns immediately.
    ///
    /// If the streaming response was finished with an error before calling
    /// `collect()`, this method propagates that error.
    nonisolated(nonsending) public func collect() async throws -> sending LanguageModelSession.Response<Content>
}

/// A prompt from a person to the model.
///
/// Prompts can contain content written by you, an outside source, or input directly from people using
/// your app. You can initialize a `Prompt` from a string literal:
///
/// ```swift
/// let prompt = Prompt("What are miniature schnauzers known for?")
/// ```
///
/// Use ``PromptBuilder`` to dynamically control the prompt's content based on your app's state. The
/// code below shows if the Boolean is `true`, the prompt includes a second line of text:
///
/// ```swift
/// let responseShouldRhyme = true
/// let prompt = Prompt {
///     "Answer the following question from the user: \(userInput)"
///     if responseShouldRhyme {
///         "Your response MUST rhyme!"
///     }
/// }
/// ```
///
/// If your prompt includes input from people, consider wrapping the input in a string template with your
/// own prompt to better steer the model's response. For more information on handling inputs in your
/// prompts, see <doc:improving-safety-from-generative-model-output>.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct Prompt : Sendable {

    /// Creates an instance with the content you specify.
    public init(_ content: some PromptRepresentable)
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Prompt : PromptRepresentable {

    /// An instance that represents a prompt.
    public var promptRepresentation: Prompt { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Prompt {

    public init(@PromptBuilder _ content: () throws -> Prompt) rethrows
}

/// A type that represents a prompt builder.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
@resultBuilder public struct PromptBuilder {

    /// Creates a builder with the a block.
    public static func buildBlock<each P>(_ components: repeat each P) -> Prompt where repeat each P : PromptRepresentable

    /// Creates a builder with the an array of prompts.
    public static func buildArray(_ prompts: [some PromptRepresentable]) -> Prompt

    /// Creates a builder with the first component.
    public static func buildEither(first component: some PromptRepresentable) -> Prompt

    /// Creates a builder with the second component.
    public static func buildEither(second component: some PromptRepresentable) -> Prompt

    /// Creates a builder with an optional component.
    public static func buildOptional(_ component: Prompt?) -> Prompt

    /// Creates a builder with a limited availability prompt.
    public static func buildLimitedAvailability(_ prompt: some PromptRepresentable) -> Prompt

    /// Creates a builder with an expression.
    public static func buildExpression<P>(_ expression: P) -> P where P : PromptRepresentable

    /// Creates a builder with a prompt expression.
    public static func buildExpression(_ expression: Prompt) -> Prompt
}

/// A type whose value can represent a prompt.
///  
/// - Important: Conformance to this protocol is provided automatically by the
/// `@Generable` macro, you should **not** override its implementations. Overriding
/// may negatively impact runtime performance and cause bugs.
///  
/// For types that are not ``Generable``, you may provide your own implementation.
///  
/// Experiment with different representations to find one that works well for
/// your type. Generally, any format that is easily understandable to humans
/// will work well for the model as well.
///  
/// ```swift
/// struct FamousHistoricalFigure: PromptRepresentable {
///     var name: String
///     var biggestAccomplishment: String
///
///     var promptRepresentation: Prompt {
///         """
///         Famous Historical Figure:
///         - name: \(name)
///         - best known for: \(biggestAccomplishment)
///         """
///     }
/// }
///
/// let response = try await LanguageModelSession().respond {
///     "Tell me more about..."
///     FamousHistoricalFigure(
///         name: "Albert Einstein",
///         biggestAccomplishment: "Theory of Relativity"
///     )
/// }
/// ```
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol PromptRepresentable {

    /// An instance that represents a prompt.
    @PromptBuilder var promptRepresentation: Prompt { get }
}

/// An on-device large language model capable of text generation tasks.
///
/// The `SystemLanguageModel` refers to the on-device text foundation model that powers Apple
/// Intelligence. Use ``default`` to access the base version of the model and perform general-purpose
/// text generation tasks. To access a specialized version of the model, initialize the model
/// with ``UseCase`` to perform tasks like ``UseCase/contentTagging``.
///
/// Verify the model availability before you use the model. Model availability depends on device factors like:
///
/// * The device must support Apple Intelligence.
/// * Apple Intelligence must be turned on in Settings.
///
/// Use ``Availability`` to change what your app shows to people based on the availability condition:
///
/// ```swift
/// struct GenerativeView: View {
///     // Create a reference to the system language model.
///     private var model = SystemLanguageModel.default
///
///     var body: some View {
///         switch model.availability {
///         case .available:
///             // Show your intelligence UI.
///         case .unavailable(.deviceNotEligible):
///             // Show an alternative UI.
///         case .unavailable(.appleIntelligenceNotEnabled):
///             // Ask the person to turn on Apple Intelligence.
///         case .unavailable(.modelNotReady):
///             // The model isn't ready because it's downloading or because
///             // of other system reasons.
///         case .unavailable(let other):
///             // The model is unavailable for an unknown reason.
///         }
///     }
/// }
/// ```
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
final public class SystemLanguageModel : Sendable {

    /// The availability of the language model.
    final public var availability: SystemLanguageModel.Availability { get }

    /// A convenience getter to check if the system is entirely ready.
    final public var isAvailable: Bool { get }

    /// A type that represents the use case for prompting.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct UseCase : Sendable, Equatable {

        /// A use case for general prompting.
        ///
        /// This is the default use case for the base version of the model, so if you use
        /// `SystemLanguageModel.default`, you don't need to specify a use case.
        public static let general: SystemLanguageModel.UseCase

        /// A use case for content tagging.
        ///
        /// Content tagging produces a list of categorizing tags based on the input prompt. When specializing
        /// the model for the `contentTagging` use case, it always responds with tags. The tagging
        /// capabilities of the model include detecting topics, emotions, actions, and objects. For more
        /// information about content tagging, see <doc:categorizing-and-organizing-data-with-content-tags>.
        public static let contentTagging: SystemLanguageModel.UseCase

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SystemLanguageModel.UseCase, b: SystemLanguageModel.UseCase) -> Bool
    }

    @objc deinit
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension SystemLanguageModel {

    /// Controls the built-in safety guardrails for prompt and response filtering.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Guardrails : Sendable {

        /// Default guardrails. This mode ensures that unsafecontent in prompts and responses will be
        /// blocked with a `LanguageModelSession.GenerationError.guardrailViolation`
        /// error.
        public static let `default`: SystemLanguageModel.Guardrails

        /// Guardrails that allow for permissively transforming text input, including
        /// potentially unsafe content, to text responses, such as summarizing an article.
        ///
        /// In this mode, requests you make to the model that generate a `String` will not throw
        /// `LanguageModelSession.GenerationError.guardrailViolation` errors.
        /// However, when the purpose of your instructions and prompts is not transforming user input,
        /// the model may still refuse to respond to potentially unsafe prompts by generating an
        /// explanation.
        ///
        /// When you generate responses other than `String`, this mode behaves the same way as `.default`.
        public static let permissiveContentTransformations: SystemLanguageModel.Guardrails
    }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension SystemLanguageModel {

    /// The availability status for a specific system language model.
    /// - SeeAlso: ``SystemLanguageModel/availability``
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @frozen public enum Availability : Equatable, Sendable {

        /// The unavailable reason.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public enum UnavailableReason : Equatable, Sendable {

            /// The device does not support Apple Intelligence.
            case deviceNotEligible

            /// Apple Intelligence is not enabled on the system.
            case appleIntelligenceNotEnabled

            /// The model(s) aren't available on the user's device.
            ///
            /// Models are downloaded automatically based on factors
            /// like network status, battery level, and system load.
            case modelNotReady

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: SystemLanguageModel.Availability.UnavailableReason, b: SystemLanguageModel.Availability.UnavailableReason) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// The system is ready for making requests.
        case available

        /// Indicates that the system is not ready for requests.
        case unavailable(SystemLanguageModel.Availability.UnavailableReason)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: SystemLanguageModel.Availability, b: SystemLanguageModel.Availability) -> Bool
    }

    /// The base version of the model.
    ///
    /// The base model is a generic model that is useful for a
    /// wide variety of applications, but is not specialized to
    /// any particular use case.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static let `default`: SystemLanguageModel

    /// Creates a system language model for a specific use case.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public convenience init(useCase: SystemLanguageModel.UseCase = .general, guardrails: SystemLanguageModel.Guardrails = Guardrails.default)

    /// Creates the base version of the model with an adapter.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public convenience init(adapter: SystemLanguageModel.Adapter, guardrails: SystemLanguageModel.Guardrails = .default)

    /// Languages that the model supports.
    ///
    /// To check if a given locale is considered supported by the model, use `supportsLocale(_:)`, which will also take into consideration language fallbacks.
    final public var supportedLanguages: Set<Locale.Language> { get }

    /// Returns a Boolean indicating whether the given locale is supported by the model.
    ///
    /// Use this method over `supportedLanguages` to check whether the given locale qualifies a user for using this model, as this method will take into consideration language fallbacks.
    final public func supportsLocale(_ locale: Locale = Locale.current) -> Bool
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension SystemLanguageModel : nonisolated Observable {
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension SystemLanguageModel {

    /// An adapter for a language model.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Adapter {

        /// Values read from the creator defined field of the adapter's metadata.
        public var creatorDefinedMetadata: [String : Any] { get }
    }
}

/// Specializes the system language model for custom use cases.
///
/// Use the base system model for most prompt engineering, guided generation, and tools. If you need to
/// specialize the model, train a custom `Adapter` to alter the system model weights and optimize it for
/// your custom task. Use custom adapters only if you're comfortable training foundation models in Python.
///
/// > Important: You need to re-train an adapter for every new version of the base system model that
/// Apple releases. Adapters consume a large amount of storage space and isn't recommended for
/// most apps.
///
/// For more on custom adapters, see [Get started with Foundation Models adapter training](https://developer.apple.com/apple-intelligence/foundation-models-adapter/).
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension SystemLanguageModel.Adapter {

    /// Creates an adapter from the file URL.
    ///
    /// - Throws: An error of `AssetLoadingError` type when `fileURL`
    ///   is invalid.
    public init(fileURL: URL) throws

    /// Creates an adapter downloaded from the background assets framework.
    ///
    /// - Throws: An error of `AssetLoadingError` type when there are
    ///   no compatible asset packs with this adapter name downloaded.
    public init(name: String) throws

    /// Prepares an adapter before being used with a ``LanguageModelSession``.
    /// You should call this if your adapter has a draft model.
    public func compile() async throws

    /// Get all compatible adapter identifiers compatible with current system models.
    ///
    /// - Parameters:
    ///   - name: Name of the adapter.
    ///
    /// - Returns: All adapter identifiers compatible with current system models, listed in descending
    ///   order in terms of system preference. You can determine which asset pack or on-demand
    ///   resource to download with compatible adapter identifiers.
    ///
    ///   On devices that support Apple Intelligence, the result is guaranteed to be non-empty.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static func compatibleAdapterIdentifiers(name: String) -> [String]

    /// Remove all obsolete adapters that are no longer compatible with current system models.
    public static func removeObsoleteAdapters() throws

    /// Returns a Boolean value that indicates whether an asset pack is an on-device foundation model
    /// adapter and is compatible with the system base model version on the runtime device.
    ///
    /// Use this check when choosing an adapter asset pack to download. This check only validates the
    /// asset pack name and metadata, so initializing the adapter with ``Adapter/init(name:)`` --- or
    /// loading the adapter onto the base model with ``SystemLanguageModel/init(adapter:guardrails:)`` ---
    /// may throw errors if the adapter has a compatibility issue despite having correct metadata.
    ///
    /// > Note: Run this check before you download an adapter asset pack to confirm if it's usable on the
    /// runtime device.
    public static func isCompatible(_ assetPack: AssetPack) -> Bool
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension SystemLanguageModel.Adapter {

    @available(iOS 26.0, macOS 26.0, *)
    @available(watchOS, unavailable)
    @available(tvOS, unavailable)
    public enum AssetError : Error, LocalizedError {

        /// The context in which the error occurred.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public struct Context : Sendable {

            /// A debug description to help developers diagnose issues during development.
            /// 
            /// This string is not localized and is not appropriate for display to end users.
            public let debugDescription: String

            public init(debugDescription: String)
        }

        /// An error that happens if the provided asset files are invalid.
        case invalidAsset(SystemLanguageModel.Adapter.AssetError.Context)

        /// An error that happens if the provided adapter name is invalid.
        case invalidAdapterName(SystemLanguageModel.Adapter.AssetError.Context)

        /// An error that happens if there are no compatible adapters for the current system base model.
        case compatibleAdapterNotFound(SystemLanguageModel.Adapter.AssetError.Context)

        /// A string representation of the error description.
        public var errorDescription: String? { get }

        /// A localized message describing how one might recover from the failure.
        public var recoverySuggestion: String? { get }
    }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension SystemLanguageModel.Availability.UnavailableReason : Hashable {
}

/// A tool that a model can call to gather information at runtime or perform side effects.
///
/// Tool calling gives the model the ability to call your code to incorporate
/// up-to-date information like recent events and data from your app. A tool
/// includes a name and a description that the framework puts in the prompt to let
/// the model decide when and how often to call your tool.
///
/// A `Tool` defines a ``call(arguments:)`` method that takes arguments that conforms to
/// ``ConvertibleFromGeneratedContent``, and returns an output of any type that conforms to
/// ``PromptRepresentable``, allowing the model to understand and reason about in subsequent
/// interactions. Typically, ``Output`` is a `String` or any ``Generable`` types.
///
/// ```swift
/// struct FindContacts: Tool {
///     let name = "findContacts"
///     let description = "Finds a specific number of contacts"
///
///     @Generable
///     struct Arguments {
///         @Guide(description: "The number of contacts to get", .range(1...10))
///         let count: Int
///     }
///
///     func call(arguments: Arguments) async throws -> [String] {
///         var contacts: [CNContact] = []
///         // Fetch a number of contacts using the arguments.
///         let formattedContacts = contacts.map {
///             "\($0.givenName) \($0.familyName)"
///         }
///         return formattedContacts
///     }
/// }
/// ```
///
/// Tools must conform to <doc://com.apple.documentation/documentation/swift/sendable>
/// so the framework can run them concurrently. If the model needs to pass the output
/// of one tool as the input to another, it executes back-to-back tool calls.
///
/// You control the life cycle of your tool, so you can track the state of it between
/// calls to the model. For example, you might store a list of database records that
/// you don't want to reuse between tool calls.
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public protocol Tool<Arguments, Output> : Sendable {

    /// The output that this tool produces for the language model to reason about in subsequent
    /// interactions.
    ///
    /// Typically output is either a `String` or a ``Generable`` type.
    associatedtype Output : PromptRepresentable

    /// The arguments that this tool should accept.
    ///
    /// Typically arguments are either a ``Generable`` type or ``GeneratedContent``.
    associatedtype Arguments : ConvertibleFromGeneratedContent

    /// A unique name for the tool, such as "get_weather", "toggleDarkMode", or "search contacts".
    var name: String { get }

    /// A natural language description of when and how to use the tool.
    var description: String { get }

    /// A schema for the parameters this tool accepts.
    var parameters: GenerationSchema { get }

    /// If true, the model's name, description, and parameters schema will be injected
    /// into the instructions of sessions that leverage this tool.
    ///
    /// The default implementation is `true`
    ///
    /// - Note: This should only be `false` if the model has been trained to have
    /// innate knowledge of this tool. For zero-shot prompting, it should always be `true`.
    var includesSchemaInInstructions: Bool { get }

    /// A language model will call this method when it wants to leverage this tool.
    ///
    /// If errors are throw in the body of this method, they will be wrapped in a
    /// ``LanguageModelSession/ToolCallError`` and rethrown at the call site
    /// of ``LanguageModelSession/respond(to:options:)-(Prompt,_)``.
    ///
    /// - Note: This method may be invoked concurrently with itself or with other tools.
    func call(arguments: Self.Arguments) async throws -> Self.Output
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Tool {

    /// A unique name for the tool, such as "get_weather", "toggleDarkMode", or "search contacts".
    public var name: String { get }

    /// If true, the model's name, description, and parameters schema will be injected
    /// into the instructions of sessions that leverage this tool.
    ///
    /// The default implementation is `true`
    ///
    /// - Note: This should only be `false` if the model has been trained to have
    /// innate knowledge of this tool. For zero-shot prompting, it should always be `true`.
    public var includesSchemaInInstructions: Bool { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Tool where Self.Arguments : Generable {

    /// A schema for the parameters this tool accepts.
    public var parameters: GenerationSchema { get }
}

/// A transcript contains a linear history of ``Transcript/Entry`` entries.
///
/// Transcript entries are can be used to visualize previous prompts and
/// responses.
///
/// ```swift
/// struct HistoryView: View {
///     let session: LanguageModelSession
///
///     var body: some View {
///         ScrollView {
///             ForEach(session.transcript) { entry in
///                 switch entry {
///                 case let .instructions(instructions):
///                     MyInstructionsView(instructions)
///                 case let .prompt(prompt)
///                     MyPromptView(prompt)
///                 case let .toolCalls(toolCalls):
///                     MyToolCallsView(toolCalls)
///                 case let .toolOutput(toolOutput):
///                     MyToolOutputView(toolOutput)
///                 case let .response(response):
///                     MyResponseView(response)
///                 }
///             }
///         }
///     }
/// }
/// ```
@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
public struct Transcript : Sendable, Equatable, RandomAccessCollection {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: Transcript.Index) -> Transcript.Entry

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Creates a transcript.
    ///
    /// - Parameters:
    ///   - entries: An array of entries to seed the transcript.
    public init(entries: some Sequence<Transcript.Entry> = [])

    /// An entry in a transcript.
    ///
    /// An individual entry in a transcript may represent instructions from you
    /// to the model, a prompt from a user, tool calls, or a response generated
    /// by the model.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public enum Entry : Sendable, Identifiable, Equatable {

        /// Instructions, typically provided by you, the developer.
        case instructions(Transcript.Instructions)

        /// A prompt, typically sourced from an end user.
        case prompt(Transcript.Prompt)

        /// A tool call containing a tool name and the arguments to invoke it with.
        case toolCalls(Transcript.ToolCalls)

        /// An tool output provided back to the model.
        case toolOutput(Transcript.ToolOutput)

        /// A response from the model.
        case response(Transcript.Response)

        /// The stable identity of the entity associated with this instance.
        public var id: String { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.Entry, b: Transcript.Entry) -> Bool

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String
    }

    /// The types of segments that may be included in a transcript entry.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public enum Segment : Sendable, Identifiable, Equatable {

        /// A segment containing text.
        case text(Transcript.TextSegment)

        /// A segment containing structured content.
        case structure(Transcript.StructuredSegment)

        /// The stable identity of the entity associated with this instance.
        public var id: String { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.Segment, b: Transcript.Segment) -> Bool

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String
    }

    /// A segment containing text.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct TextSegment : Sendable, Identifiable, Equatable {

        /// The stable identity of the entity associated with this instance.
        public var id: String

        public var content: String

        public init(id: String = UUID().uuidString, content: String)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.TextSegment, b: Transcript.TextSegment) -> Bool

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String
    }

    /// A segment containing structured content.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct StructuredSegment : Sendable, Identifiable, Equatable {

        /// The stable identity of the entity associated with this instance.
        public var id: String

        /// A source that be used to understand which type content represents.
        public var source: String

        /// The content of the segment.
        public var content: GeneratedContent

        public init(id: String = UUID().uuidString, source: String, content: GeneratedContent)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.StructuredSegment, b: Transcript.StructuredSegment) -> Bool

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String
    }

    /// Instructions you provide to the model that define its behavior.
    ///
    /// Instructions are typically provided to define the role and behavior of the model. Apple trains the model
    /// to obey instructions over any commands it receives in prompts. This is a security mechanism to help
    /// mitigate prompt injection attacks.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Instructions : Sendable, Identifiable, Equatable {

        /// The stable identity of the entity associated with this instance.
        public var id: String

        /// The content of the instructions, in natural language.
        ///
        /// - Note: Instructions are often provided in English even when the
        /// users interact with the model in another language.
        public var segments: [Transcript.Segment]

        /// A list of tools made available to the model.
        public var toolDefinitions: [Transcript.ToolDefinition]

        /// Initialize instructions by describing how you want the model to
        /// behave using natural language.
        ///
        /// - Parameters:
        ///   - id: A unique identifier for this instructions segment.
        ///   - segments: An array of segments that make up the instructions.
        ///   - toolDefinitions: Tools that the model should be allowed to call.
        public init(id: String = UUID().uuidString, segments: [Transcript.Segment], toolDefinitions: [Transcript.ToolDefinition])

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.Instructions, b: Transcript.Instructions) -> Bool

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String
    }

    /// A definition of a tool.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct ToolDefinition : Sendable, Equatable {

        /// The tool's name.
        public var name: String

        /// A description of how and when to use the tool.
        public var description: String

        public init(name: String, description: String, parameters: GenerationSchema)

        public init(tool: some Tool)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.ToolDefinition, b: Transcript.ToolDefinition) -> Bool
    }

    /// A prompt from the user to the model.
    ///
    /// Prompts typically contain content sourced directly from the user,
    /// though you may choose to augment prompts by interpolating content from
    /// end users into a template that you control.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Prompt : Sendable, Identifiable, Equatable {

        /// The identifier of the prompt.
        public var id: String

        /// Ordered prompt segments.
        public var segments: [Transcript.Segment]

        /// Generation options associated with the prompt.
        public var options: GenerationOptions

        /// An optional response format that describes the desired output structure.
        public var responseFormat: Transcript.ResponseFormat?

        /// Creates a prompt.
        ///
        /// - Parameters:
        ///   - id: A ``Generable`` type to use as the response format.
        ///   - segments: An array of segments that make up the prompt.
        ///   - options: Options that control how tokens are sampled from the distribution the model produces.
        ///   - responseFormat: A response format that describes the output structure.
        public init(id: String = UUID().uuidString, segments: [Transcript.Segment], options: GenerationOptions = GenerationOptions(), responseFormat: Transcript.ResponseFormat? = nil)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.Prompt, b: Transcript.Prompt) -> Bool

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String
    }

    /// Specifies a response format that the model must conform its output to.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct ResponseFormat : Sendable, Equatable {

        /// A name associated with the response format.
        public var name: String { get }

        /// Creates a response format with type you specify.
        ///
        /// - Parameters:
        ///   - type: A ``Generable`` type to use as the response format.
        public init<Content>(type: Content.Type) where Content : Generable

        /// Creates a response format with a schema.
        ///
        /// - Parameters:
        ///   - schema: A schema to use as the response format.
        public init(schema: GenerationSchema)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.ResponseFormat, b: Transcript.ResponseFormat) -> Bool
    }

    /// A collection tool calls generated by the model.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct ToolCalls : Sendable, Identifiable, Equatable, RandomAccessCollection {

        /// The stable identity of the entity associated with this instance.
        public var id: String

        public init<S>(id: String = UUID().uuidString, _ calls: S) where S : Sequence, S.Element == Transcript.ToolCall

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> Transcript.ToolCall { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.ToolCalls, b: Transcript.ToolCalls) -> Bool

        /// A type representing the sequence's elements.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Element = Transcript.ToolCall

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Index = Int

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Indices = Range<Int>

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias Iterator = IndexingIterator<Transcript.ToolCalls>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias SubSequence = Slice<Transcript.ToolCalls>
    }

    /// A tool call generated by the model containing the name of a tool and arguments to pass to it.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct ToolCall : Sendable, Identifiable, Equatable {

        /// The stable identity of the entity associated with this instance.
        public var id: String

        /// The name of the tool being invoked.
        public var toolName: String

        /// Arguments to pass to the invoked tool.
        public var arguments: GeneratedContent

        public init(id: String, toolName: String, arguments: GeneratedContent)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.ToolCall, b: Transcript.ToolCall) -> Bool

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String
    }

    /// A tool output provided back to the model.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct ToolOutput : Sendable, Identifiable, Equatable {

        /// A unique id for this tool output.
        public var id: String

        /// The name of the tool that produced this output.
        public var toolName: String

        /// Segments of the tool output.
        public var segments: [Transcript.Segment]

        public init(id: String, toolName: String, segments: [Transcript.Segment])

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.ToolOutput, b: Transcript.ToolOutput) -> Bool

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String
    }

    /// A response from the model.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public struct Response : Sendable, Identifiable, Equatable {

        /// The stable identity of the entity associated with this instance.
        public var id: String

        /// Version aware identifiers for all assets used to generate this response.
        public var assetIDs: [String]

        /// Ordered prompt segments.
        public var segments: [Transcript.Segment]

        public init(id: String = UUID().uuidString, assetIDs: [String], segments: [Transcript.Segment])

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Transcript.Response, b: Transcript.Response) -> Bool

        /// A type representing the stable identity of the entity associated with
        /// an instance.
        @available(iOS 26.0, macOS 26.0, *)
        @available(tvOS, unavailable)
        @available(watchOS, unavailable)
        public typealias ID = String
    }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Transcript, b: Transcript) -> Bool

    /// A type representing the sequence's elements.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Element = Transcript.Entry

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Indices = Range<Transcript.Index>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias Iterator = IndexingIterator<Transcript>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 26.0, macOS 26.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public typealias SubSequence = Slice<Transcript>
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.Entry : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.Segment : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.TextSegment : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.StructuredSegment : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.Instructions : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.Prompt : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.ResponseFormat : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.ToolCalls : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.ToolCall : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.ToolOutput : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(watchOS, unavailable)
@available(tvOS, unavailable)
extension Transcript.Response : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Optional where Wrapped : Generable {

    public typealias PartiallyGenerated = Wrapped.PartiallyGenerated
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Optional : ConvertibleToGeneratedContent, PromptRepresentable, InstructionsRepresentable where Wrapped : ConvertibleToGeneratedContent {

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    public var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Bool : Generable {

    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema { get }

    /// Creates an instance from content generated by a model.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. To manually initialize your type from generated content,
    /// decode the values as shown below:
    ///
    /// ```swift
    /// struct Person: ConvertibleFromGeneratedContent {
    ///     var name: String
    ///     var age: Int
    ///
    ///     init(_ content: GeneratedContent) {
    ///         self.name = try content.value(forProperty: "firstName")
    ///         self.age = try content.value(forProperty: "ageInYears")
    ///     }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleToGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleToGeneratedContent/generatedContent``.
    ///
    /// - SeeAlso: `@Generable` macro ``Generable(description:)``
    public init(_ content: GeneratedContent) throws

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    public var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension String : Generable {

    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema { get }

    /// Creates an instance from content generated by a model.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. To manually initialize your type from generated content,
    /// decode the values as shown below:
    ///
    /// ```swift
    /// struct Person: ConvertibleFromGeneratedContent {
    ///     var name: String
    ///     var age: Int
    ///
    ///     init(_ content: GeneratedContent) {
    ///         self.name = try content.value(forProperty: "firstName")
    ///         self.age = try content.value(forProperty: "ageInYears")
    ///     }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleToGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleToGeneratedContent/generatedContent``.
    ///
    /// - SeeAlso: `@Generable` macro ``Generable(description:)``
    public init(_ content: GeneratedContent) throws

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    public var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Int : Generable {

    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema { get }

    /// Creates an instance from content generated by a model.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. To manually initialize your type from generated content,
    /// decode the values as shown below:
    ///
    /// ```swift
    /// struct Person: ConvertibleFromGeneratedContent {
    ///     var name: String
    ///     var age: Int
    ///
    ///     init(_ content: GeneratedContent) {
    ///         self.name = try content.value(forProperty: "firstName")
    ///         self.age = try content.value(forProperty: "ageInYears")
    ///     }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleToGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleToGeneratedContent/generatedContent``.
    ///
    /// - SeeAlso: `@Generable` macro ``Generable(description:)``
    public init(_ content: GeneratedContent) throws

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    public var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Float : Generable {

    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema { get }

    /// Creates an instance from content generated by a model.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. To manually initialize your type from generated content,
    /// decode the values as shown below:
    ///
    /// ```swift
    /// struct Person: ConvertibleFromGeneratedContent {
    ///     var name: String
    ///     var age: Int
    ///
    ///     init(_ content: GeneratedContent) {
    ///         self.name = try content.value(forProperty: "firstName")
    ///         self.age = try content.value(forProperty: "ageInYears")
    ///     }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleToGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleToGeneratedContent/generatedContent``.
    ///
    /// - SeeAlso: `@Generable` macro ``Generable(description:)``
    public init(_ content: GeneratedContent) throws

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    public var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Double : Generable {

    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema { get }

    /// Creates an instance from content generated by a model.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. To manually initialize your type from generated content,
    /// decode the values as shown below:
    ///
    /// ```swift
    /// struct Person: ConvertibleFromGeneratedContent {
    ///     var name: String
    ///     var age: Int
    ///
    ///     init(_ content: GeneratedContent) {
    ///         self.name = try content.value(forProperty: "firstName")
    ///         self.age = try content.value(forProperty: "ageInYears")
    ///     }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleToGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleToGeneratedContent/generatedContent``.
    ///
    /// - SeeAlso: `@Generable` macro ``Generable(description:)``
    public init(_ content: GeneratedContent) throws

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    public var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Decimal : Generable {

    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema { get }

    /// Creates an instance from content generated by a model.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. To manually initialize your type from generated content,
    /// decode the values as shown below:
    ///
    /// ```swift
    /// struct Person: ConvertibleFromGeneratedContent {
    ///     var name: String
    ///     var age: Int
    ///
    ///     init(_ content: GeneratedContent) {
    ///         self.name = try content.value(forProperty: "firstName")
    ///         self.age = try content.value(forProperty: "ageInYears")
    ///     }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleToGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleToGeneratedContent/generatedContent``.
    ///
    /// - SeeAlso: `@Generable` macro ``Generable(description:)``
    public init(_ content: GeneratedContent) throws

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    public var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Array : Generable where Element : Generable {

    /// A representation of partially generated content
    public typealias PartiallyGenerated = [Element.PartiallyGenerated]

    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Array : ConvertibleToGeneratedContent where Element : ConvertibleToGeneratedContent {

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    public var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Array : ConvertibleFromGeneratedContent where Element : ConvertibleFromGeneratedContent {

    /// Creates an instance from content generated by a model.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. To manually initialize your type from generated content,
    /// decode the values as shown below:
    ///
    /// ```swift
    /// struct Person: ConvertibleFromGeneratedContent {
    ///     var name: String
    ///     var age: Int
    ///
    ///     init(_ content: GeneratedContent) {
    ///         self.name = try content.value(forProperty: "firstName")
    ///         self.age = try content.value(forProperty: "ageInYears")
    ///     }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleToGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleToGeneratedContent/generatedContent``.
    ///
    /// - SeeAlso: `@Generable` macro ``Generable(description:)``
    public init(_ content: GeneratedContent) throws
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Never : Generable {

    /// An instance of the generation schema.
    public static var generationSchema: GenerationSchema { get }

    /// Creates an instance from content generated by a model.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. To manually initialize your type from generated content,
    /// decode the values as shown below:
    ///
    /// ```swift
    /// struct Person: ConvertibleFromGeneratedContent {
    ///     var name: String
    ///     var age: Int
    ///
    ///     init(_ content: GeneratedContent) {
    ///         self.name = try content.value(forProperty: "firstName")
    ///         self.age = try content.value(forProperty: "ageInYears")
    ///     }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleToGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleToGeneratedContent/generatedContent``.
    ///
    /// - SeeAlso: `@Generable` macro ``Generable(description:)``
    public init(_ content: GeneratedContent) throws

    /// This instance represented as generated content.
    ///
    /// Conformance to this protocol is provided by the `@Generable` macro.
    /// A manual implementation may be used to map values onto properties using
    /// different names. Use the generated content property as shown below, to
    /// manually return a new ``GeneratedContent`` with the properties you specify.
    ///
    /// ```swift
    /// struct Person: ConvertibleToGeneratedContent {
    ///    var name: String
    ///    var age: Int
    ///
    ///    var generatedContent: GeneratedContent {
    ///        GeneratedContent(properties: [
    ///            "firstName": name,
    ///            "ageInYears": age
    ///        ])
    ///    }
    /// }
    /// ```
    ///
    /// - Important: If your type also conforms to ``ConvertibleFromGeneratedContent``,
    /// it is critical that this implementation be symmetrical with ``ConvertibleFromGeneratedContent/init(_:)``.
    public var generatedContent: GeneratedContent { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension String : InstructionsRepresentable {

    /// An instance that represents the instructions.
    public var instructionsRepresentation: Instructions { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Array : InstructionsRepresentable where Element : InstructionsRepresentable {

    /// An instance that represents the instructions.
    public var instructionsRepresentation: Instructions { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension String : PromptRepresentable {

    /// An instance that represents a prompt.
    public var promptRepresentation: Prompt { get }
}

@available(iOS 26.0, macOS 26.0, *)
@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension Array : PromptRepresentable where Element : PromptRepresentable {

    /// An instance that represents a prompt.
    public var promptRepresentation: Prompt { get }
}

