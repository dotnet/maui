# Test Failures due possible code bugs

## Core.UnitTests.csproj - GetLerp_InterfaceType_ReturnsObjectLerp
- **Confidence**: High
- **Test File**: src/Core/tests/UnitTests/Animations/LerpTests.cs
- **Bug Location**: src/Core/src/Animations/Lerp.cs@174

### Analysis
The GetLerp method has a logic flaw when handling interface types. Interface types like IDisposable don't have BaseType properties (BaseType is null), so the method fails to find the object Lerp that should be returned as a fallback. The method only walks the BaseType hierarchy but doesn't account for interfaces that should inherit from object conceptually. The test is correct in expecting that interface types should return the object Lerp.

### Suggested Fix
The GetLerp method needs to be modified to handle interface types. When the BaseType chain traversal is complete and no Lerp is found, the method should fall back to checking for typeof(object) in the Lerps dictionary. This can be done by adding a final fallback check: `if (lerp == null && type.IsInterface) { Lerps.TryGetValue(typeof(object), out lerp); }` before the return statement, or more generally, always try the object type as a final fallback.

## Core.UnitTests.csproj - GetLerp_NullType_ReturnsNull
- **Confidence**: High
- **Test File**: src/Core/tests/UnitTests/Animations/LerpTests.cs
- **Bug Location**: src/Core/src/Animations/Lerp.cs@177

### Analysis
The GetLerp method throws ArgumentNullException when passed a null Type parameter because Dictionary.TryGetValue does not accept null keys. The method should handle null input gracefully and return null as expected by the test. The issue is in the production code at line 177 where it attempts to use the null type parameter as a dictionary key without first checking for null.

### Suggested Fix
The GetLerp method needs to add a null check at the beginning. The fix would be to add `if (type == null) return null;` before line 177. This would handle the null case gracefully and prevent the ArgumentNullException from being thrown when trying to use null as a dictionary key.

## Core.UnitTests.csproj - IndexOfChar_NullString_ThrowsArgumentNullException
- **Confidence**: High
- **Test File**: src/Core/tests/UnitTests/Extensions/StringExtensionsTests.cs
- **Bug Location**: src/Core/src/Extensions/StringExtensions.cs@19

### Analysis
The IndexOfChar extension method does not perform null checking on its toSearch parameter. When a null string is passed, it attempts to call IndexOf on the null reference, resulting in a NullReferenceException instead of the expected ArgumentNullException. The test is correctly expecting an ArgumentNullException for null input, which is the standard behavior for string methods.

### Suggested Fix
The IndexOfChar method needs null parameter validation. Add a null check at the beginning of the method: `if (toSearch == null) throw new ArgumentNullException(nameof(toSearch));`. The fixed method should look like:

```csharp
public static int IndexOfChar(this string toSearch, char character)
{
    if (toSearch == null)
        throw new ArgumentNullException(nameof(toSearch));
        
#if NETSTANDARD2_0
    return toSearch.IndexOf(character);
#else
    return toSearch.IndexOf(character, StringComparison.Ordinal);
#endif
}
```

## Core.UnitTests.csproj - TryGetTarget_WeakReferenceWithIncompatibleTarget_ReturnsFalseAndSetsTargetToNull
- **Confidence**: High
- **Test File**: src/Core/tests/UnitTests/WeakReferenceExtensionsTests.cs
- **Bug Location**: src/Core/src/WeakReferenceExtensions.cs@14

### Analysis
The TryGetTarget<T> method in WeakReferenceExtensions.cs performs a direct cast on line 14 without checking type compatibility. When the WeakReference contains an integer (42) and we try to get it as a string, the cast (T?)self.Target throws an InvalidCastException. The test correctly expects the method to return false and set target to null for incompatible types, but the production code doesn't handle this scenario gracefully.

### Suggested Fix
The TryGetTarget<T> method needs to be modified to check type compatibility before casting. Replace line 14 with: `target = self.Target is T validTarget ? validTarget : null;` This will safely check if the target is of the correct type and assign it if compatible, or null if not, instead of throwing an exception.

