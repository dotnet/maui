# PR Review: #20467 - Inheriting Visual States

## ‚úÖ Final Recommendation: APPROVE

**Rationale:**
1. **Fix is correct** - Gate verification confirms the fix resolves the issue (tests FAIL without fix, PASS with fix)
2. **Clean implementation** - PR's approach (merge in Setter.Apply) is cleaner than alternatives (explored Style.ApplyCore approach - works but more complex)
3. **Well-isolated** - New `MergeWithParent()` extension method is reusable and testable
4. **Comprehensive testing** - Added unit test validates both visual states work correctly
5. **No breaking changes** - Only adds functionality, doesn't change existing behavior

**Improvements Made:**
- ‚úÖ Added unit test `VisualStatesInheritFromParentStyle` to validate the fix
- ‚úÖ Verified test correctly catches the bug (FAILS without fix)
- ‚úÖ Explored alternative approaches (Style.ApplyCore) - confirmed PR's approach is superior

**Suggested PR Description Update:**
Add the required NOTE block at the top and "Issues Fixed" section with test information.

---

**Date:** 2026-01-10 | **Issue:** None (community PR) | **PR:** [#20467](https://github.com/dotnet/maui/pull/20467)

## ‚úÖ Status: COMPLETE

| Phase | Status |
|-------|--------|
| Pre-Flight | ‚úÖ COMPLETE |
| üß™ Tests | ‚úÖ COMPLETE |
| üö¶ Gate | ‚úÖ PASSED |
| üîß Fix | ‚úÖ COMPLETE |
| üìã Report | ‚úÖ COMPLETE |

---

<details>
<summary><strong>üìã Issue Summary</strong></summary>

**Problem:** Visual states from parent styles aren't being applied to derived styles.

**Scenario:**
When a derived style (with `BasedOn` referencing a parent style) defines visual states in the same `VisualStateGroup` as the parent, only the derived style's visual states work. The parent style's visual states in that group are ignored.

**Example:**
- Parent style defines `Custom` visual state
- Derived style (BasedOn parent) defines `Normal` visual state in same `CommonStates` group
- Result: `Custom` state is ignored (doesn't apply colors)

**Steps to Reproduce:**
1. Define parent style with visual state (e.g., `Custom`)
2. Create derived style with `BasedOn` parent
3. Add different visual state to same group (e.g., `Normal`)
4. Try to switch to parent's visual state via `VisualStateManager.GoToState()`

**Expected:** Both parent and derived visual states should work
**Actual:** Only derived style's visual states work

**Platforms Affected:**
- [x] iOS
- [x] Android
- [x] Windows
- [x] MacCatalyst
(All platforms - this is XAML/Style logic)

**Related Work:**
- PR #19812 mentioned in comments (PointerOver priority) - closed, unrelated to inheritance
- Missing before/after images in PR description

</details>

<details>
<summary><strong>üìÅ Files Changed</strong></summary>

| File | Type | Changes |
|------|------|---------|
| `src/Controls/src/Core/Setter.cs` | Fix | +7 lines |
| `src/Controls/src/Core/VisualStateManager.cs` | Fix | +19 lines |

**No test files included.**

</details>

<details>
<summary><strong>üí¨ PR Discussion Summary</strong></summary>

**Key Comments:**
- @MartyIX: Asked about relationship to PR #19812 (Feb 10, 2024) - author hasn't responded
- @MartyIX: Noted before/after images are missing from PR description (Mar 8, 2025)
- @jsuarezruiz: Triggered Azure Pipelines (May 13, 2024)
- Bot: Community contribution

**Reviewer Feedback:**
- No formal reviews submitted
- No inline code comments

**Disagreements to Investigate:**
None

**Author Uncertainty:**
- No response to question about relationship to PR #19812
- Missing visual comparison (images broken in PR description)

</details>

<details>
<summary><strong>üß™ Tests</strong></summary>

**Status**: ‚è≥ PENDING


- [x] Unit test created: `VisualStatesInheritFromParentStyle`
- [x] Tests reproduce the issue
- [x] Tests follow xUnit pattern

**Test Files:**
- Unit Test: `src/Controls/tests/Core.UnitTests/VisualStateManagerTests.cs`

**Test Verification:**
- ‚ùå WITHOUT fix: Test FAILS (Expected 2 states, found 1: Normal)
- ‚úÖ WITH fix: Test PASSES (Both Normal and Custom states present)


</details>

<details>
<summary><strong>üö¶ Gate - Test Verification</strong></summary>

**Status**: ‚è≥ PENDING

- [ ] Tests FAIL without fix (bug reproduced)
- [ ] Tests PASS with fix (bug resolved)

**Result:** PASSED ‚úÖ

**Verification Details:**
- Test: `VisualStatesInheritFromParentStyle`
- WITHOUT fix: `Expected at least 2 states (Normal + Custom), but found 1: Normal`
- WITH fix: Both states present, switching between them works correctly

</details>

<details>
<summary><strong>üîß Fix Candidates</strong></summary>

**Status**: ‚è≥ PENDING

| # | Source | Approach | Test Result | Files Changed | Notes |
|---|--------|----------|-------------|---------------|-------|
| PR | PR #20467 | Merge parent visual states into derived style during `Setter.Apply()` | ‚úÖ PASS (Gate) | `Setter.cs` (+7), `VisualStateManager.cs` (+19) | Original PR - validated by Gate |

**PR's Approach:**
1. In `Setter.Apply()`: When applying visual state groups, check if target already has visual states
2. If yes: Call new `MergeWithParent()` extension method
3. `MergeWithParent()`: For matching VisualStateGroup names, add parent's visual states that don't exist in derived style


| 1 | try-fix | Merge visual states at Style.ApplyCore() level before applying setters | ‚úÖ PASS | `Style.cs` (+36) | Works! Alternative approach - merges at style application time instead of setter application time |

**Exhausted:** Yes (explored both viable approaches)
**Selected Fix:** PR's fix

**Comparison:**
Both fixes work correctly. Here's the trade-off analysis:

| Criterion | PR's Fix (Setter.Apply) | try-fix #1 (Style.ApplyCore) |
|-----------|-------------------------|------------------------------|
| **Files changed** | 2 files (+26 lines) | 1 file (+36 lines) |
| **Complexity** | Lower - isolated extension method | Higher - Style.cs logic more complex |
| **Scope** | Narrow - only affects visual state setters | Broader - affects all style applications |
| **Reusability** | MergeWithParent() is reusable | Merge logic embedded in ApplyCore |
| **Maintainability** | Better - extension method is testable in isolation | Harder - mixed with style application logic |
| **Performance** | Merges only when setter applied | Pre-merges before application (slightly earlier) |

**Verdict:** PR's fix is superior because:
1. **Better separation of concerns** - Visual state merging logic lives with VisualStateManager
2. **More reusable** - Extension method could be used elsewhere if needed
3. **Easier to maintain** - Isolated logic is easier to test and modify
4. **Cleaner** - Doesn't complicate Style.ApplyCore with domain-specific logic

Both approaches validate that merging parent visual states is the correct solution. The PR author chose the cleaner implementation point.

</details>
