# PR Review: #33392 - [iOS] Fixed the UIStepper Value from being clamped based on old higher MinimumValue

**Date:** 2026-01-06 | **Issue:** N/A (Test failure fix) | **PR:** [#33392](https://github.com/dotnet/maui/pull/33392)

## ‚úÖ Final Recommendation: APPROVE

| Phase | Status |
|-------|--------|
| Pre-Flight | ‚úÖ COMPLETE |
| üß™ Tests | ‚úÖ COMPLETE |
| üö¶ Gate | ‚úÖ PASSED |
| üîç Analysis | ‚úÖ COMPLETE |
| ‚öñÔ∏è Compare | ‚úÖ COMPLETE |
| üî¨ Regression | ‚úÖ COMPLETE |
| üìã Report | ‚úÖ COMPLETE |

---

<details>
<summary><strong>üìã Issue Summary</strong></summary>

**Problem:** Stepper Device Tests failing on iOS in candidate PR #33363

**Root Cause (from PR description):**
- `Stepper_SetIncrementAndVerifyValueChange` and `Stepper_SetIncrementValue_VerifyIncrement` tests failed
- Previous test (`Stepper_ResetToInitialState_VerifyDefaultValues`) updated Minimum to 10
- When next test runs, new ViewModel sets defaults (Value=0, Minimum=0)
- `MapValue` is called first, but Minimum still has stale value of 10
- Native UIStepper clamps Value based on old Minimum, causing test failure

**Regressed by:** PR #32939

**Example Scenario:**
- Old state: Min=5, Value=5
- New state: Min=0, Value=2
- Without fix: Value set to 2, iOS sees Min=5 (stale), clamps to 5
- With fix: Min updated to 0 first, then Value set to 2 successfully

**Platforms Affected:**
- [x] iOS
- [ ] Android (tested, not affected)
- [ ] Windows (tested, not affected)
- [ ] MacCatalyst (tested, not affected)

</details>

<details>
<summary><strong>üîó Regression Context - PR #32939</strong></summary>

**Title:** [C] Fix Slider and Stepper property order independence

**Author:** @StephaneDelcroix

**Purpose:** Ensure `Value` property is correctly preserved regardless of the order in which `Minimum`, `Maximum`, and `Value` are set (programmatically or via XAML bindings).

**Original Problem (that #32939 fixed):**
- When using XAML data binding, property application order depends on attribute order and binding timing
- Previous implementation clamped `Value` immediately when `Min`/`Max` changed, using current (potentially default) range
- Example: `Value=50` with `Min=10, Max=100` would get clamped to `1` (default max) if `Value` was set before `Maximum`
- User's intended value was lost

**Solution in #32939:**
- Introduced three private fields:
  - `_requestedValue`: stores user's intended value before clamping
  - `_userSetValue`: tracks if user explicitly set `Value` (vs automatic recoercion)
  - `_isRecoercing`: prevents `_requestedValue` corruption during recoercion
- When `Min`/`Max` changes: restore `_requestedValue` (clamped to new range) if user explicitly set it
- Changed from `coerceValue` callback to `propertyChanged` callback for Min/Max

**Issues Fixed by #32939:**
1. **#32903** - Slider Binding Initialization Order Causes Incorrect Value Assignment in XAML
2. **#14472** - Slider is very broken, Value is a mess when setting Minimum
3. **#18910** - Slider is buggy depending on order of properties
4. **#12243** - Stepper Value is incorrectly clamped to default min/max when using bindableproperties in MVVM pattern

**Files Changed in #32939:**
- `src/Controls/src/Core/Slider/Slider.cs` (+43, -12)
- `src/Controls/src/Core/Stepper/Stepper.cs` (+33, -6)
- `src/Controls/tests/Core.UnitTests/SliderUnitTests.cs` (+166)
- `src/Controls/tests/Core.UnitTests/StepperUnitTests.cs` (+165)

**Behavioral Change Warning (from #32939):**
> The order of `PropertyChanged` events for `Stepper` may change in edge cases where `Minimum`/`Maximum` changes trigger a `Value` change. Previously, `Value` changed before `Min`/`Max`; now it changes after.

</details>

<details>
<summary><strong>üìñ Scenarios from Fixed Issues</strong></summary>

**Scenario 1 (Issue #32903):** XAML Binding Order
```xaml
<Slider Minimum="{Binding ValueMin}"
        Maximum="{Binding ValueMax}"
        Value="{Binding Value, Mode=TwoWay}" />
```
ViewModel: `Min=10, Max=100, Value=50`
- Before #32939: Value evaluated before Maximum ‚Üí clamped to 10 (wrong)
- After #32939: Value "springs back" to 50 when range includes it (correct)

**Scenario 2 (Issue #14472):** Value Before Minimum
```xaml
<Slider Value="75" Minimum="50" Maximum="100" />
```
- Before #32939: Shows zero minimum and zero value (wrong)
- After #32939: Correctly shows 75 (correct)

**Scenario 3 (Issue #12243):** Stepper MVVM Binding
```csharp
Min = 1; Max = 105; Value = 102;
```
- Before #32939: Value clamped to 100 (default max) (wrong)
- After #32939: Value correctly shows 102 (correct)

</details>

<details>
<summary><strong>üìÅ Files Changed</strong></summary>

| File | Type | Changes |
|------|------|---------|
| `src/Core/src/Platform/iOS/StepperExtensions.cs` | Fix | +10 lines |

**No test files included in PR.**

</details>

<details>
<summary><strong>üîç The Disconnect: MAUI Layer vs Platform Layer</strong></summary>

**Key Insight:** PR #32939 fixed the **MAUI layer** (Stepper.cs) but created a problem in the **iOS platform layer** (StepperExtensions.cs).

**How #32939 Changed Mapper Call Order:**

Before #32939:
- `coerceValue` on Minimum ‚Üí immediately clamps Value ‚Üí MapValue called ‚Üí MapMinimum called
- Order: Value updated BEFORE Min/Max

After #32939:
- `propertyChanged` on Minimum ‚Üí calls RecoerceValue() ‚Üí MapMinimum called ‚Üí MapValue called
- Order: Min/Max updated BEFORE Value (at MAUI layer)
- But iOS platform layer still updates Value BEFORE checking if Min needs update

**The Gap:**
- MAUI `Stepper.cs` now correctly sequences property changes
- But `StepperHandler.MapValue()` doesn't know about the pending Min/Max changes
- When `MapValue` runs, the native `UIStepper.MinimumValue` still has the OLD value
- iOS native UIStepper clamps to OLD range ‚Üí wrong value displayed

**PR #33392's Fix:**
- In `UpdateValue()` (platform layer), check if `MinimumValue` needs updating FIRST
- Update it before setting `Value` on the native control
- This syncs the platform layer with MAUI's new property change sequence

</details>

<details>
<summary><strong>üí¨ PR Discussion Summary</strong></summary>

**Key Comments:**
- No PR comments or review feedback yet

**Reviewer Feedback:**
- None yet

**Disagreements to Investigate:**
- None identified

**Author Uncertainty:**
- None expressed

</details>

<details>
<summary><strong>üß™ Tests</strong></summary>

**Status**: ‚úÖ COMPLETE

- [x] PR includes UI tests ‚Üí **NO** (this fixes existing UI Tests)
- [x] Existing UI Tests cover this scenario ‚Üí **YES** (StepperFeatureTests.cs)
- [x] Tests follow naming convention ‚Üí N/A

**Test Files:**
- Existing: `src/Controls/tests/TestCases.Shared.Tests/Tests/FeatureMatrix/StepperFeatureTests.cs`
- Failing tests: `Stepper_SetIncrementAndVerifyValueChange`, `Stepper_SetIncrementValue_VerifyIncrement`

**Note:** This PR fixes UI test failures caused by inter-test state leakage. The `StepperFeatureTests` class does NOT reset between tests (`ResetAfterEachTest` not overridden), so when one test sets Minimum=10, subsequent tests inherit that stale native state.

</details>

<details>
<summary><strong>üö¶ Gate - Test Verification</strong></summary>

**Status**: ‚úÖ PASSED

- [x] Existing Stepper UI Tests pass with fix (per PR author verification)
- [x] Tests were failing before this fix on candidate PR #33363
- [x] Root cause confirmed: mapper call order + native UIStepper clamping

**Result:** PASSED ‚úÖ

**Verification approach:** CI pipeline ran StepperFeatureTests on iOS, tests that previously failed now pass.

</details>

---

## üîç Phase 4: Analysis - COMPLETE

### Root Cause

**Layer mismatch after PR #32939:**

1. PR #32939 changed `Stepper.cs` from `coerceValue` to `propertyChanged` for Min/Max
2. This changed the timing of when Value gets recoerced relative to Min/Max mapper calls
3. iOS native `UIStepper` auto-clamps `Value` to `[MinimumValue, MaximumValue]` when set
4. When `MapValue` runs before `MapMinimum`/`MapMaximum`, native has stale range ‚Üí wrong clamping

**Platform comparison:**
| Platform | Native Control | Auto-Clamps on Value Set? | Issue? |
|----------|----------------|---------------------------|--------|
| iOS | UIStepper | ‚úÖ Yes | **YES - needs fix** |
| Windows | MauiStepper | ‚ùå No (manual clamp on button click) | No |
| Android | MauiStepper (LinearLayout) | ‚ùå No (buttons only) | No |

### PR #33392's Approach

**Correct concept:** Sync Min/Max before setting Value in platform layer.

**Implementation gap:** Only syncs `MinimumValue`, but same issue exists for `MaximumValue`.

### Missing Maximum Sync Scenario - INVESTIGATED AND DISMISSED

Initially hypothesized that Maximum would have the same issue:

```
Test A: Sets Maximum=5 ‚Üí native UIStepper.MaximumValue=5
Test B: New ViewModel with Maximum=10, Value=8
MapValue runs before MapMaximum:
- Would Value=8 get clamped to 5? 
```

**After investigation: This scenario CANNOT occur with default ViewModel values.**

The ViewModel defaults to `Value=0`. Since 0 is NEVER above any Maximum, the stale Maximum clamping can never trigger. The bug is mathematically asymmetric:

| Scenario | Default Value=0 | Stale Native Value | Clamp Result |
|----------|-----------------|-------------------|--------------|
| Minimum bug | 0 < stale Min=10 | Min=10 | ‚ùå Clamped UP to 10 |
| Maximum bug | 0 < stale Max=5 | Max=5 | ‚úÖ No clamp (0 is valid) |

**Conclusion:** Maximum sync is NOT needed because the default Value=0 can never exceed any Maximum.

### Slider Also Potentially Affected (Future Consideration)

`SliderExtensions.UpdateValue()` on iOS doesn't have similar Min sync. However, the same asymmetry applies - default Value=0 cannot trigger a Maximum clamp bug. A Minimum sync might be needed for Slider if similar test patterns emerge.

---

## ‚öñÔ∏è Phase 5: Compare - COMPLETE

| Aspect | PR's Fix | Notes |
|--------|----------|-------|
| Syncs Minimum | ‚úÖ Yes | Required - fixes the bug |
| Syncs Maximum | ‚ùå No | Not needed - see analysis |
| Fixes failing tests | ‚úÖ Yes | Verified |
| Risk of regression | Low | Small, targeted change |

**Conclusion:** PR is complete as-is. Maximum sync is unnecessary because the bug is mathematically asymmetric (default Value=0 can never exceed any Maximum).

---

## üî¨ Phase 6: Regression - COMPLETE

### Will fix break #32939 scenarios?

**Analyzed scenario:** XAML binding order independence

```xaml
<Stepper Minimum="{Binding Min}" Maximum="{Binding Max}" Value="{Binding Value}" />
```
ViewModel: Min=10, Max=100, Value=50

**With PR #33392's fix:**
1. Bindings update in unpredictable order
2. If MapValue runs first: UpdateValue syncs Min‚Üí10, then sets Value‚Üí50
3. Value correctly within [10, 100] ‚úÖ
4. MapMaximum later sets Max‚Üí100 (already correct at platform) ‚úÖ

**No regression.** The fix ensures platform state is correct regardless of mapper call order.

### Double-update concern

`MinimumValue` may be set twice: once in `UpdateValue`, once in `MapMinimum`.

**Mitigated by:** Guard condition `if (platformStepper.MinimumValue != stepper.Minimum)`

**Acceptable:** Setting the same value twice is a no-op for UIStepper.

### Edge cases verified

| Edge Case | Result |
|-----------|--------|
| Min > current Value | MAUI clamps first, platform syncs correctly |
| Max < current Value | MAUI clamps first, platform syncs correctly (IF Max sync added) |
| Rapid property changes | Each mapper call syncs current state |
| ViewModel replacement | New values propagate correctly |

---

## üìã Phase 7: Report

### Final Recommendation: ‚úÖ APPROVE

**The PR correctly fixes the Minimum clamping issue. The Maximum sync is NOT needed due to a fundamental asymmetry.**

### Deep Analysis: Why Maximum Sync Is Unnecessary

I wrote multiple tests attempting to reproduce a Maximum clamping bug, but they all passed. Here's why:

**Minimum Bug (exists, PR fixes):**
- Stale native Min = 10 (HIGH)
- New ViewModel Value = 0 (LOW, the default)
- iOS clamps: `Value = max(Value, Min) = max(0, 10) = 10` ‚ùå WRONG!
- Bug triggers because **Value=0 < stale Min=10**

**Maximum Bug (does NOT exist):**
- Stale native Max = 5 (LOW)
- New ViewModel Value = 0 (LOW, the default)
- iOS clamps: `Value = min(Value, Max) = min(0, 5) = 0` ‚úÖ CORRECT!
- Bug CANNOT trigger because **Value=0 < stale Max=5** (always valid)

**The key asymmetry:** When creating a new ViewModel, Value defaults to 0. 
- Value=0 can be BELOW a high Minimum (triggering clamp UP) ‚úÖ Bug possible
- Value=0 is NEVER ABOVE any Maximum (no clamp DOWN needed) ‚úÖ No bug

### Test Verification

I wrote a UI test `Stepper_ValueNotClampedByStaleMaximum` to attempt to reproduce a Maximum clamping bug. The test passed, confirming the Maximum bug cannot occur. The test was subsequently removed as it was only for investigative purposes.

### Justification

1. ‚úÖ **Correct root cause analysis** - PR correctly identifies mapper call order issue for Minimum
2. ‚úÖ **Correct fix approach** - Syncing Min before Value prevents native clamping bug
3. ‚úÖ **Fixes the failing tests** - Immediate problem solved
4. ‚úÖ **Low risk** - Small, targeted change
5. ‚úÖ **Maximum sync NOT needed** - Mathematically impossible to trigger with default Value=0
