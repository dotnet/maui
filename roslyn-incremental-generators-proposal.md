# Roslyn Incremental Generators: Two-Phase Compilation for Cross-Generator Dependencies

## Problem Statement

Modern .NET applications, particularly .NET MAUI projects, commonly depend on multiple source generators that need to reference types created by other generators. Currently, source generators run independently without visibility into types generated by their peers, causing compilation failures when one generator depends on types produced by another.

### Real-World Scenario

A typical .NET MAUI application might use:
- **XAML** (source generated code-behind)
- **Blazor** (source generated components)
- **CommunityToolkit.Mvvm** (observable properties, commands)
- **MAUI Community Toolkit** (behaviors, converters)

When these generators produce types that other generators need to reference, the compilation fails because all generators see only the initial compilation state, not each other's contributions.

### Impact

This limitation forces framework authors to:
1. Implement workarounds that don't scale
2. Duplicate generator logic to produce dependent types
3. Use fragile heuristics and allow compiler errors
4. Limit cross-library interoperability

## Current Workarounds in .NET MAUI

### 1. Nested Generator Execution
We invoke one source generator from within another generator's `RegisterImplementationSourceOutput` to ensure dependent types exist. This approach:
- Only works for generators we control
- Doesn't scale to third-party generators
- Violates generator independence principles
- Creates tight coupling between generators

### 2. Heuristic-Based Type Guessing
We make assumptions about generated type shapes and allow compilation errors when assumptions fail. This approach:
- Produces poor developer experience
- Creates cryptic error messages
- Fails unpredictably with version updates
- Requires extensive documentation of edge cases

## Existing Proposals and Their Limitations

### MSBuild-Based Ordering (`Before`/`After` Properties)

Previous proposals suggest using MSBuild properties to define generator execution order:


**Limitations:**
1. **Knowledge requirement** - Developers must know all generators in their dependency tree
2. **Fragility** - Transitive dependencies break ordering assumptions
3. **Performance** - Forces full recompilation when any generator in the chain changes
4. **Circular dependencies** - No clear resolution strategy
5. **Maintenance burden** - Version updates can break ordering contracts

## Proposed Solution: Two-Phase Incremental Compilation

### Core Concept

Introduce a two-phase compilation model where generators can contribute **type declarations** (signatures only) in phase one, and **implementations** in phase two. This mirrors the distinction already present between `RegisterSourceOutput` and `RegisterImplementationSourceOutput`, but makes it more explicit and structured.

### API Design

```csharp
public void Initialize(IncrementalGeneratorInitializationContext context)
{
    // Phase 1: Declare types and signatures
    // These are visible to other generators in Phase 2
    context.RegisterDeclarationOutput(
        source: ...,
        action: (context, source) => 
        {
            // Emit partial types, method signatures, property declarations
            // No implementation bodies
        });
    
    // Phase 2: Provide implementations
    // Can see all declarations from Phase 1
    context.RegisterImplementationOutput(
        source: ...,
        action: (context, source) => 
        {
            // Emit method bodies, complete implementations
            // Has access to enriched compilation including all declarations
        });
}
```

### Execution Model

#### Phase 1: Declaration Phase
1. Create `DeclarationCompilation` from initial user code
2. Execute all `RegisterDeclarationOutput` actions across all generators
3. Collect generated declaration sources (partial types, signatures)
4. Create `EnrichedCompilation` = `DeclarationCompilation` + declaration sources
5. Provide `EnrichedCompilationProvider` to Phase 2

#### Phase 2: Implementation Phase
1. Use `EnrichedCompilation` that includes all generator declarations
2. Execute all `RegisterImplementationOutput` actions
3. Each generator can now see types declared by other generators
4. Produce final compilation output

### Key Properties

**Determinism**: Phase 1 cannot access other generators' declarations, preventing circular dependencies and non-deterministic behavior.

**Performance**: Only declarations trigger Phase 2 invalidation, not implementation changes. Implementation-only changes don't cascade.

**Compatibility**: Existing single-phase generators continue to work. The two-phase model is opt-in.

**Scalability**: Generators don't need to know about each other. The runtime manages visibility automatically.

## Concrete Example: MAUI + CommunityToolkit.Mvvm

### Before (Fails)

```csharp
// CommunityToolkit.Mvvm generates this
public partial class MainViewModel : ObservableObject
{
    [ObservableProperty]
    private string _title;
    // Generates: public string Title { get; set; }
}

// MAUI XAML generator tries to reference it
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        BindingContext = new MainViewModel(); // Error: MainViewModel.Title doesn't exist yet
    }
}
```

### After (Two-Phase)

**Phase 1:**
```csharp
// CommunityToolkit.Mvvm in RegisterDeclarationOutput
public partial class MainViewModel : ObservableObject
{
    public string Title { get; set; } // Declaration only
}
```

**Phase 2:**
```csharp
// MAUI XAML generator in RegisterImplementationOutput
public partial class MainPage : ContentPage
{
    public MainPage()
    {
        BindingContext = new MainViewModel(); // ✓ MainViewModel.Title is visible
        Title = "Hello"; // ✓ Compiles successfully
    }
}

// CommunityToolkit.Mvvm in RegisterImplementationOutput
public partial class MainViewModel : ObservableObject
{
    private string _title;
    public string Title 
    { 
        get => _title;
        set => SetProperty(ref _title, value); // Implementation
    }
}
```

## Benefits

1. **No explicit ordering required** - Generators don't need to declare dependencies
2. **Better incremental compilation** - Implementation changes don't cascade
3. **Improved developer experience** - Fewer cryptic compilation errors
4. **Framework interoperability** - Enables rich ecosystem of composable generators
5. **Backward compatible** - Existing generators continue to work
6. **Prevention of circular dependencies** - Phase 1 isolation ensures deterministic compilation

## Comparison with Existing APIs

| API | Phase | Visibility | Current Behavior |
|-----|-------|------------|------------------|
| `RegisterPostInitializationOutput` | Pre-compilation | N/A | Global using directives, attributes |
| **`RegisterDeclarationOutput`** (proposed) | Phase 1 | Initial compilation only | Type signatures, partial declarations |
| **`RegisterImplementationOutput`** (enhanced) | Phase 2 | Declarations from all generators | Complete implementations |
| `RegisterSourceOutput` | Mixed (today) | Initial compilation only | Both declaration and implementation |

## Open Questions

1. **Naming**: `RegisterDeclarationOutput` vs `RegisterSignatureOutput` vs reusing `RegisterSourceOutput`?
2. **Granularity**: Should declaration vs implementation be per-generator or per-output?
3. **Diagnostics**: How should errors in Phase 1 affect Phase 2 execution?
4. **Incremental behavior**: What level of caching between phases?

## Related Work

- [Roslyn Issue #57589](https://github.com/dotnet/roslyn/issues/57589) - Similar two-phase proposal (Oct 2020)
- [Source Generators Cookbook](https://github.com/dotnet/roslyn/blob/main/docs/features/source-generators.cookbook.md)
- Current `RegisterImplementationSourceOutput` documentation

## Implementation Considerations

This proposal would require:
1. Extensions to `IncrementalGeneratorInitializationContext`
2. New compilation pipeline stages in Roslyn
3. Updates to incremental compilation caching strategy
4. Generator testing infrastructure updates
5. Documentation and migration guidance

---

**Author**: .NET MAUI Team  
**Date**: November 2025  
**Status**: Draft Proposal
